<!DOCTYPE html>
<!--[if IE]><![endif]-->
<html>
  
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
    <title>Getting Started </title>
    <meta name="viewport" content="width=device-width">
    <meta name="title" content="Getting Started ">
    <meta name="generator" content="docfx 2.58.9.0">
    
    <link rel="shortcut icon" href="../favicon.ico">
    <link rel="stylesheet" href="../styles/docfx.vendor.css">
    <link rel="stylesheet" href="../styles/docfx.css">
    <link rel="stylesheet" href="../styles/main.css">
    <meta property="docfx:navrel" content="../toc.html">
    <meta property="docfx:tocrel" content="toc.html">
    
    
    
  </head>
  <body data-spy="scroll" data-target="#affix" data-offset="120">
    <div id="wrapper">
      <header>
        
        <nav id="autocollapse" class="navbar navbar-inverse ng-scope" role="navigation">
          <div class="container">
            <div class="navbar-header">
              <button type="button" class="navbar-toggle" data-toggle="collapse" data-target="#navbar">
                <span class="sr-only">Toggle navigation</span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
              </button>
              
              <a class="navbar-brand" href="../index.html">
                <img id="logo" class="svg" src="../logo.svg" alt="">
              </a>
            </div>
            <div class="collapse navbar-collapse" id="navbar">
              <form class="navbar-form navbar-right" role="search" id="search">
                <div class="form-group">
                  <input type="text" class="form-control" id="search-query" placeholder="Search" autocomplete="off">
                </div>
              </form>
            </div>
          </div>
        </nav>
        
        <div class="subnav navbar navbar-default">
          <div class="container hide-when-search" id="breadcrumb">
            <ul class="breadcrumb">
              <li></li>
            </ul>
          </div>
        </div>
      </header>
      <div role="main" class="container body-content hide-when-search">
        
        <div class="sidenav hide-when-search">
          <a class="btn toc-toggle collapse" data-toggle="collapse" href="#sidetoggle" aria-expanded="false" aria-controls="sidetoggle">Show / Hide Table of Contents</a>
          <div class="sidetoggle collapse" id="sidetoggle">
            <div id="sidetoc"></div>
          </div>
        </div>
        <div class="article row grid-right">
          <div class="col-md-10">
            <article class="content wrap" id="_content" data-uid="">
<h1 id="getting-started">Getting Started</h1>

<ol>
<li>Set up your project. If you haven't written mods for any Pathfinder game, start with the wiki's <a href="https://github.com/WittleWolfie/OwlcatModdingWiki/wiki/Beginner-Guide">Beginner Guide</a>.</li>
<li>Create a <a href="https://github.com/WittleWolfie/OwlcatModdingWiki/wiki/Publicize-Assemblies">public assembly</a>.</li>
<li>Install <a href="https://www.nuget.org/packages/WW-Blueprint-Core/">WW-Blueprint-Core</a> using <a href="https://docs.microsoft.com/en-us/nuget/what-is-nuget">NuGet</a>.
<ul>
<li>For v1.3.0+ the package is a DLL that <strong>must be merged into your mod assembly</strong></li>
<li>Prior to v1.3.0 the package included either a signed DLL or source code. The source code is still published as a <a href="https://github.com/WittleWolfie/WW-Blueprint-Core/releases">Release on GitHub</a> if you prefer including the source directly.</li>
</ul>
</li>
<li>Make sure your project is configured for .NET 4.7.2 and the latest C# language version
<ul>
<li>In your .csproj file you should have the following properties:</li>
</ul>
<pre><code class="lang-xml">&lt;PropertyGroup&gt;
  &lt;LangVersion&gt;latest&lt;/LangVersion&gt;
  &lt;TargetFramework&gt;net472&lt;/TargetFramework&gt;
&lt;/PropertyGroup&gt;
</code></pre>
</li>
<li>Add the required assembly references:
<ul>
<li>Publicized copy of <code>%WrathPath%\Wrath_Data\Managed\Assembly-CSharp.dll</code></li>
<li><code>%WrathPath%\Wrath_Data\Managed\Owlcat.Runtime.Core.dll</code></li>
<li><code>%WrathPath%\Wrath_Data\Managed\Owlcat.Runtime.Visual.dll</code></li>
<li><code>$WrathPath%\Wrath_Data\Managed\Owlcat.Runtime.UI.dll</code></li>
<li><code>$WrathPath%\Wrath_Data\Managed\UnityEngine.dll</code></li>
<li><code>$WrathPath%\Wrath_Data\Managed\UnityEngine.CoreModule.dll</code></li>
</ul>
</li>
<li>Configure DLL Merging:
<ul>
<li>Install <a href="https://www.nuget.org/packages/ILRepack.MSBuild.Task/">ILRepack.MSBuild.Task</a> using NuGet</li>
<li>Add the following to your .csproj file, using your mod's assembly name in place of <code>MyAssemblyName</code>:</li>
</ul>
<pre><code class="lang-xml">&lt;!-- DLL Merging --&gt;
&lt;Target Name=&quot;ILRepack&quot; AfterTargets=&quot;Build&quot;&gt;
  &lt;ItemGroup&gt;
    &lt;InputAssemblies Include=&quot;BlueprintCore.dll&quot; /&gt;
    &lt;InputAssemblies Include=&quot;MyAssemblyName.dll&quot; /&gt;
    &lt;OutputAssembly Include=&quot;MyAssemblyName.dll&quot; /&gt;
  &lt;/ItemGroup&gt;

  &lt;Message Text=&quot;Merging: @(InputAssemblies) into @(OutputAssembly)&quot; Importance=&quot;High&quot; /&gt;

  &lt;ILRepack
    OutputType=&quot;Dll&quot;
    MainAssembly=&quot;MyAssemblyName.dll&quot;
    OutputAssembly=&quot;@(OutputAssembly)&quot;
    InputAssemblies=&quot;@(InputAssemblies)&quot;
    WorkingDirectory=&quot;$(OutputPath)&quot; /&gt;
&lt;/Target&gt;
</code></pre>
</li>
<li>You're ready to go!</li>
</ol>
<p><a href="tutorials/overview.html">Tutorials</a> explain how to mod the game using the library. The sections below provide an overview of the main features.</p>
<p>If you're having problems check <a href="issues.html">Known Issues</a>.</p>
<p>If you're interested in contributing see <a href="contributing.html">How to Contribute</a>.</p>
<h2 id="blueprint-configurators">Blueprint Configurators</h2>
<p>All blueprint types inheriting from BlueprintScriptableObject have a corresponding configurator. e.g. <a class="xref" href="../api/BlueprintCore.Blueprints.Configurators.Buffs.BuffConfigurator.html">BuffConfigurator</a> is the configurator for <code>BlueprintBuff</code>.</p>
<p>If you write a custom blueprint or use one from a mod you can use <a class="xref" href="../api/BlueprintCore.Blueprints.Configurators.BlueprintConfigurator-1.html">BlueprintConfigurator</a>. This won't expose fields and supported components for the type but allows use of the basic configurator API and validation with any blueprint type:</p>
<p>To use a configurator:</p>
<ol>
<li>Instantiate a configurator using <code>For()</code> or <code>New()</code>
<ul>
<li><code>For()</code> creates a configurator for an existing blueprint</li>
<li><code>New()</code> creates and registers a new blueprint</li>
</ul>
</li>
<li>Modify the blueprint using the configurator methods</li>
<li>Commit the configuration with <a class="xref" href="../api/BlueprintCore.Blueprints.Configurators.BaseBlueprintConfigurator-2.html#BlueprintCore_Blueprints_Configurators_BaseBlueprintConfigurator_2_Configure">Configure()</a>
<ul>
<li>Until this is called, no changes are made to the blueprint</li>
<li>After commit the blueprint is validated and any errors are logged as a warning</li>
</ul>
</li>
</ol>
<pre><code class="lang-C#">BuffConfigurator.New(MyBuffName, MyBuffGuid).AddStatBonus(stat: StatType.Strength, value: 2).Configure();
</code></pre>
<p>This code will create a new <code>BlueprintBuff</code> using the provided name and GUID. When the buff is applied to a unit it
grants +2 to Strength because of the <code>AddStatBonus</code> component.</p>
<h3 id="common-methods">Common Methods</h3>
<ul>
<li><a class="xref" href="../api/BlueprintCore.Blueprints.Configurators.BaseBlueprintConfigurator-2.html#BlueprintCore_Blueprints_Configurators_BaseBlueprintConfigurator_2_AddComponent_Kingmaker_Blueprints_BlueprintComponent_">AddComponent</a>
<ul>
<li>Adds a <code>BlueprintComponent</code> of any type</li>
<li>Used internally by all configurator methods that add a new component</li>
<li>Use this for custom components in your modification</li>
<li>All component types in the base game are supported by type specific methods. e.g. <code>AddStatBonus</code></li>
</ul>
</li>
<li><a class="xref" href="../api/BlueprintCore.Blueprints.Configurators.BaseBlueprintConfigurator-2.html#BlueprintCore_Blueprints_Configurators_BaseBlueprintConfigurator_2_AddUniqueComponent_Kingmaker_Blueprints_BlueprintComponent_BlueprintCore_Blueprints_Configurators_BaseBlueprintConfigurator__0__1__ComponentMerge_System_Action_Kingmaker_Blueprints_BlueprintComponent_Kingmaker_Blueprints_BlueprintComponent__">AddUniqueComponent</a>
<ul>
<li>Similar to <code>AddComponent</code>, but for components for which only one can exist in a blueprint</li>
<li>Supports user defined conflict resolution if multiple components are present. See <a class="xref" href="../api/BlueprintCore.Blueprints.Configurators.BaseBlueprintConfigurator-2.ComponentMerge.html">ComponentMerge</a>.</li>
</ul>
</li>
<li><a class="xref" href="../api/BlueprintCore.Blueprints.Configurators.BaseBlueprintConfigurator-2.html#BlueprintCore_Blueprints_Configurators_BaseBlueprintConfigurator_2_RemoveComponents_System_Func_Kingmaker_Blueprints_BlueprintComponent_System_Boolean__">RemoveComponents</a>
<ul>
<li>Removes any components matching the supplied <code>Func&lt;BlueprintComponent, bool&gt;</code></li>
</ul>
</li>
<li><a class="xref" href="../api/BlueprintCore.Blueprints.Configurators.BaseBlueprintConfigurator-2.html#BlueprintCore_Blueprints_Configurators_BaseBlueprintConfigurator_2_EditComponent__1_System_Action___0__">EditComponent</a>
<ul>
<li>After configuring components, runs the provided <code>Action</code> on the first component matching the specified type</li>
</ul>
</li>
<li><a class="xref" href="../api/BlueprintCore.Blueprints.Configurators.BaseBlueprintConfigurator-2.html#BlueprintCore_Blueprints_Configurators_BaseBlueprintConfigurator_2_OnConfigure_System_Action__0____">OnConfigure</a>
<ul>
<li>Executes an <code>Action</code> on the blueprint as the last step in configuration</li>
</ul>
</li>
</ul>
<h3 id="modifying-fields">Modifying Fields</h3>
<p>Each configurator exposes methods to set and modify fields. The comment summary for these methods links to the field they modify.</p>
<p>Simple fields such as booleans and integers are usually controlled by methods of the form <code>SetX()</code> while more complex or correlated fields have methods enforcing implicit contracts. For example, fields representing flags are often modified using <code>AddX()</code> and <code>RemoveY()</code> methods.</p>
<p>All blueprint fields should be exposed in their configurator. Some fields are not exposed because they are unused or unnecessary.</p>
<h3 id="adding-components">Adding Components</h3>
<p>Each <code>BlueprintComponent</code> type exposes methods to create and add them to the blueprint. The comment summary for these methods links to the type of component they create, or in some cases modify.</p>
<p>Within the game library you can add any component to any blueprint since they are all stored in a <code>BlueprintComponent</code> array. In reality, each component has restrictions on how it is used such as which type of blueprint and whether there can be more than one copy in a blueprint. See the <a href="https://github.com/WittleWolfie/OwlcatModdingWiki/wiki/%5BWrath%5D-Blueprints">Blueprints</a> article on the wiki for more details.</p>
<p>The configurator API enforce these requirements through two mechanisms:</p>
<ol>
<li>Configurators expose methods for components that are flagged as compatible</li>
<li>Validation identifies and logs an error if an invalid component is present</li>
</ol>
<p>This ensures you can see conflicts or problems in existing blueprints as well as your own. However, just because a component is exposed on a configurator does not guarantee it will work. The existing component annotations are not always correct or complete and manual review of the 1000+ components is not feasible. If you detect any conflicts please report it so the API can be updated.</p>
<h3 id="quick-example-fast-healing">Quick Example: Fast Healing</h3>
<p>The following snippet creates a new <code>BlueprintBuff</code> that grants fast healing 1 until combat ends.</p>
<pre><code class="lang-C#">BuffConfigurator.New(Name, Guid)
    .SetDisplayName(DisplayName)
    .SetDescription(Description)
    .SetIcon(Icon)
    .FastHealing(1)
    .RemoveWhenCombatEnds()
    .Configure();
</code></pre>
<h2 id="actionsbuilder-and-conditionsbuilder">ActionsBuilder and ConditionsBuilder</h2>
<p>Actions and conditions in the game are always used in the form of <code>ActionList</code> and <code>ConditionsChecker</code>. <a class="xref" href="../api/BlueprintCore.Actions.Builder.ActionsBuilder.html">ActionsBuilder</a> and <a class="xref" href="../api/BlueprintCore.Conditions.Builder.ConditionsBuilder.html">ConditionsBuilder</a> provide builder APIs for constructing them.</p>
<p>Basic usage both builders is the same:</p>
<ol>
<li>Instantiate a builder using <code>New()</code></li>
<li>Add actions/conditions using builder methods
<ul>
<li><code>ConditionsBuilder</code> has a special method, <a class="xref" href="../api/BlueprintCore.Conditions.Builder.ConditionsBuilder.html#BlueprintCore_Conditions_Builder_ConditionsBuilder_UseOr">UseOr()</a> which results in a <code>ConditionsChecker</code> that will pass if any one condition passes. By default all conditions must pass.</li>
</ul>
</li>
<li>Build the list with <code>Build()</code>
<ul>
<li>When an <code>ActionList</code> or <code>ConditionsChecker</code> is needed in a library method you do not need to call <code>Build()</code>. Instead the builder is passed into the method directly and <code>Build()</code> is called by the library.</li>
<li>Calling build logs validation errors as a warning.</li>
</ul>
</li>
</ol>
<p>Builder methods declare the game type they implement in their comment summary.</p>
<h3 id="extensions">Extensions</h3>
<p>To limit the number of actions and conditions available when using <a class="xref" href="../api/BlueprintCore.Actions.Builder.ActionsBuilder.html">ActionsBuilder</a> and <a class="xref" href="../api/BlueprintCore.Conditions.Builder.ConditionsBuilder.html">ConditionsBuilder</a>, specific types are implemented in extension methods.</p>
<p>Extension methods are logically grouped so most of the time you can include a single extension namespace. The extension groups are the same for both builders:</p>
<ul>
<li>AreaEx
<ul>
<li>Extensions involving the game map, dungeons, or locations</li>
<li>Types specifically related to the Kingdom and Crusade system are in KingdomEx</li>
</ul>
</li>
<li>AVEx
<ul>
<li>Extensions involving audiovisual effects such as dialogs, camera, cutscenes, and sounds</li>
<li><code>ActionsBuilder</code> only</li>
</ul>
</li>
<li>BasicEx
<ul>
<li>Extensions for most game mechanics not included in ContextEx</li>
</ul>
</li>
<li>ContextEx
<ul>
<li>Extensions for <code>ContextAction</code> and <code>ContextCondition</code> types</li>
<li>Some types are implemented in more specific extensions such as KingdomEx</li>
</ul>
</li>
<li>KingdomEx
<ul>
<li>Extensions for the Kingom and Crusade systems</li>
</ul>
</li>
<li>MiscEx
<ul>
<li>Extensions that are not game mechanics related and don't fit into other categories</li>
<li>Examples include things like achievement related actions</li>
</ul>
</li>
<li>NewEx
<ul>
<li>Extensions for types provided by BlueprintCore</li>
</ul>
</li>
<li>StoryEx
<ul>
<li>Extensions related to the story such as companion stories, quests, and etudes</li>
</ul>
</li>
<li>UpgraderEx
<ul>
<li>Extensions for all <code>UpgraderOnlyActions</code> types</li>
<li><code>ActionsBuilder</code> only</li>
</ul>
</li>
</ul>
<h3 id="quick-example-melee-attack">Quick Example: Melee Attack</h3>
<p>The following snippet creates a new <code>ActionList</code> that initiates a melee attack if the target is in melee range.</p>
<pre><code>// Extension for MeleeAttack() which is a ContextAction
using BlueprintCore.Actions.Builder.ContextEx;
// Extension for TargetInMeleeRange() which is a new condition in the library
using BlueprintCore.Conditions.Builder.NewEx;

ActionsBuilder.New()
    .Conditional(
        ConditionsBuilder.New().TargetInMeleeRange(),
        ifTrue: ActionsBuilder.New().MeleeAttack())
    .Build();
</code></pre>
<h2 id="referencing-blueprints">Referencing Blueprints</h2>
<p>When a blueprint reference is required the API accepts a <code>string</code> argument. The argument can be the guid for the blueprint or it can be the name of the blueprint if you have registered a name to guid mapping using <a class="xref" href="../api/BlueprintCore.Utils.BlueprintTool.html#BlueprintCore_Utils_BlueprintTool_AddGuidsByName_System_Collections_Generic_Dictionary_System_String_System_String__">BlueprintTool#AddGuidsByName()</a>. Blueprints created using <a class="xref" href="../api/BlueprintCore.Utils.BlueprintTool.html#BlueprintCore_Utils_BlueprintTool_Create__1_System_String_System_String_">BlueprintTool#Create(string, string)</a> automatically register the name to guid mapping.</p>
<p>The parameter comment declares the type of blueprint reference expected.</p>
<h2 id="generated-methods">Generated Methods</h2>
<p>The majority of the API is implemented using generated code. These methods are identified by the <a class="xref" href="../api/BlueprintCore.Utils.GeneratedAttribute.html">GeneratedAttribute</a>.</p>
<p>Generated methods have a parameter for every field in the object, essentially acting as a constructor. To minimize boilerplate generated methods declare most parameters as optional.</p>
<p>This is not an indication of how the object should be used. Optional parameters in a generated method may be required for the object to function. In contrast, non-generated methods expose strict APIs that only declare parameters optional when they are not needed.</p>
<p>If you identify methods in need of manual implementations please report them. This should be reserved for complex objects with a large number of fields or complex requirements for its fields.</p>
<h2 id="logging-and-utils">Logging and Utils</h2>
<h3 id="tools">Tools</h3>
<p>Tool classes provide simple utility functions, usually related to a specific type. See each class for more details, but some notable uses:</p>
<ul>
<li><a class="xref" href="../api/BlueprintCore.Utils.BlueprintTool.html">BlueprintTool</a>
<ul>
<li>Use this to create, fetch, and provide a name to guid mapping for blueprints</li>
</ul>
</li>
<li><a class="xref" href="../api/BlueprintCore.Utils.ElementTool.html">ElementTool</a>
<ul>
<li>Use this to create or initialize types inheriting from <code>Element</code></li>
</ul>
</li>
<li><a class="xref" href="../api/BlueprintCore.Utils.PrereqTool.html">PrereqTool</a>
<ul>
<li>Use this to create types inheriting from <code>Prerequisite</code></li>
</ul>
</li>
</ul>
<h3 id="type-constructors">Type Constructors</h3>
<p>Utility classes are provided to simplify creating game objects.</p>
<ul>
<li><a class="xref" href="../api/BlueprintCore.Utils.ContextDuration.html">ContextDuration</a>
<ul>
<li>Creates <code>ContextDurationValue</code></li>
</ul>
</li>
<li><a class="xref" href="../api/BlueprintCore.Utils.ContextValues.html">ContextValues</a>
<ul>
<li>Creates <code>ContextValue</code></li>
</ul>
</li>
<li><a class="xref" href="../api/BlueprintCore.Blueprints.Components.ContextRankConfigs.html">ContextRankConfigs</a>
<ul>
<li>Creates <code>ContextRankConfig</code></li>
</ul>
</li>
<li><a class="xref" href="../api/BlueprintCore.Blueprints.Configurators.Abilities.ResourceAmountBuilder.html">ResourceAmountBuilder</a>
<ul>
<li>Creates <code>BlueprintAbilityResource.Amount</code></li>
</ul>
</li>
</ul>
<h3 id="logging">Logging</h3>
<p><a class="xref" href="../api/BlueprintCore.Utils.LogWrapper.html">LogWrapper</a> wraps the game's <code>LogChannel</code> class to provide control over verbose log output. It is used internally for logging within BlueprintCore and is available for use within your modification, but not required.</p>
<h3 id="validator">Validator</h3>
<p><a class="xref" href="../api/BlueprintCore.Utils.Validator.html">Validator</a> is used by the library to validate method inputs, actions, conditions, blueprint components, and blueprints. Any game objects you create outside of the library can be validated using <a class="xref" href="../api/BlueprintCore.Utils.Validator.html#BlueprintCore_Utils_Validator_Check_System_Object_">Validator#Check()</a>.</p>
</article>
          </div>
          
          <div class="hidden-sm col-md-2" role="complementary">
            <div class="sideaffix">
              <div class="contribution">
                <ul class="nav">
                  <li>
                    <a href="https://github.com/WittleWolfie/WW-Blueprint-Core/blob/dllmerge/BlueprintCore/articles/intro.md/#L1" class="contribution-link">Improve this Doc</a>
                  </li>
                </ul>
              </div>
              <nav class="bs-docs-sidebar hidden-print hidden-xs hidden-sm affix" id="affix">
                <h5>In This Article</h5>
                <div></div>
              </nav>
            </div>
          </div>
        </div>
      </div>
      
      <footer>
        <div class="grad-bottom"></div>
        <div class="footer">
          <div class="container">
            <span class="pull-right">
              <a href="#top">Back to top</a>
            </span>
            
            <span>Generated by <strong>DocFX</strong></span>
          </div>
        </div>
      </footer>
    </div>
    
    <script type="text/javascript" src="../styles/docfx.vendor.js"></script>
    <script type="text/javascript" src="../styles/docfx.js"></script>
    <script type="text/javascript" src="../styles/main.js"></script>
  </body>
</html>
