//***** AUTO-GENERATED - DO NOT EDIT *****//

using BlueprintCore.Actions.Builder;
using BlueprintCore.Blueprints.CustomConfigurators;
using BlueprintCore.Conditions.Builder;
using BlueprintCore.Utils;
using Kingmaker.AreaLogic.Etudes;
using Kingmaker.Armies;
using Kingmaker.Armies.Components;
using Kingmaker.Armies.TacticalCombat.Brain;
using Kingmaker.Armies.TacticalCombat.Components;
using Kingmaker.Assets.Armies.TacticalCombat.Components;
using Kingmaker.Blueprints;
using Kingmaker.Blueprints.Classes;
using Kingmaker.Blueprints.Classes.Selection;
using Kingmaker.Blueprints.Classes.Spells;
using Kingmaker.Blueprints.Facts;
using Kingmaker.Blueprints.Items;
using Kingmaker.Blueprints.Items.Armors;
using Kingmaker.Blueprints.Items.Ecnchantments;
using Kingmaker.Blueprints.Items.Equipment;
using Kingmaker.Blueprints.Items.Weapons;
using Kingmaker.Blueprints.Root.Fx;
using Kingmaker.Controllers.Rest;
using Kingmaker.Controllers.Rest.State;
using Kingmaker.Corruption;
using Kingmaker.Designers.Mechanics.Buffs;
using Kingmaker.Designers.Mechanics.Facts;
using Kingmaker.Designers.Mechanics.Facts.Behavior;
using Kingmaker.ElementsSystem;
using Kingmaker.EntitySystem.Stats;
using Kingmaker.Enums;
using Kingmaker.Enums.Damage;
using Kingmaker.Formations.Facts;
using Kingmaker.Kingdom;
using Kingmaker.Localization;
using Kingmaker.ResourceLinks;
using Kingmaker.RuleSystem;
using Kingmaker.RuleSystem.Rules;
using Kingmaker.RuleSystem.Rules.Damage;
using Kingmaker.Settings;
using Kingmaker.UI.MVVM._VM.ServiceWindows.LocalMap.Utils;
using Kingmaker.UnitLogic;
using Kingmaker.UnitLogic.Abilities;
using Kingmaker.UnitLogic.Abilities.Blueprints;
using Kingmaker.UnitLogic.Abilities.Components;
using Kingmaker.UnitLogic.Abilities.Components.AreaEffects;
using Kingmaker.UnitLogic.ActivatableAbilities;
using Kingmaker.UnitLogic.Alignments;
using Kingmaker.UnitLogic.Buffs.Blueprints;
using Kingmaker.UnitLogic.Buffs.Components;
using Kingmaker.UnitLogic.Class.Kineticist;
using Kingmaker.UnitLogic.Commands.Base;
using Kingmaker.UnitLogic.FactLogic;
using Kingmaker.UnitLogic.Mechanics;
using Kingmaker.UnitLogic.Mechanics.Actions;
using Kingmaker.UnitLogic.Mechanics.Components;
using Kingmaker.UnitLogic.Mechanics.Properties;
using Kingmaker.UnitLogic.Parts;
using Kingmaker.Utility;
using Kingmaker.Visual.Sound;
using Owlcat.Runtime.Visual.Effects.WeatherSystem;
using System;
using System.Collections.Generic;
using System.Linq;
using UnityEngine;

namespace BlueprintCore.Blueprints.Configurators.Facts
{
  /// <summary>
  /// Implements common fields and components for blueprints inheriting from <see cref="BlueprintUnitFact"/>.
  /// </summary>
  /// <inheritdoc/>
  public abstract class BaseUnitFactConfigurator<T, TBuilder>
    : BaseFactConfigurator<T, TBuilder>
    where T : BlueprintUnitFact
    where TBuilder : BaseUnitFactConfigurator<T, TBuilder>
  {
    protected BaseUnitFactConfigurator(Blueprint<T, BlueprintReference<T>> blueprint) : base(blueprint) { }

    /// <summary>
    /// Adds <see cref="AddFacts"/>
    /// </summary>
    ///
    /// <remarks>
    ///
    /// <list type="bullet">
    /// <listheader>Used by</listheader>
    /// <item><term>!Octavia_Companion_Mage_Test</term><description>f9161aa0b3f519c47acbce01f53ee217</description></item>
    /// <item><term>DrovierAspectOfTheFalconFeature</term><description>7c3a2b21ffb8faf49a4656a04487d8b4</description></item>
    /// <item><term>ZonKuthonFeature</term><description>f7eed400baa66a744ad361d4df0e6f1b</description></item>
    /// </list>
    /// </remarks>
    ///
    /// <param name="facts">
    /// <para>
    /// Blueprint of type BlueprintUnitFact. You can pass in the blueprint using:
    /// <list type ="bullet">
    ///   <item><term>A blueprint instance</term></item>
    ///   <item><term>A blueprint reference</term></item>
    ///   <item><term>A blueprint id as a string, Guid, or BlueprintGuid</term></item>
    ///   <item><term>A blueprint name registered with <see cref="BlueprintCore.Utils.BlueprintTool">BlueprintTool</see></term></item>
    /// </list>
    /// See <see cref="BlueprintCore.Utils.Blueprint{{T, TRef}}">Blueprint</see> for more details.
    /// </para>
    /// </param>
    /// <param name="dummy">
    /// <para>
    /// Blueprint of type BlueprintUnit. You can pass in the blueprint using:
    /// <list type ="bullet">
    ///   <item><term>A blueprint instance</term></item>
    ///   <item><term>A blueprint reference</term></item>
    ///   <item><term>A blueprint id as a string, Guid, or BlueprintGuid</term></item>
    ///   <item><term>A blueprint name registered with <see cref="BlueprintCore.Utils.BlueprintTool">BlueprintTool</see></term></item>
    /// </list>
    /// See <see cref="BlueprintCore.Utils.Blueprint{{T, TRef}}">Blueprint</see> for more details.
    /// </para>
    /// </param>
    /// <param name="merge">
    /// If mergeBehavior is ComponentMerge.Merge and the component already exists, this expression is called to merge the components.
    /// </param>
    /// <param name="mergeBehavior">
    /// Handling if the component already exists since the component is unique. Defaults to ComponentMerge.Fail.
    /// </param>
    public TBuilder AddFacts(
        List<Blueprint<BlueprintUnitFact, BlueprintUnitFactReference>> facts,
        int? casterLevel = null,
        bool? doNotRestoreMissingFacts = null,
        Blueprint<BlueprintUnit, BlueprintUnitReference>? dummy = null,
        bool? hasDifficultyRequirements = null,
        bool? invertDifficultyRequirements = null,
        Action<BlueprintComponent, BlueprintComponent>? merge = null,
        ComponentMerge mergeBehavior = ComponentMerge.Merge,
        GameDifficultyOption? minDifficulty = null)
    {
      var component = new AddFacts();
      component.m_Facts = facts?.Select(bp => bp.Reference)?.ToArray();
      component.CasterLevel = casterLevel ?? component.CasterLevel;
      component.DoNotRestoreMissingFacts = doNotRestoreMissingFacts ?? component.DoNotRestoreMissingFacts;
      component.Dummy = dummy?.Reference ?? component.Dummy;
      if (component.Dummy is null)
      {
        component.Dummy = BlueprintTool.GetRef<BlueprintUnitReference>(null);
      }
      component.HasDifficultyRequirements = hasDifficultyRequirements ?? component.HasDifficultyRequirements;
      component.InvertDifficultyRequirements = invertDifficultyRequirements ?? component.InvertDifficultyRequirements;
      component.MinDifficulty = minDifficulty ?? component.MinDifficulty;
      return AddUniqueComponent(component, mergeBehavior, merge);
    }

    /// <summary>
    /// Adds <see cref="AddInitiatorSkillRollTrigger"/>
    /// </summary>
    ///
    /// <remarks>
    ///
    /// <list type="bullet">
    /// <listheader>Used by</listheader>
    /// <item><term>GloryDomainBaseBuff</term><description>55edcfff497a1e04a963f72c485da5cb</description></item>
    /// <item><term>GuidanceBuff</term><description>ec931b882e806ce42906597e5585c13f</description></item>
    /// <item><term>RangedLegerdemainUntargetable</term><description>5f632e786b68d8d4c8bb66275fc600a7</description></item>
    /// </list>
    /// </remarks>
    ///
    /// <param name="merge">
    /// If mergeBehavior is ComponentMerge.Merge and the component already exists, this expression is called to merge the components.
    /// </param>
    /// <param name="mergeBehavior">
    /// Handling if the component already exists since the component is unique. Defaults to ComponentMerge.Fail.
    /// </param>
    public TBuilder AddInitiatorSkillRollTrigger(
        bool onlySuccess,
        StatType skill,
        ActionsBuilder? action = null,
        Action<BlueprintComponent, BlueprintComponent>? merge = null,
        ComponentMerge mergeBehavior = ComponentMerge.Merge)
    {
      var component = new AddInitiatorSkillRollTrigger();
      component.OnlySuccess = onlySuccess;
      component.Skill = skill;
      component.Action = action?.Build() ?? component.Action;
      if (component.Action is null)
      {
        component.Action = Utils.Constants.Empty.Actions;
      }
      return AddUniqueComponent(component, mergeBehavior, merge);
    }

    /// <summary>
    /// Adds <see cref="FormationACBonus"/>
    /// </summary>
    ///
    /// <remarks>
    ///
    /// <list type="bullet">
    /// <listheader>Used by</listheader>
    /// <item><term>AirBlessingMajorBuff</term><description>ac410725d8fc6fe4b81d47269f4f3ea1</description></item>
    /// <item><term>BuffWingsDraconicRed</term><description>08ae1c01155a2184db869e9ebedc758d</description></item>
    /// <item><term>WingsMovanicDeva</term><description>775df52784e1d454cba0da8df5f4f59a</description></item>
    /// </list>
    /// </remarks>
    ///
    /// <param name="ignoreIfHasAnyFact">
    /// <para>
    /// Blueprint of type BlueprintUnitFact. You can pass in the blueprint using:
    /// <list type ="bullet">
    ///   <item><term>A blueprint instance</term></item>
    ///   <item><term>A blueprint reference</term></item>
    ///   <item><term>A blueprint id as a string, Guid, or BlueprintGuid</term></item>
    ///   <item><term>A blueprint name registered with <see cref="BlueprintCore.Utils.BlueprintTool">BlueprintTool</see></term></item>
    /// </list>
    /// See <see cref="BlueprintCore.Utils.Blueprint{{T, TRef}}">Blueprint</see> for more details.
    /// </para>
    /// </param>
    /// <param name="property">
    /// <para>
    /// Blueprint of type BlueprintUnitProperty. You can pass in the blueprint using:
    /// <list type ="bullet">
    ///   <item><term>A blueprint instance</term></item>
    ///   <item><term>A blueprint reference</term></item>
    ///   <item><term>A blueprint id as a string, Guid, or BlueprintGuid</term></item>
    ///   <item><term>A blueprint name registered with <see cref="BlueprintCore.Utils.BlueprintTool">BlueprintTool</see></term></item>
    /// </list>
    /// See <see cref="BlueprintCore.Utils.Blueprint{{T, TRef}}">Blueprint</see> for more details.
    /// </para>
    /// </param>
    public TBuilder AddFormationACBonus(
        int? bonus = null,
        List<Blueprint<BlueprintUnitFact, BlueprintUnitFactReference>>? ignoreIfHasAnyFact = null,
        Blueprint<BlueprintUnitProperty, BlueprintUnitPropertyReference>? property = null,
        bool? unitProperty = null)
    {
      var component = new FormationACBonus();
      component.Bonus = bonus ?? component.Bonus;
      component.m_IgnoreIfHasAnyFact = ignoreIfHasAnyFact?.Select(bp => bp.Reference)?.ToArray() ?? component.m_IgnoreIfHasAnyFact;
      if (component.m_IgnoreIfHasAnyFact is null)
      {
        component.m_IgnoreIfHasAnyFact = new BlueprintUnitFactReference[0];
      }
      component.m_Property = property?.Reference ?? component.m_Property;
      if (component.m_Property is null)
      {
        component.m_Property = BlueprintTool.GetRef<BlueprintUnitPropertyReference>(null);
      }
      component.UnitProperty = unitProperty ?? component.UnitProperty;
      return AddComponent(component);
    }

    /// <summary>
    /// Adds <see cref="CorruptionProtection"/>
    /// </summary>
    ///
    /// <remarks>
    ///
    /// <list type="bullet">
    /// <listheader>Used by</listheader>
    /// <item><term>BuildingAsylum</term><description>6724effab6d84cce873a0f40fe0c5d33</description></item>
    /// <item><term>Legend_UniqueRestBuff</term><description>65ea55e5521d43409d102defd153757a</description></item>
    /// <item><term>PlayerAeonCorruptionProtectionBuff</term><description>256ae19b117c40868248154da12d17b8</description></item>
    /// </list>
    /// </remarks>
    ///
    /// <param name="removeRankAfterRest">
    /// <para>
    /// InfoBox: Prevents corruption grow. If RemoveRankAfterRest = false, will prevent corruption grow until buff ends
    /// </para>
    /// </param>
    public TBuilder AddCorruptionProtection(
        bool? removeRankAfterRest = null)
    {
      var component = new CorruptionProtection();
      component.m_RemoveRankAfterRest = removeRankAfterRest ?? component.m_RemoveRankAfterRest;
      return AddComponent(component);
    }

    /// <summary>
    /// Adds <see cref="RestRoleBonus"/>
    /// </summary>
    ///
    /// <remarks>
    ///
    /// <list type="bullet">
    /// <listheader>Used by</listheader>
    /// <item><term>TheSwarmImproveRestFeature</term><description>768406ab83d5497e808a4dce1285791d</description></item>
    /// </list>
    /// </remarks>
    ///
    /// <param name="merge">
    /// If mergeBehavior is ComponentMerge.Merge and the component already exists, this expression is called to merge the components.
    /// </param>
    /// <param name="mergeBehavior">
    /// Handling if the component already exists since the component is unique. Defaults to ComponentMerge.Fail.
    /// </param>
    public TBuilder AddRestRoleBonus(
        ModifierDescriptor? descriptor = null,
        Action<BlueprintComponent, BlueprintComponent>? merge = null,
        ComponentMerge mergeBehavior = ComponentMerge.Merge,
        CampingRoleType? roleType = null,
        ContextValue? value = null)
    {
      var component = new RestRoleBonus();
      component.m_Descriptor = descriptor ?? component.m_Descriptor;
      component.m_RoleType = roleType ?? component.m_RoleType;
      component.m_Value = value ?? component.m_Value;
      if (component.m_Value is null)
      {
        component.m_Value = ContextValues.Constant(0);
      }
      return AddUniqueComponent(component, mergeBehavior, merge);
    }

    /// <summary>
    /// Adds <see cref="ReplaceUnitPrefab"/>
    /// </summary>
    ///
    /// <remarks>
    ///
    /// <list type="bullet">
    /// <listheader>Used by</listheader>
    /// <item><term>DragonAzataFeatureTierIIBuff</term><description>95f7a7c4be0e4c73855b1cc71b45dba4</description></item>
    /// <item><term>DragonAzataFeatureTierIIIPrefab</term><description>600c4d652b6e4684a7a4b77946903c30</description></item>
    /// <item><term>DragonAzataFeatureTierIIPrefab</term><description>50853b0623b844ac86129db459907797</description></item>
    /// </list>
    /// </remarks>
    public TBuilder AddReplaceUnitPrefab(
        PrefabLink? prefab = null)
    {
      var component = new ReplaceUnitPrefab();
      component.m_Prefab = prefab ?? component.m_Prefab;
      if (component.m_Prefab is null)
      {
        component.m_Prefab = Utils.Constants.Empty.PrefabLink;
      }
      return AddComponent(component);
    }

    /// <summary>
    /// Adds <see cref="PretendUnit"/>
    /// </summary>
    ///
    /// <remarks>
    ///
    /// <list type="bullet">
    /// <listheader>Used by</listheader>
    /// <item><term>Alushinyrra_Minagho</term><description>23e9e36701934fcbbf3e1472091d9321</description></item>
    /// <item><term>Lann_NPC_Level1</term><description>82e18082c3477d747b45265b9aa99249</description></item>
    /// <item><term>Ziforian_normal</term><description>7ef2998dbeb7fda43a47ce842f4d142d</description></item>
    /// </list>
    /// </remarks>
    ///
    /// <param name="unit">
    /// <para>
    /// Blueprint of type BlueprintUnit. You can pass in the blueprint using:
    /// <list type ="bullet">
    ///   <item><term>A blueprint instance</term></item>
    ///   <item><term>A blueprint reference</term></item>
    ///   <item><term>A blueprint id as a string, Guid, or BlueprintGuid</term></item>
    ///   <item><term>A blueprint name registered with <see cref="BlueprintCore.Utils.BlueprintTool">BlueprintTool</see></term></item>
    /// </list>
    /// See <see cref="BlueprintCore.Utils.Blueprint{{T, TRef}}">Blueprint</see> for more details.
    /// </para>
    /// </param>
    public TBuilder AddPretendUnit(
        Blueprint<BlueprintUnit, BlueprintUnitReference>? unit = null)
    {
      var component = new PretendUnit();
      component.m_Unit = unit?.Reference ?? component.m_Unit;
      if (component.m_Unit is null)
      {
        component.m_Unit = BlueprintTool.GetRef<BlueprintUnitReference>(null);
      }
      return AddComponent(component);
    }

    /// <summary>
    /// Adds <see cref="AddClassLevels"/>
    /// </summary>
    ///
    /// <remarks>
    ///
    /// <para>
    /// ComponentName: Add class levels
    /// </para>
    ///
    /// <list type="bullet">
    /// <listheader>Used by</listheader>
    /// <item><term>AasimarGirlSlave</term><description>848db1dc1890e734d978b0d2ce3775f5</description></item>
    /// <item><term>CR5_SkeletalChampionUnarmed</term><description>b348af45b8ef0dd4086d9a8a50439a37</description></item>
    /// <item><term>ZombieLordWizardFeatureListLevel8</term><description>1495a07abb198e54a9b31188c9c6ec47</description></item>
    /// </list>
    /// </remarks>
    ///
    /// <param name="archetypes">
    /// <para>
    /// Blueprint of type BlueprintArchetype. You can pass in the blueprint using:
    /// <list type ="bullet">
    ///   <item><term>A blueprint instance</term></item>
    ///   <item><term>A blueprint reference</term></item>
    ///   <item><term>A blueprint id as a string, Guid, or BlueprintGuid</term></item>
    ///   <item><term>A blueprint name registered with <see cref="BlueprintCore.Utils.BlueprintTool">BlueprintTool</see></term></item>
    /// </list>
    /// See <see cref="BlueprintCore.Utils.Blueprint{{T, TRef}}">Blueprint</see> for more details.
    /// </para>
    /// </param>
    /// <param name="characterClass">
    /// <para>
    /// Blueprint of type BlueprintCharacterClass. You can pass in the blueprint using:
    /// <list type ="bullet">
    ///   <item><term>A blueprint instance</term></item>
    ///   <item><term>A blueprint reference</term></item>
    ///   <item><term>A blueprint id as a string, Guid, or BlueprintGuid</term></item>
    ///   <item><term>A blueprint name registered with <see cref="BlueprintCore.Utils.BlueprintTool">BlueprintTool</see></term></item>
    /// </list>
    /// See <see cref="BlueprintCore.Utils.Blueprint{{T, TRef}}">Blueprint</see> for more details.
    /// </para>
    /// </param>
    /// <param name="memorizeSpells">
    /// <para>
    /// Blueprint of type BlueprintAbility. You can pass in the blueprint using:
    /// <list type ="bullet">
    ///   <item><term>A blueprint instance</term></item>
    ///   <item><term>A blueprint reference</term></item>
    ///   <item><term>A blueprint id as a string, Guid, or BlueprintGuid</term></item>
    ///   <item><term>A blueprint name registered with <see cref="BlueprintCore.Utils.BlueprintTool">BlueprintTool</see></term></item>
    /// </list>
    /// See <see cref="BlueprintCore.Utils.Blueprint{{T, TRef}}">Blueprint</see> for more details.
    /// </para>
    /// </param>
    /// <param name="merge">
    /// If mergeBehavior is ComponentMerge.Merge and the component already exists, this expression is called to merge the components.
    /// </param>
    /// <param name="mergeBehavior">
    /// Handling if the component already exists since the component is unique. Defaults to ComponentMerge.Fail.
    /// </param>
    /// <param name="selectSpells">
    /// <para>
    /// InfoBox: If some selection isn't specified here than first appropriate item will be selected
    /// </para>
    /// <para>
    /// Blueprint of type BlueprintAbility. You can pass in the blueprint using:
    /// <list type ="bullet">
    ///   <item><term>A blueprint instance</term></item>
    ///   <item><term>A blueprint reference</term></item>
    ///   <item><term>A blueprint id as a string, Guid, or BlueprintGuid</term></item>
    ///   <item><term>A blueprint name registered with <see cref="BlueprintCore.Utils.BlueprintTool">BlueprintTool</see></term></item>
    /// </list>
    /// See <see cref="BlueprintCore.Utils.Blueprint{{T, TRef}}">Blueprint</see> for more details.
    /// </para>
    /// </param>
    public TBuilder AddClassLevels(
        List<Blueprint<BlueprintArchetype, BlueprintArchetypeReference>>? archetypes = null,
        Blueprint<BlueprintCharacterClass, BlueprintCharacterClassReference>? characterClass = null,
        bool? doNotApplyAutomatically = null,
        int? levels = null,
        StatType? levelsStat = null,
        List<Blueprint<BlueprintAbility, BlueprintAbilityReference>>? memorizeSpells = null,
        Action<BlueprintComponent, BlueprintComponent>? merge = null,
        ComponentMerge mergeBehavior = ComponentMerge.Merge,
        StatType? raceStat = null,
        SelectionEntry[]? selections = null,
        List<Blueprint<BlueprintAbility, BlueprintAbilityReference>>? selectSpells = null,
        StatType[]? skills = null)
    {
      var component = new AddClassLevels();
      component.m_Archetypes = archetypes?.Select(bp => bp.Reference)?.ToArray() ?? component.m_Archetypes;
      if (component.m_Archetypes is null)
      {
        component.m_Archetypes = new BlueprintArchetypeReference[0];
      }
      component.m_CharacterClass = characterClass?.Reference ?? component.m_CharacterClass;
      if (component.m_CharacterClass is null)
      {
        component.m_CharacterClass = BlueprintTool.GetRef<BlueprintCharacterClassReference>(null);
      }
      component.DoNotApplyAutomatically = doNotApplyAutomatically ?? component.DoNotApplyAutomatically;
      component.Levels = levels ?? component.Levels;
      component.LevelsStat = levelsStat ?? component.LevelsStat;
      component.m_MemorizeSpells = memorizeSpells?.Select(bp => bp.Reference)?.ToArray() ?? component.m_MemorizeSpells;
      if (component.m_MemorizeSpells is null)
      {
        component.m_MemorizeSpells = new BlueprintAbilityReference[0];
      }
      component.RaceStat = raceStat ?? component.RaceStat;
      foreach (var item in selections) { Validate(item); }
      component.Selections = selections ?? component.Selections;
      if (component.Selections is null)
      {
        component.Selections = new SelectionEntry[0];
      }
      component.m_SelectSpells = selectSpells?.Select(bp => bp.Reference)?.ToArray() ?? component.m_SelectSpells;
      if (component.m_SelectSpells is null)
      {
        component.m_SelectSpells = new BlueprintAbilityReference[0];
      }
      component.Skills = skills ?? component.Skills;
      if (component.Skills is null)
      {
        component.Skills = new StatType[0];
      }
      return AddUniqueComponent(component, mergeBehavior, merge);
    }

    /// <summary>
    /// Adds <see cref="BuildBalanceRadarChart"/>
    /// </summary>
    ///
    /// <remarks>
    ///
    /// <list type="bullet">
    /// <listheader>Used by</listheader>
    /// <item><term>DLC1StartPregenFighterUnit</term><description>7fdbc4d2fcef4478b375e73dd98d32f1</description></item>
    /// <item><term>PrebuildKineticistFeatureList</term><description>4d3485ad2fe43cd40b6cfbc1a3b9e484</description></item>
    /// <item><term>PrebuildWizardFeatureList</term><description>f75b7868dd11fb04f83ca94f9f8cc957</description></item>
    /// </list>
    /// </remarks>
    public TBuilder AddBuildBalanceRadarChart(
        int? control = null,
        int? defense = null,
        int? magic = null,
        int? melee = null,
        int? ranged = null,
        int? support = null)
    {
      var component = new BuildBalanceRadarChart();
      component.Control = control ?? component.Control;
      component.Defense = defense ?? component.Defense;
      component.Magic = magic ?? component.Magic;
      component.Melee = melee ?? component.Melee;
      component.Ranged = ranged ?? component.Ranged;
      component.Support = support ?? component.Support;
      return AddComponent(component);
    }

    /// <summary>
    /// Adds <see cref="StatsDistributionPreset"/>
    /// </summary>
    ///
    /// <remarks>
    ///
    /// <list type="bullet">
    /// <listheader>Used by</listheader>
    /// <item><term>PrebuildAlchemistFeatureList</term><description>f271855551ee72a48abbfe5119cc9ba4</description></item>
    /// <item><term>PrebuildMagusFeatureList</term><description>9dac81eacf313ca44a4d9386f9fcbb73</description></item>
    /// <item><term>PrebuildWizardFeatureList</term><description>f75b7868dd11fb04f83ca94f9f8cc957</description></item>
    /// </list>
    /// </remarks>
    ///
    /// <param name="merge">
    /// If mergeBehavior is ComponentMerge.Merge and the component already exists, this expression is called to merge the components.
    /// </param>
    /// <param name="mergeBehavior">
    /// Handling if the component already exists since the component is unique. Defaults to ComponentMerge.Fail.
    /// </param>
    public TBuilder AddStatsDistributionPreset(
        int? charisma = null,
        int? constitution = null,
        int? dexterity = null,
        int? intelligence = null,
        Action<BlueprintComponent, BlueprintComponent>? merge = null,
        ComponentMerge mergeBehavior = ComponentMerge.Merge,
        int? strength = null,
        int? targetPoints = null,
        int? wisdom = null)
    {
      var component = new StatsDistributionPreset();
      component.Charisma = charisma ?? component.Charisma;
      component.Constitution = constitution ?? component.Constitution;
      component.Dexterity = dexterity ?? component.Dexterity;
      component.Intelligence = intelligence ?? component.Intelligence;
      component.Strength = strength ?? component.Strength;
      component.TargetPoints = targetPoints ?? component.TargetPoints;
      component.Wisdom = wisdom ?? component.Wisdom;
      return AddUniqueComponent(component, mergeBehavior, merge);
    }

    /// <summary>
    /// Adds <see cref="SuppressSpellSchool"/>
    /// </summary>
    ///
    /// <remarks>
    ///
    /// <list type="bullet">
    /// <listheader>Used by</listheader>
    /// <item><term>HellsDecreeAbilityMagicAbjurationBuff</term><description>b07ce045e7503d84bafe8715a05bdda7</description></item>
    /// <item><term>HellsDecreeAbilityMagicEvocationBuff</term><description>ea03cb0438d8ce049a6dbf1e89d9f911</description></item>
    /// <item><term>HellsDecreeAbilityMagicTransmutationBuff</term><description>ded8dddbbf78c48408582980da0608b7</description></item>
    /// </list>
    /// </remarks>
    public TBuilder AddSuppressSpellSchool(
        SuppressSpellSchool.Logic? componentLogic = null,
        SpellSchool[]? school = null)
    {
      var component = new SuppressSpellSchool();
      component.m_ComponentLogic = componentLogic ?? component.m_ComponentLogic;
      component.m_School = school ?? component.m_School;
      if (component.m_School is null)
      {
        component.m_School = new SpellSchool[0];
      }
      return AddComponent(component);
    }

    /// <summary>
    /// Adds <see cref="AzataFavorableMagic"/>
    /// </summary>
    ///
    /// <remarks>
    ///
    /// <list type="bullet">
    /// <listheader>Used by</listheader>
    /// <item><term>FavorableMagicFeature</term><description>afcee6925a6eadf43820d12e0d966ebe</description></item>
    /// </list>
    /// </remarks>
    public TBuilder AddAzataFavorableMagic()
    {
      return AddComponent(new AzataFavorableMagic());
    }

    /// <summary>
    /// Adds <see cref="DemonSocothbenothAspect"/>
    /// </summary>
    ///
    /// <remarks>
    ///
    /// <list type="bullet">
    /// <listheader>Used by</listheader>
    /// <item><term>SocothbenothAspectBuff</term><description>006210142499ccb4ea837d4b61506055</description></item>
    /// </list>
    /// </remarks>
    public TBuilder AddDemonSocothbenothAspect()
    {
      return AddComponent(new DemonSocothbenothAspect());
    }

    /// <summary>
    /// Adds <see cref="AbilityUsagesCountTrigger"/>
    /// </summary>
    ///
    /// <remarks>
    ///
    /// <list type="bullet">
    /// <listheader>Used by</listheader>
    /// <item><term>BootsOfArcanePersistanceFeature</term><description>5e7bedc8d16a324468121c18cb0cd63a</description></item>
    /// <item><term>PlaguePersistenceQuarterstaffFeature</term><description>a05cd6b2f01240c5943779fef1ccc0d4</description></item>
    /// </list>
    /// </remarks>
    ///
    /// <param name="triggerCount">
    /// <para>
    /// InfoBox: All counters are flushed after rest
    /// </para>
    /// </param>
    public TBuilder AddAbilityUsagesCountTrigger(
        ActionsBuilder? action = null,
        ContextValue? triggerCount = null)
    {
      var component = new AbilityUsagesCountTrigger();
      component.Action = action?.Build() ?? component.Action;
      if (component.Action is null)
      {
        component.Action = Utils.Constants.Empty.Actions;
      }
      component.m_TriggerCount = triggerCount ?? component.m_TriggerCount;
      if (component.m_TriggerCount is null)
      {
        component.m_TriggerCount = ContextValues.Constant(0);
      }
      return AddComponent(component);
    }

    /// <summary>
    /// Adds <see cref="AccomplishedSneakAttacker"/>
    /// </summary>
    ///
    /// <remarks>
    ///
    /// <para>
    /// ComponentName: Add stat bonus
    /// </para>
    ///
    /// <list type="bullet">
    /// <listheader>Used by</listheader>
    /// <item><term>AccomplishedSneakAttacker</term><description>9f0187869dc23744292c0e5bb364464e</description></item>
    /// </list>
    /// </remarks>
    public TBuilder AddAccomplishedSneakAttacker(
        int? value = null)
    {
      var component = new AccomplishedSneakAttacker();
      component.Value = value ?? component.Value;
      return AddComponent(component);
    }

    /// <summary>
    /// Adds <see cref="AcrobaticMovement"/>
    /// </summary>
    ///
    /// <remarks>
    ///
    /// <list type="bullet">
    /// <listheader>Used by</listheader>
    /// <item><term>MobilityUseAbilityBuff</term><description>9dc2afb96879cfd4bb7aed475ed51002</description></item>
    /// </list>
    /// </remarks>
    ///
    /// <param name="merge">
    /// If mergeBehavior is ComponentMerge.Merge and the component already exists, this expression is called to merge the components.
    /// </param>
    /// <param name="mergeBehavior">
    /// Handling if the component already exists since the component is unique. Defaults to ComponentMerge.Fail.
    /// </param>
    public TBuilder AddAcrobaticMovement(
        Action<BlueprintComponent, BlueprintComponent>? merge = null,
        ComponentMerge mergeBehavior = ComponentMerge.Merge)
    {
      var component = new AcrobaticMovement();
      return AddUniqueComponent(component, mergeBehavior, merge);
    }

    /// <summary>
    /// Adds <see cref="AddACBonusWithDistanceToMasterCondition"/>
    /// </summary>
    ///
    /// <remarks>
    ///
    /// <list type="bullet">
    /// <listheader>Used by</listheader>
    /// <item><term>SelfRelianceAnimalFeature</term><description>b204307a24f2207408557adaad2a29a8</description></item>
    /// </list>
    /// </remarks>
    public TBuilder AddACBonusWithDistanceToMasterCondition(
        CompareOperation.Type? compareType = null,
        ModifierDescriptor? descriptor = null,
        Feet? distance = null,
        ContextValue? value = null)
    {
      var component = new AddACBonusWithDistanceToMasterCondition();
      component.CompareType = compareType ?? component.CompareType;
      component.Descriptor = descriptor ?? component.Descriptor;
      component.Distance = distance ?? component.Distance;
      component.Value = value ?? component.Value;
      if (component.Value is null)
      {
        component.Value = ContextValues.Constant(0);
      }
      return AddComponent(component);
    }

    /// <summary>
    /// Adds <see cref="AddAbilityResourceTrigger"/>
    /// </summary>
    ///
    /// <remarks>
    ///
    /// <list type="bullet">
    /// <listheader>Used by</listheader>
    /// <item><term>SpiritThrasherFeature</term><description>701422799dd64e07ad931d2844b00362</description></item>
    /// </list>
    /// </remarks>
    ///
    /// <param name="merge">
    /// If mergeBehavior is ComponentMerge.Merge and the component already exists, this expression is called to merge the components.
    /// </param>
    /// <param name="mergeBehavior">
    /// Handling if the component already exists since the component is unique. Defaults to ComponentMerge.Fail.
    /// </param>
    /// <param name="resource">
    /// <para>
    /// Blueprint of type BlueprintAbilityResource. You can pass in the blueprint using:
    /// <list type ="bullet">
    ///   <item><term>A blueprint instance</term></item>
    ///   <item><term>A blueprint reference</term></item>
    ///   <item><term>A blueprint id as a string, Guid, or BlueprintGuid</term></item>
    ///   <item><term>A blueprint name registered with <see cref="BlueprintCore.Utils.BlueprintTool">BlueprintTool</see></term></item>
    /// </list>
    /// See <see cref="BlueprintCore.Utils.Blueprint{{T, TRef}}">Blueprint</see> for more details.
    /// </para>
    /// </param>
    public TBuilder AddAbilityResourceTrigger(
        ActionsBuilder? action = null,
        Action<BlueprintComponent, BlueprintComponent>? merge = null,
        ComponentMerge mergeBehavior = ComponentMerge.Merge,
        Blueprint<BlueprintAbilityResource, BlueprintAbilityResourceReference>? resource = null)
    {
      var component = new AddAbilityResourceTrigger();
      component.Action = action?.Build() ?? component.Action;
      if (component.Action is null)
      {
        component.Action = Utils.Constants.Empty.Actions;
      }
      component.m_Resource = resource?.Reference ?? component.m_Resource;
      if (component.m_Resource is null)
      {
        component.m_Resource = BlueprintTool.GetRef<BlueprintAbilityResourceReference>(null);
      }
      return AddUniqueComponent(component, mergeBehavior, merge);
    }

    /// <summary>
    /// Adds <see cref="AddAbilityUseTargetTrigger"/>
    /// </summary>
    ///
    /// <remarks>
    ///
    /// <list type="bullet">
    /// <listheader>Used by</listheader>
    /// <item><term>AnomalyTemplateDefensive_ChaoticMindBuff</term><description>2159f35f1dfb4ee78da818f443a086ee</description></item>
    /// <item><term>EverlastingLightFeature</term><description>824df03a2fdf4d5299e1b540adf86583</description></item>
    /// <item><term>WitchHexHoarfrostBuff</term><description>11a4a94204505d84e97154b2fdda234c</description></item>
    /// </list>
    /// </remarks>
    ///
    /// <param name="merge">
    /// If mergeBehavior is ComponentMerge.Merge and the component already exists, this expression is called to merge the components.
    /// </param>
    /// <param name="mergeBehavior">
    /// Handling if the component already exists since the component is unique. Defaults to ComponentMerge.Fail.
    /// </param>
    /// <param name="spellbooks">
    /// <para>
    /// Blueprint of type BlueprintSpellbook. You can pass in the blueprint using:
    /// <list type ="bullet">
    ///   <item><term>A blueprint instance</term></item>
    ///   <item><term>A blueprint reference</term></item>
    ///   <item><term>A blueprint id as a string, Guid, or BlueprintGuid</term></item>
    ///   <item><term>A blueprint name registered with <see cref="BlueprintCore.Utils.BlueprintTool">BlueprintTool</see></term></item>
    /// </list>
    /// See <see cref="BlueprintCore.Utils.Blueprint{{T, TRef}}">Blueprint</see> for more details.
    /// </para>
    /// </param>
    /// <param name="spells">
    /// <para>
    /// Blueprint of type BlueprintAbility. You can pass in the blueprint using:
    /// <list type ="bullet">
    ///   <item><term>A blueprint instance</term></item>
    ///   <item><term>A blueprint reference</term></item>
    ///   <item><term>A blueprint id as a string, Guid, or BlueprintGuid</term></item>
    ///   <item><term>A blueprint name registered with <see cref="BlueprintCore.Utils.BlueprintTool">BlueprintTool</see></term></item>
    /// </list>
    /// See <see cref="BlueprintCore.Utils.Blueprint{{T, TRef}}">Blueprint</see> for more details.
    /// </para>
    /// </param>
    /// <param name="triggerOnEffectApply">
    /// <para>
    /// InfoBox: Useful option for AoE spells to trigger when Owner is not primary target. Attention: will trigger for every spell effect (on each scorching ray reached Owner)
    /// </para>
    /// </param>
    public TBuilder AddAbilityUseTargetTrigger(
        ActionsBuilder? action = null,
        bool? afterCast = null,
        bool? checkDescriptor = null,
        bool? dontCheckType = null,
        bool? fromSpellbook = null,
        Action<BlueprintComponent, BlueprintComponent>? merge = null,
        ComponentMerge mergeBehavior = ComponentMerge.Merge,
        List<Blueprint<BlueprintSpellbook, BlueprintSpellbookReference>>? spellbooks = null,
        SpellDescriptorWrapper? spellDescriptor = null,
        bool? spellList = null,
        List<Blueprint<BlueprintAbility, BlueprintAbilityReference>>? spells = null,
        bool? toCaster = null,
        bool? triggerOnEffectApply = null,
        AbilityType? type = null)
    {
      var component = new AddAbilityUseTargetTrigger();
      component.Action = action?.Build() ?? component.Action;
      if (component.Action is null)
      {
        component.Action = Utils.Constants.Empty.Actions;
      }
      component.AfterCast = afterCast ?? component.AfterCast;
      component.CheckDescriptor = checkDescriptor ?? component.CheckDescriptor;
      component.DontCheckType = dontCheckType ?? component.DontCheckType;
      component.FromSpellbook = fromSpellbook ?? component.FromSpellbook;
      component.m_Spellbooks = spellbooks?.Select(bp => bp.Reference)?.ToArray() ?? component.m_Spellbooks;
      if (component.m_Spellbooks is null)
      {
        component.m_Spellbooks = new BlueprintSpellbookReference[0];
      }
      component.SpellDescriptor = spellDescriptor ?? component.SpellDescriptor;
      component.SpellList = spellList ?? component.SpellList;
      component.m_Spells = spells?.Select(bp => bp.Reference)?.ToArray() ?? component.m_Spells;
      if (component.m_Spells is null)
      {
        component.m_Spells = new BlueprintAbilityReference[0];
      }
      component.ToCaster = toCaster ?? component.ToCaster;
      component.TriggerOnEffectApply = triggerOnEffectApply ?? component.TriggerOnEffectApply;
      component.Type = type ?? component.Type;
      return AddUniqueComponent(component, mergeBehavior, merge);
    }

    /// <summary>
    /// Adds <see cref="AddAbilityUseTrigger"/>
    /// </summary>
    ///
    /// <remarks>
    ///
    /// <list type="bullet">
    /// <listheader>Used by</listheader>
    /// <item><term>AeonBaneBuff</term><description>345160619fc2ddc44b8ad98c94dde448</description></item>
    /// <item><term>LivingFlameFeature</term><description>01276815beaf1c44bbfb842bc1bcb899</description></item>
    /// <item><term>ZippyMagicFeature</term><description>30b4200f897ba25419ba3a292aed4053</description></item>
    /// </list>
    /// </remarks>
    ///
    /// <param name="abilities">
    /// <para>
    /// Blueprint of type BlueprintAbility. You can pass in the blueprint using:
    /// <list type ="bullet">
    ///   <item><term>A blueprint instance</term></item>
    ///   <item><term>A blueprint reference</term></item>
    ///   <item><term>A blueprint id as a string, Guid, or BlueprintGuid</term></item>
    ///   <item><term>A blueprint name registered with <see cref="BlueprintCore.Utils.BlueprintTool">BlueprintTool</see></term></item>
    /// </list>
    /// See <see cref="BlueprintCore.Utils.Blueprint{{T, TRef}}">Blueprint</see> for more details.
    /// </para>
    /// </param>
    /// <param name="ability">
    /// <para>
    /// Blueprint of type BlueprintAbility. You can pass in the blueprint using:
    /// <list type ="bullet">
    ///   <item><term>A blueprint instance</term></item>
    ///   <item><term>A blueprint reference</term></item>
    ///   <item><term>A blueprint id as a string, Guid, or BlueprintGuid</term></item>
    ///   <item><term>A blueprint name registered with <see cref="BlueprintCore.Utils.BlueprintTool">BlueprintTool</see></term></item>
    /// </list>
    /// See <see cref="BlueprintCore.Utils.Blueprint{{T, TRef}}">Blueprint</see> for more details.
    /// </para>
    /// </param>
    /// <param name="actionsOnAllTargets">
    /// <para>
    /// InfoBox: Применить действия на всех юнитов, на которых подействовал спел (AoE, projectiles). Только после каста
    /// </para>
    /// </param>
    /// <param name="merge">
    /// If mergeBehavior is ComponentMerge.Merge and the component already exists, this expression is called to merge the components.
    /// </param>
    /// <param name="mergeBehavior">
    /// Handling if the component already exists since the component is unique. Defaults to ComponentMerge.Fail.
    /// </param>
    /// <param name="spellbooks">
    /// <para>
    /// Blueprint of type BlueprintSpellbook. You can pass in the blueprint using:
    /// <list type ="bullet">
    ///   <item><term>A blueprint instance</term></item>
    ///   <item><term>A blueprint reference</term></item>
    ///   <item><term>A blueprint id as a string, Guid, or BlueprintGuid</term></item>
    ///   <item><term>A blueprint name registered with <see cref="BlueprintCore.Utils.BlueprintTool">BlueprintTool</see></term></item>
    /// </list>
    /// See <see cref="BlueprintCore.Utils.Blueprint{{T, TRef}}">Blueprint</see> for more details.
    /// </para>
    /// </param>
    public TBuilder AddAbilityUseTrigger(
        List<Blueprint<BlueprintAbility, BlueprintAbilityReference>>? abilities = null,
        Blueprint<BlueprintAbility, BlueprintAbilityReference>? ability = null,
        ActionsBuilder? action = null,
        bool? actionsOnAllTargets = null,
        bool? actionsOnTarget = null,
        bool? afterCast = null,
        bool? checkAbilityType = null,
        bool? checkDescriptor = null,
        bool? checkRange = null,
        bool? exactSpellLevel = null,
        int? exactSpellLevelLimit = null,
        bool? forMultipleSpells = null,
        bool? forOneSpell = null,
        bool? fromSpellbook = null,
        Action<BlueprintComponent, BlueprintComponent>? merge = null,
        ComponentMerge mergeBehavior = ComponentMerge.Merge,
        bool? minSpellLevel = null,
        int? minSpellLevelLimit = null,
        AbilityRange? range = null,
        List<Blueprint<BlueprintSpellbook, BlueprintSpellbookReference>>? spellbooks = null,
        SpellDescriptorWrapper? spellDescriptor = null,
        AbilityType? type = null)
    {
      var component = new AddAbilityUseTrigger();
      component.Abilities = abilities?.Select(bp => bp.Reference)?.ToList() ?? component.Abilities;
      if (component.Abilities is null)
      {
        component.Abilities = new();
      }
      component.m_Ability = ability?.Reference ?? component.m_Ability;
      if (component.m_Ability is null)
      {
        component.m_Ability = BlueprintTool.GetRef<BlueprintAbilityReference>(null);
      }
      component.Action = action?.Build() ?? component.Action;
      if (component.Action is null)
      {
        component.Action = Utils.Constants.Empty.Actions;
      }
      component.ActionsOnAllTargets = actionsOnAllTargets ?? component.ActionsOnAllTargets;
      component.ActionsOnTarget = actionsOnTarget ?? component.ActionsOnTarget;
      component.AfterCast = afterCast ?? component.AfterCast;
      component.CheckAbilityType = checkAbilityType ?? component.CheckAbilityType;
      component.CheckDescriptor = checkDescriptor ?? component.CheckDescriptor;
      component.CheckRange = checkRange ?? component.CheckRange;
      component.ExactSpellLevel = exactSpellLevel ?? component.ExactSpellLevel;
      component.ExactSpellLevelLimit = exactSpellLevelLimit ?? component.ExactSpellLevelLimit;
      component.ForMultipleSpells = forMultipleSpells ?? component.ForMultipleSpells;
      component.ForOneSpell = forOneSpell ?? component.ForOneSpell;
      component.FromSpellbook = fromSpellbook ?? component.FromSpellbook;
      component.MinSpellLevel = minSpellLevel ?? component.MinSpellLevel;
      component.MinSpellLevelLimit = minSpellLevelLimit ?? component.MinSpellLevelLimit;
      component.Range = range ?? component.Range;
      component.m_Spellbooks = spellbooks?.Select(bp => bp.Reference)?.ToArray() ?? component.m_Spellbooks;
      if (component.m_Spellbooks is null)
      {
        component.m_Spellbooks = new BlueprintSpellbookReference[0];
      }
      component.SpellDescriptor = spellDescriptor ?? component.SpellDescriptor;
      component.Type = type ?? component.Type;
      return AddUniqueComponent(component, mergeBehavior, merge);
    }

    /// <summary>
    /// Adds <see cref="AddAdditionalLimb"/>
    /// </summary>
    ///
    /// <remarks>
    ///
    /// <list type="bullet">
    /// <listheader>Used by</listheader>
    /// <item><term>AnimalCompanionUpgradeHorse</term><description>63c7fb121ab916045b4589caa44fbfb0</description></item>
    /// <item><term>DragonDiscipleBiteFeatureFire</term><description>a909bb70937f96d4c81e6dcd09962a15</description></item>
    /// <item><term>WolfScarredFaceCurseBite2d6</term><description>011156061ba439143ae9a278312ce66a</description></item>
    /// </list>
    /// </remarks>
    ///
    /// <param name="weapon">
    /// <para>
    /// Blueprint of type BlueprintItemWeapon. You can pass in the blueprint using:
    /// <list type ="bullet">
    ///   <item><term>A blueprint instance</term></item>
    ///   <item><term>A blueprint reference</term></item>
    ///   <item><term>A blueprint id as a string, Guid, or BlueprintGuid</term></item>
    ///   <item><term>A blueprint name registered with <see cref="BlueprintCore.Utils.BlueprintTool">BlueprintTool</see></term></item>
    /// </list>
    /// See <see cref="BlueprintCore.Utils.Blueprint{{T, TRef}}">Blueprint</see> for more details.
    /// </para>
    /// </param>
    public TBuilder AddAdditionalLimb(
        Blueprint<BlueprintItemWeapon, BlueprintItemWeaponReference>? weapon = null)
    {
      var component = new AddAdditionalLimb();
      component.m_Weapon = weapon?.Reference ?? component.m_Weapon;
      if (component.m_Weapon is null)
      {
        component.m_Weapon = BlueprintTool.GetRef<BlueprintItemWeaponReference>(null);
      }
      return AddComponent(component);
    }

    /// <summary>
    /// Adds <see cref="AddAttackerSpellFailureChance"/>
    /// </summary>
    ///
    /// <remarks>
    ///
    /// <list type="bullet">
    /// <listheader>Used by</listheader>
    /// <item><term>BlinkBuff</term><description>c168c6a0e471e924b8c69b31c6352587</description></item>
    /// <item><term>ScapegoatAbilityEnemyBuff</term><description>9261f8040c97eab458010defa54cb594</description></item>
    /// </list>
    /// </remarks>
    ///
    /// <param name="merge">
    /// If mergeBehavior is ComponentMerge.Merge and the component already exists, this expression is called to merge the components.
    /// </param>
    /// <param name="mergeBehavior">
    /// Handling if the component already exists since the component is unique. Defaults to ComponentMerge.Fail.
    /// </param>
    public TBuilder AddAttackerSpellFailureChance(
        int? chance = null,
        ConditionsBuilder? conditions = null,
        GameObject? failFx = null,
        Action<BlueprintComponent, BlueprintComponent>? merge = null,
        ComponentMerge mergeBehavior = ComponentMerge.Merge)
    {
      var component = new AddAttackerSpellFailureChance();
      component.Chance = chance ?? component.Chance;
      component.Conditions = conditions?.Build() ?? component.Conditions;
      if (component.Conditions is null)
      {
        component.Conditions = Utils.Constants.Empty.Conditions;
      }
      Validate(failFx);
      component.FailFx = failFx ?? component.FailFx;
      return AddUniqueComponent(component, mergeBehavior, merge);
    }

    /// <summary>
    /// Adds <see cref="AddBackgroundArmorProficiency"/>
    /// </summary>
    ///
    /// <remarks>
    ///
    /// <list type="bullet">
    /// <listheader>Used by</listheader>
    /// <item><term>BackgroundAldoriSwordsman</term><description>ce0ea6b388ac467408d6da224fab403d</description></item>
    /// <item><term>BackgroundGladiator</term><description>1ea754d5573a0ed4e9fca4c30519f247</description></item>
    /// <item><term>BackgroundMercenary</term><description>43b7315eb58242943848750af3671a25</description></item>
    /// </list>
    /// </remarks>
    ///
    /// <param name="merge">
    /// If mergeBehavior is ComponentMerge.Merge and the component already exists, this expression is called to merge the components.
    /// </param>
    /// <param name="mergeBehavior">
    /// Handling if the component already exists since the component is unique. Defaults to ComponentMerge.Fail.
    /// </param>
    /// <param name="stackBonus">
    /// <para>
    /// InfoBox: Bonus to Armor Check Penalty if unit has the same proficiency from another source
    /// </para>
    /// </param>
    public TBuilder AddBackgroundArmorProficiency(
        Action<BlueprintComponent, BlueprintComponent>? merge = null,
        ComponentMerge mergeBehavior = ComponentMerge.Merge,
        ArmorProficiencyGroup? proficiency = null,
        ContextValue? stackBonus = null)
    {
      var component = new AddBackgroundArmorProficiency();
      component.Proficiency = proficiency ?? component.Proficiency;
      component.StackBonus = stackBonus ?? component.StackBonus;
      if (component.StackBonus is null)
      {
        component.StackBonus = ContextValues.Constant(0);
      }
      return AddUniqueComponent(component, mergeBehavior, merge);
    }

    /// <summary>
    /// Adds <see cref="AddBackgroundClassSkill"/>
    /// </summary>
    ///
    /// <remarks>
    ///
    /// <list type="bullet">
    /// <listheader>Used by</listheader>
    /// <item><term>BackgroundAbsalomHaggler</term><description>82e28a28c3799ef4a85515a1fc60fec6</description></item>
    /// <item><term>BackgroundMartialDisciple</term><description>46d69a77c26701a459607c3f42e3664a</description></item>
    /// <item><term>BackgroundWarriorOfTheLinnormKings</term><description>494c972a8e7626749aeda25582e2e88f</description></item>
    /// </list>
    /// </remarks>
    ///
    /// <param name="merge">
    /// If mergeBehavior is ComponentMerge.Merge and the component already exists, this expression is called to merge the components.
    /// </param>
    /// <param name="mergeBehavior">
    /// Handling if the component already exists since the component is unique. Defaults to ComponentMerge.Fail.
    /// </param>
    public TBuilder AddBackgroundClassSkill(
        Action<BlueprintComponent, BlueprintComponent>? merge = null,
        ComponentMerge mergeBehavior = ComponentMerge.Merge,
        StatType? skill = null)
    {
      var component = new AddBackgroundClassSkill();
      component.Skill = skill ?? component.Skill;
      return AddUniqueComponent(component, mergeBehavior, merge);
    }

    /// <summary>
    /// Adds <see cref="AddBackgroundWeaponProficiency"/>
    /// </summary>
    ///
    /// <remarks>
    ///
    /// <list type="bullet">
    /// <listheader>Used by</listheader>
    /// <item><term>BackgroundAcrobat</term><description>621e1bb8e1d5e114da5a107351f5c7b3</description></item>
    /// <item><term>BackgroundLumberjack</term><description>2fc1ee0a5b240b5468efed9fffe416aa</description></item>
    /// <item><term>BackgroundWarriorOfTheLinnormKings</term><description>494c972a8e7626749aeda25582e2e88f</description></item>
    /// </list>
    /// </remarks>
    ///
    /// <param name="merge">
    /// If mergeBehavior is ComponentMerge.Merge and the component already exists, this expression is called to merge the components.
    /// </param>
    /// <param name="mergeBehavior">
    /// Handling if the component already exists since the component is unique. Defaults to ComponentMerge.Fail.
    /// </param>
    /// <param name="stackBonusType">
    /// <para>
    /// InfoBox: Bonus to Attack if unit has the same proficiency from another source
    /// </para>
    /// </param>
    public TBuilder AddBackgroundWeaponProficiency(
        Action<BlueprintComponent, BlueprintComponent>? merge = null,
        ComponentMerge mergeBehavior = ComponentMerge.Merge,
        WeaponCategory? proficiency = null,
        ContextValue? stackBonus = null,
        ModifierDescriptor? stackBonusType = null)
    {
      var component = new AddBackgroundWeaponProficiency();
      component.Proficiency = proficiency ?? component.Proficiency;
      component.StackBonus = stackBonus ?? component.StackBonus;
      if (component.StackBonus is null)
      {
        component.StackBonus = ContextValues.Constant(0);
      }
      component.StackBonusType = stackBonusType ?? component.StackBonusType;
      return AddUniqueComponent(component, mergeBehavior, merge);
    }

    /// <summary>
    /// Adds <see cref="AddBondProperty"/>
    /// </summary>
    ///
    /// <remarks>
    ///
    /// <list type="bullet">
    /// <listheader>Used by</listheader>
    /// <item><term>ArcaneArmorEnchantAcidResist10Buff</term><description>94f3b00c96f60a6479c3b61c57d0ce89</description></item>
    /// <item><term>SacredArmorEnchantElectricityResist10Buff</term><description>c2f5c35adcb889c42aef37bc4f9add71</description></item>
    /// <item><term>WeaponBondSpeedBuff</term><description>f260f8100cd9f6749bf071c930eb287d</description></item>
    /// </list>
    /// </remarks>
    ///
    /// <param name="enchant">
    /// <para>
    /// Blueprint of type BlueprintItemEnchantment. You can pass in the blueprint using:
    /// <list type ="bullet">
    ///   <item><term>A blueprint instance</term></item>
    ///   <item><term>A blueprint reference</term></item>
    ///   <item><term>A blueprint id as a string, Guid, or BlueprintGuid</term></item>
    ///   <item><term>A blueprint name registered with <see cref="BlueprintCore.Utils.BlueprintTool">BlueprintTool</see></term></item>
    /// </list>
    /// See <see cref="BlueprintCore.Utils.Blueprint{{T, TRef}}">Blueprint</see> for more details.
    /// </para>
    /// </param>
    public TBuilder AddBondProperty(
        Blueprint<BlueprintItemEnchantment, BlueprintItemEnchantmentReference>? enchant = null,
        EnchantPoolType? enchantPool = null)
    {
      var component = new AddBondProperty();
      component.m_Enchant = enchant?.Reference ?? component.m_Enchant;
      if (component.m_Enchant is null)
      {
        component.m_Enchant = BlueprintTool.GetRef<BlueprintItemEnchantmentReference>(null);
      }
      component.EnchantPool = enchantPool ?? component.EnchantPool;
      return AddComponent(component);
    }

    /// <summary>
    /// Adds <see cref="AddBuffInBadWeather"/>
    /// </summary>
    ///
    /// <remarks>
    ///
    /// <list type="bullet">
    /// <listheader>Used by</listheader>
    /// <item><term>StormBuff</term><description>0aeba56961779e54a8a0f6dedef081ee</description></item>
    /// </list>
    /// </remarks>
    ///
    /// <param name="buff">
    /// <para>
    /// Blueprint of type BlueprintBuff. You can pass in the blueprint using:
    /// <list type ="bullet">
    ///   <item><term>A blueprint instance</term></item>
    ///   <item><term>A blueprint reference</term></item>
    ///   <item><term>A blueprint id as a string, Guid, or BlueprintGuid</term></item>
    ///   <item><term>A blueprint name registered with <see cref="BlueprintCore.Utils.BlueprintTool">BlueprintTool</see></term></item>
    /// </list>
    /// See <see cref="BlueprintCore.Utils.Blueprint{{T, TRef}}">Blueprint</see> for more details.
    /// </para>
    /// </param>
    public TBuilder AddBuffInBadWeather(
        Blueprint<BlueprintBuff, BlueprintBuffReference>? buff = null,
        InclemencyType? weather = null,
        bool? whenCalmer = null)
    {
      var component = new AddBuffInBadWeather();
      component.m_Buff = buff?.Reference ?? component.m_Buff;
      if (component.m_Buff is null)
      {
        component.m_Buff = BlueprintTool.GetRef<BlueprintBuffReference>(null);
      }
      component.Weather = weather ?? component.Weather;
      component.WhenCalmer = whenCalmer ?? component.WhenCalmer;
      return AddComponent(component);
    }

    /// <summary>
    /// Adds <see cref="AddBuffOnApplyingSpell"/>
    /// </summary>
    ///
    /// <remarks>
    ///
    /// <list type="bullet">
    /// <listheader>Used by</listheader>
    /// <item><term>BlightedQuickwood_Feature_Fear</term><description>f653afef52ddbd742ba43e808302fdb4</description></item>
    /// <item><term>DweomercatSpellLinkIllusionFeature</term><description>07905613e720cb94b84540c1579c7eee</description></item>
    /// <item><term>MusicianFeature_Restoration</term><description>465afee6825d43fdbf78c3d2052eb74b</description></item>
    /// </list>
    /// </remarks>
    public TBuilder AddBuffOnApplyingSpell(
        AddBuffOnApplyingSpell.SpellConditionAndBuff[]? buffs = null,
        bool? onEffectApplied = null,
        bool? onResistSpell = null)
    {
      var component = new AddBuffOnApplyingSpell();
      foreach (var item in buffs) { Validate(item); }
      component.Buffs = buffs ?? component.Buffs;
      if (component.Buffs is null)
      {
        component.Buffs = new AddBuffOnApplyingSpell.SpellConditionAndBuff[0];
      }
      component.OnEffectApplied = onEffectApplied ?? component.OnEffectApplied;
      component.OnResistSpell = onResistSpell ?? component.OnResistSpell;
      return AddComponent(component);
    }

    /// <summary>
    /// Adds <see cref="AddCasterSpellFailureChance"/>
    /// </summary>
    ///
    /// <remarks>
    ///
    /// <list type="bullet">
    /// <listheader>Used by</listheader>
    /// <item><term>ScapegoatAbilityEnemyBuff</term><description>9261f8040c97eab458010defa54cb594</description></item>
    /// </list>
    /// </remarks>
    ///
    /// <param name="merge">
    /// If mergeBehavior is ComponentMerge.Merge and the component already exists, this expression is called to merge the components.
    /// </param>
    /// <param name="mergeBehavior">
    /// Handling if the component already exists since the component is unique. Defaults to ComponentMerge.Fail.
    /// </param>
    public TBuilder AddCasterSpellFailureChance(
        int? chance = null,
        ConditionsBuilder? conditions = null,
        GameObject? failFx = null,
        Action<BlueprintComponent, BlueprintComponent>? merge = null,
        ComponentMerge mergeBehavior = ComponentMerge.Merge)
    {
      var component = new AddCasterSpellFailureChance();
      component.Chance = chance ?? component.Chance;
      component.Conditions = conditions?.Build() ?? component.Conditions;
      if (component.Conditions is null)
      {
        component.Conditions = Utils.Constants.Empty.Conditions;
      }
      Validate(failFx);
      component.FailFx = failFx ?? component.FailFx;
      return AddUniqueComponent(component, mergeBehavior, merge);
    }

    /// <summary>
    /// Adds <see cref="AddClassSkill"/>
    /// </summary>
    ///
    /// <remarks>
    ///
    /// <list type="bullet">
    /// <listheader>Used by</listheader>
    /// <item><term>AirClassSkills</term><description>5f6197b9fde96d840882b858208d2809</description></item>
    /// <item><term>CavalierLionSkills</term><description>7c00cd81a50bd4944bce094d870c8f5e</description></item>
    /// <item><term>WitchOfTheVeilSecrecyFeature</term><description>8c189560d7f94dd688f0dc29f6963610</description></item>
    /// </list>
    /// </remarks>
    ///
    /// <param name="merge">
    /// If mergeBehavior is ComponentMerge.Merge and the component already exists, this expression is called to merge the components.
    /// </param>
    /// <param name="mergeBehavior">
    /// Handling if the component already exists since the component is unique. Defaults to ComponentMerge.Fail.
    /// </param>
    public TBuilder AddClassSkill(
        Action<BlueprintComponent, BlueprintComponent>? merge = null,
        ComponentMerge mergeBehavior = ComponentMerge.Merge,
        StatType? skill = null)
    {
      var component = new AddClassSkill();
      component.Skill = skill ?? component.Skill;
      return AddUniqueComponent(component, mergeBehavior, merge);
    }

    /// <summary>
    /// Adds <see cref="AddClusteredAttack"/>
    /// </summary>
    ///
    /// <remarks>
    ///
    /// <list type="bullet">
    /// <listheader>Used by</listheader>
    /// <item><term>ClusteredShots</term><description>f7de245bb20f12f47864c7cb8b1d1abb</description></item>
    /// <item><term>PummelingStyleBuff</term><description>8cb3816915b1a8348b3872b964a2fa23</description></item>
    /// </list>
    /// </remarks>
    public TBuilder AddClusteredAttack(
        AddClusteredAttack.Type? attackType = null)
    {
      var component = new AddClusteredAttack();
      component.AttackType = attackType ?? component.AttackType;
      return AddComponent(component);
    }

    /// <summary>
    /// Adds <see cref="AddConcealment"/>
    /// </summary>
    ///
    /// <remarks>
    ///
    /// <list type="bullet">
    /// <listheader>Used by</listheader>
    /// <item><term>AnomalyTemplateDefensive_MaelstromsDisplacementEffectBuff</term><description>f1c8732f09714cd38fc75d2b73ce7002</description></item>
    /// <item><term>HermitRevelationFadeFromMemoryBuff</term><description>d2827b1f12da932448de212fd1888813</description></item>
    /// <item><term>WindsOfVengeanceBuff</term><description>796a2fe600e5ead41b29cd9963cf2de9</description></item>
    /// </list>
    /// </remarks>
    public TBuilder AddConcealment(
        bool? checkDistance = null,
        bool? checkWeaponRangeType = null,
        Concealment? concealment = null,
        ConcealmentDescriptor? descriptor = null,
        Feet? distanceGreater = null,
        bool? onlyForAttacks = null,
        WeaponRangeType? rangeType = null)
    {
      var component = new AddConcealment();
      component.CheckDistance = checkDistance ?? component.CheckDistance;
      component.CheckWeaponRangeType = checkWeaponRangeType ?? component.CheckWeaponRangeType;
      component.Concealment = concealment ?? component.Concealment;
      component.Descriptor = descriptor ?? component.Descriptor;
      component.DistanceGreater = distanceGreater ?? component.DistanceGreater;
      component.OnlyForAttacks = onlyForAttacks ?? component.OnlyForAttacks;
      component.RangeType = rangeType ?? component.RangeType;
      return AddComponent(component);
    }

    /// <summary>
    /// Adds <see cref="AddCondition"/>
    /// </summary>
    ///
    /// <remarks>
    ///
    /// <para>
    /// ComponentName: Add condition
    /// </para>
    ///
    /// <list type="bullet">
    /// <listheader>Used by</listheader>
    /// <item><term>Abrikandilu_Frozen_Buff</term><description>b2df7031cdad480caddf962c894ca484</description></item>
    /// <item><term>IcyPrisonParalyzedBuff</term><description>6f0e450771cc7d446aea798e1fef1c7a</description></item>
    /// <item><term>ZachariusFearAuraEffectBuff</term><description>384831c7bbbbe62469a9e3247545d73d</description></item>
    /// </list>
    /// </remarks>
    ///
    /// <param name="merge">
    /// If mergeBehavior is ComponentMerge.Merge and the component already exists, this expression is called to merge the components.
    /// </param>
    /// <param name="mergeBehavior">
    /// Handling if the component already exists since the component is unique. Defaults to ComponentMerge.Fail.
    /// </param>
    public TBuilder AddCondition(
        UnitCondition? condition = null,
        UnitConditionExceptions? exceptions = null,
        Action<BlueprintComponent, BlueprintComponent>? merge = null,
        ComponentMerge mergeBehavior = ComponentMerge.Merge)
    {
      var component = new AddCondition();
      component.Condition = condition ?? component.Condition;
      Validate(exceptions);
      component.Exceptions = exceptions ?? component.Exceptions;
      return AddUniqueComponent(component, mergeBehavior, merge);
    }

    /// <summary>
    /// Adds <see cref="AddConditionImmunity"/>
    /// </summary>
    ///
    /// <remarks>
    ///
    /// <para>
    /// ComponentName: Add condition immunity
    /// </para>
    ///
    /// <list type="bullet">
    /// <listheader>Used by</listheader>
    /// <item><term>AcrobaticMovement</term><description>483667247e2441740ad0cff6a67b50e3</description></item>
    /// <item><term>FormOfTheDragonIIIBronzeBuff</term><description>1d3d388fd7b740842bde43dfb0aa56bb</description></item>
    /// <item><term>WingsDiabolic</term><description>4113178a8d5bf4841b8f15b1b39e004f</description></item>
    /// </list>
    /// </remarks>
    ///
    /// <param name="merge">
    /// If mergeBehavior is ComponentMerge.Merge and the component already exists, this expression is called to merge the components.
    /// </param>
    /// <param name="mergeBehavior">
    /// Handling if the component already exists since the component is unique. Defaults to ComponentMerge.Fail.
    /// </param>
    public TBuilder AddConditionImmunity(
        UnitCondition? condition = null,
        Action<BlueprintComponent, BlueprintComponent>? merge = null,
        ComponentMerge mergeBehavior = ComponentMerge.Merge)
    {
      var component = new AddConditionImmunity();
      component.Condition = condition ?? component.Condition;
      return AddUniqueComponent(component, mergeBehavior, merge);
    }

    /// <summary>
    /// Adds <see cref="AddConditionTrigger"/>
    /// </summary>
    ///
    /// <remarks>
    ///
    /// <list type="bullet">
    /// <listheader>Used by</listheader>
    /// <item><term>BreakControlCountBuff1</term><description>c8dc3ca3c28444f5b819c37a4649ce66</description></item>
    /// <item><term>LeatherMantleOfNightFeatureNew</term><description>3f8e38a03f2b44ae8b90b927149aeb23</description></item>
    /// <item><term>RovagugRelicSteppeBuff</term><description>3bd677c6ff3a47219e82405a1d5234dd</description></item>
    /// </list>
    /// </remarks>
    ///
    /// <param name="merge">
    /// If mergeBehavior is ComponentMerge.Merge and the component already exists, this expression is called to merge the components.
    /// </param>
    /// <param name="mergeBehavior">
    /// Handling if the component already exists since the component is unique. Defaults to ComponentMerge.Fail.
    /// </param>
    public TBuilder AddConditionTrigger(
        ActionsBuilder? action = null,
        UnitCondition[]? conditions = null,
        Action<BlueprintComponent, BlueprintComponent>? merge = null,
        ComponentMerge mergeBehavior = ComponentMerge.Merge,
        AddConditionTrigger.TriggerType? triggerType = null)
    {
      var component = new AddConditionTrigger();
      component.Action = action?.Build() ?? component.Action;
      if (component.Action is null)
      {
        component.Action = Utils.Constants.Empty.Actions;
      }
      component.Conditions = conditions ?? component.Conditions;
      if (component.Conditions is null)
      {
        component.Conditions = new UnitCondition[0];
      }
      component.m_TriggerType = triggerType ?? component.m_TriggerType;
      return AddUniqueComponent(component, mergeBehavior, merge);
    }

    /// <summary>
    /// Adds <see cref="AddCumulativeDamageBonus"/>
    /// </summary>
    ///
    /// <remarks>
    ///
    /// <list type="bullet">
    /// <listheader>Used by</listheader>
    /// <item><term>HammerTheGap</term><description>7b64641c76ff4a744a2bce7f91a20f9a</description></item>
    /// <item><term>NaturalRythmBuff</term><description>6095dc2d92b97e146b02d025f54af5ef</description></item>
    /// </list>
    /// </remarks>
    public TBuilder AddCumulativeDamageBonus(
        bool? onlyNaturalAttacks = null)
    {
      var component = new AddCumulativeDamageBonus();
      component.OnlyNaturalAttacks = onlyNaturalAttacks ?? component.OnlyNaturalAttacks;
      return AddComponent(component);
    }

    /// <summary>
    /// Adds <see cref="AddCumulativeDamageBonusX3"/>
    /// </summary>
    ///
    /// <remarks>
    ///
    /// <list type="bullet">
    /// <listheader>Used by</listheader>
    /// <item><term>NemaryStigma_HatredFeature</term><description>835965babf38498d8f523fd4001aa44c</description></item>
    /// </list>
    /// </remarks>
    public TBuilder AddCumulativeDamageBonusX3(
        bool? onlyNaturalAttacks = null)
    {
      var component = new AddCumulativeDamageBonusX3();
      component.OnlyNaturalAttacks = onlyNaturalAttacks ?? component.OnlyNaturalAttacks;
      return AddComponent(component);
    }

    /// <summary>
    /// Adds <see cref="AddDamageResistanceEnergy"/>
    /// </summary>
    ///
    /// <remarks>
    ///
    /// <para>
    /// ComponentName: Buffs/AddEffect/EnergyResistance
    /// </para>
    ///
    /// <list type="bullet">
    /// <listheader>Used by</listheader>
    /// <item><term>AcidResistance10</term><description>64e647c10eece1545b00a442330f49da</description></item>
    /// <item><term>FireResistance10</term><description>24700a71dd3dc844ea585345f6dd18f6</description></item>
    /// <item><term>WoljifCopyBuff5</term><description>41f565ee6baa69f468fb2f8295064486</description></item>
    /// </list>
    /// </remarks>
    ///
    /// <param name="merge">
    /// If mergeBehavior is ComponentMerge.Merge and the component already exists, this expression is called to merge the components.
    /// </param>
    /// <param name="mergeBehavior">
    /// Handling if the component already exists since the component is unique. Defaults to ComponentMerge.Fail.
    /// </param>
    public TBuilder AddDamageResistanceEnergy(
        Action<BlueprintComponent, BlueprintComponent>? merge = null,
        ComponentMerge mergeBehavior = ComponentMerge.Merge,
        ContextValue? pool = null,
        DamageEnergyType? type = null,
        bool? usePool = null,
        bool? useValueMultiplier = null,
        ContextValue? value = null,
        ContextValue? valueMultiplier = null)
    {
      var component = new AddDamageResistanceEnergy();
      component.Pool = pool ?? component.Pool;
      if (component.Pool is null)
      {
        component.Pool = ContextValues.Constant(0);
      }
      component.Type = type ?? component.Type;
      component.UsePool = usePool ?? component.UsePool;
      component.UseValueMultiplier = useValueMultiplier ?? component.UseValueMultiplier;
      component.Value = value ?? component.Value;
      if (component.Value is null)
      {
        component.Value = ContextValues.Constant(0);
      }
      component.ValueMultiplier = valueMultiplier ?? component.ValueMultiplier;
      if (component.ValueMultiplier is null)
      {
        component.ValueMultiplier = ContextValues.Constant(0);
      }
      return AddUniqueComponent(component, mergeBehavior, merge);
    }

    /// <summary>
    /// Adds <see cref="AddDamageResistanceForce"/>
    /// </summary>
    ///
    /// <remarks>
    ///
    /// <para>
    /// ComponentName: Buffs/AddEffect/EnergyResistance
    /// </para>
    ///
    /// <list type="bullet">
    /// <listheader>Used by</listheader>
    /// <item><term>ForceResistance20</term><description>cea02e0ba8797a446b24ce73e41c13cc</description></item>
    /// <item><term>ForceResistance30</term><description>8a9ee08a77679114b83bcb74c20b6191</description></item>
    /// <item><term>SolarWindsBuff</term><description>7f157cec45d28e54f9e580425d0fbdbe</description></item>
    /// </list>
    /// </remarks>
    ///
    /// <param name="merge">
    /// If mergeBehavior is ComponentMerge.Merge and the component already exists, this expression is called to merge the components.
    /// </param>
    /// <param name="mergeBehavior">
    /// Handling if the component already exists since the component is unique. Defaults to ComponentMerge.Fail.
    /// </param>
    public TBuilder AddDamageResistanceForce(
        Action<BlueprintComponent, BlueprintComponent>? merge = null,
        ComponentMerge mergeBehavior = ComponentMerge.Merge,
        ContextValue? pool = null,
        DamageEnergyType? type = null,
        bool? usePool = null,
        bool? useValueMultiplier = null,
        ContextValue? value = null,
        ContextValue? valueMultiplier = null)
    {
      var component = new AddDamageResistanceForce();
      component.Pool = pool ?? component.Pool;
      if (component.Pool is null)
      {
        component.Pool = ContextValues.Constant(0);
      }
      component.Type = type ?? component.Type;
      component.UsePool = usePool ?? component.UsePool;
      component.UseValueMultiplier = useValueMultiplier ?? component.UseValueMultiplier;
      component.Value = value ?? component.Value;
      if (component.Value is null)
      {
        component.Value = ContextValues.Constant(0);
      }
      component.ValueMultiplier = valueMultiplier ?? component.ValueMultiplier;
      if (component.ValueMultiplier is null)
      {
        component.ValueMultiplier = ContextValues.Constant(0);
      }
      return AddUniqueComponent(component, mergeBehavior, merge);
    }

    /// <summary>
    /// Adds <see cref="AddDamageResistanceHardness"/>
    /// </summary>
    ///
    /// <remarks>
    ///
    /// <para>
    /// ComponentName: Buffs/AddEffect/Hardness
    /// </para>
    ///
    /// <list type="bullet">
    /// <listheader>Used by</listheader>
    /// <item><term>Hardness10</term><description>937ada06eb15412a8d80a96d1cca4dc2</description></item>
    /// <item><term>Hardness20</term><description>64f281fa5a6c46e597f501d9ed4a2d23</description></item>
    /// <item><term>Hardness30</term><description>51c7b076333a471ab69ff783ad155f9b</description></item>
    /// </list>
    /// </remarks>
    ///
    /// <param name="merge">
    /// If mergeBehavior is ComponentMerge.Merge and the component already exists, this expression is called to merge the components.
    /// </param>
    /// <param name="mergeBehavior">
    /// Handling if the component already exists since the component is unique. Defaults to ComponentMerge.Fail.
    /// </param>
    public TBuilder AddDamageResistanceHardness(
        Action<BlueprintComponent, BlueprintComponent>? merge = null,
        ComponentMerge mergeBehavior = ComponentMerge.Merge,
        ContextValue? pool = null,
        bool? usePool = null,
        ContextValue? value = null)
    {
      var component = new AddDamageResistanceHardness();
      component.Pool = pool ?? component.Pool;
      if (component.Pool is null)
      {
        component.Pool = ContextValues.Constant(0);
      }
      component.UsePool = usePool ?? component.UsePool;
      component.Value = value ?? component.Value;
      if (component.Value is null)
      {
        component.Value = ContextValues.Constant(0);
      }
      return AddUniqueComponent(component, mergeBehavior, merge);
    }

    /// <summary>
    /// Adds <see cref="AddDamageResistancePhysical"/>
    /// </summary>
    ///
    /// <remarks>
    ///
    /// <para>
    /// ComponentName: Buffs/AddEffect/DR
    /// </para>
    ///
    /// <list type="bullet">
    /// <listheader>Used by</listheader>
    /// <item><term>AbyssalCreatureAcidTemplate</term><description>6e6fda1c8a35069468e7398082cd30f5</description></item>
    /// <item><term>ElementalBodyIVAirBuff</term><description>ba06b8cff52da9e4d8432144ed6a6d19</description></item>
    /// <item><term>WildShapeElementalWaterHugeBuff</term><description>ea2cd08bdf2ca1c4f8a8870804790cd7</description></item>
    /// </list>
    /// </remarks>
    ///
    /// <param name="checkedFactMythic">
    /// <para>
    /// Blueprint of type BlueprintUnitFact. You can pass in the blueprint using:
    /// <list type ="bullet">
    ///   <item><term>A blueprint instance</term></item>
    ///   <item><term>A blueprint reference</term></item>
    ///   <item><term>A blueprint id as a string, Guid, or BlueprintGuid</term></item>
    ///   <item><term>A blueprint name registered with <see cref="BlueprintCore.Utils.BlueprintTool">BlueprintTool</see></term></item>
    /// </list>
    /// See <see cref="BlueprintCore.Utils.Blueprint{{T, TRef}}">Blueprint</see> for more details.
    /// </para>
    /// </param>
    /// <param name="merge">
    /// If mergeBehavior is ComponentMerge.Merge and the component already exists, this expression is called to merge the components.
    /// </param>
    /// <param name="mergeBehavior">
    /// Handling if the component already exists since the component is unique. Defaults to ComponentMerge.Fail.
    /// </param>
    /// <param name="weaponType">
    /// <para>
    /// Blueprint of type BlueprintWeaponType. You can pass in the blueprint using:
    /// <list type ="bullet">
    ///   <item><term>A blueprint instance</term></item>
    ///   <item><term>A blueprint reference</term></item>
    ///   <item><term>A blueprint id as a string, Guid, or BlueprintGuid</term></item>
    ///   <item><term>A blueprint name registered with <see cref="BlueprintCore.Utils.BlueprintTool">BlueprintTool</see></term></item>
    /// </list>
    /// See <see cref="BlueprintCore.Utils.Blueprint{{T, TRef}}">Blueprint</see> for more details.
    /// </para>
    /// </param>
    public TBuilder AddDamageResistancePhysical(
        DamageAlignment? alignment = null,
        bool? bypassedByAlignment = null,
        bool? bypassedByEpic = null,
        bool? bypassedByForm = null,
        bool? bypassedByMagic = null,
        bool? bypassedByMaterial = null,
        bool? bypassedByMeleeWeapon = null,
        bool? bypassedByReality = null,
        bool? bypassedByWeaponType = null,
        Blueprint<BlueprintUnitFact, BlueprintUnitFactReference>? checkedFactMythic = null,
        PhysicalDamageForm? form = null,
        PhysicalDamageMaterial? material = null,
        Action<BlueprintComponent, BlueprintComponent>? merge = null,
        ComponentMerge mergeBehavior = ComponentMerge.Merge,
        int? minEnhancementBonus = null,
        bool? or = null,
        ContextValue? pool = null,
        DamageRealityType? reality = null,
        bool? usePool = null,
        ContextValue? value = null,
        Blueprint<BlueprintWeaponType, BlueprintWeaponTypeReference>? weaponType = null)
    {
      var component = new AddDamageResistancePhysical();
      component.Alignment = alignment ?? component.Alignment;
      component.BypassedByAlignment = bypassedByAlignment ?? component.BypassedByAlignment;
      component.BypassedByEpic = bypassedByEpic ?? component.BypassedByEpic;
      component.BypassedByForm = bypassedByForm ?? component.BypassedByForm;
      component.BypassedByMagic = bypassedByMagic ?? component.BypassedByMagic;
      component.BypassedByMaterial = bypassedByMaterial ?? component.BypassedByMaterial;
      component.BypassedByMeleeWeapon = bypassedByMeleeWeapon ?? component.BypassedByMeleeWeapon;
      component.BypassedByReality = bypassedByReality ?? component.BypassedByReality;
      component.BypassedByWeaponType = bypassedByWeaponType ?? component.BypassedByWeaponType;
      component.m_CheckedFactMythic = checkedFactMythic?.Reference ?? component.m_CheckedFactMythic;
      if (component.m_CheckedFactMythic is null)
      {
        component.m_CheckedFactMythic = BlueprintTool.GetRef<BlueprintUnitFactReference>(null);
      }
      component.Form = form ?? component.Form;
      component.Material = material ?? component.Material;
      component.MinEnhancementBonus = minEnhancementBonus ?? component.MinEnhancementBonus;
      component.Or = or ?? component.Or;
      component.Pool = pool ?? component.Pool;
      if (component.Pool is null)
      {
        component.Pool = ContextValues.Constant(0);
      }
      component.Reality = reality ?? component.Reality;
      component.UsePool = usePool ?? component.UsePool;
      component.Value = value ?? component.Value;
      if (component.Value is null)
      {
        component.Value = ContextValues.Constant(0);
      }
      component.m_WeaponType = weaponType?.Reference ?? component.m_WeaponType;
      if (component.m_WeaponType is null)
      {
        component.m_WeaponType = BlueprintTool.GetRef<BlueprintWeaponTypeReference>(null);
      }
      return AddUniqueComponent(component, mergeBehavior, merge);
    }

    /// <summary>
    /// Adds <see cref="AddDamageTypeVulnerability"/>
    /// </summary>
    ///
    /// <remarks>
    ///
    /// <list type="bullet">
    /// <listheader>Used by</listheader>
    /// <item><term>ArmyMarkofVengeanceOnHitBuff</term><description>508c43871245482d99597a1c98c12ab3</description></item>
    /// <item><term>EntomberBuff</term><description>da814be8a002728419c99b1ed7c0f70a</description></item>
    /// <item><term>WaterTorrentBuff</term><description>62a04b00cef8bba4ca63e956f6184e6e</description></item>
    /// </list>
    /// </remarks>
    ///
    /// <param name="merge">
    /// If mergeBehavior is ComponentMerge.Merge and the component already exists, this expression is called to merge the components.
    /// </param>
    /// <param name="mergeBehavior">
    /// Handling if the component already exists since the component is unique. Defaults to ComponentMerge.Fail.
    /// </param>
    public TBuilder AddDamageTypeVulnerability(
        DamageAlignment? damageAlignmentType = null,
        PhysicalDamageForm? formType = null,
        PhysicalDamageMaterial? materialType = null,
        Action<BlueprintComponent, BlueprintComponent>? merge = null,
        ComponentMerge mergeBehavior = ComponentMerge.Merge,
        bool? physcicalAlignment = null,
        bool? physcicalForm = null,
        bool? physcicalMaterial = null)
    {
      var component = new AddDamageTypeVulnerability();
      component.DamageAlignmentType = damageAlignmentType ?? component.DamageAlignmentType;
      component.FormType = formType ?? component.FormType;
      component.MaterialType = materialType ?? component.MaterialType;
      component.PhyscicalAlignment = physcicalAlignment ?? component.PhyscicalAlignment;
      component.PhyscicalForm = physcicalForm ?? component.PhyscicalForm;
      component.PhyscicalMaterial = physcicalMaterial ?? component.PhyscicalMaterial;
      return AddUniqueComponent(component, mergeBehavior, merge);
    }

    /// <summary>
    /// Adds <see cref="AddEnergyDamageDivisor"/>
    /// </summary>
    ///
    /// <remarks>
    ///
    /// <list type="bullet">
    /// <listheader>Used by</listheader>
    /// <item><term>Artifact_HornsOfNaragaFeature</term><description>ef431b6114fd478b8b1761087eb2bcd7</description></item>
    /// </list>
    /// </remarks>
    public TBuilder AddEnergyDamageDivisor(
        DamageEnergyTypeFlag? affectedEnergyType = null)
    {
      var component = new AddEnergyDamageDivisor();
      component.AffectedEnergyType = affectedEnergyType ?? component.AffectedEnergyType;
      return AddComponent(component);
    }

    /// <summary>
    /// Adds <see cref="AddEnergyDamageImmunity"/>
    /// </summary>
    ///
    /// <remarks>
    ///
    /// <list type="bullet">
    /// <listheader>Used by</listheader>
    /// <item><term>AnimalisticPerseveranceBuff</term><description>531c05afee72407c812aba796f925718</description></item>
    /// <item><term>BucklerOfElementalGuardBuffAcid</term><description>689b8beee599485b98138d8ea8735b97</description></item>
    /// <item><term>ThroneKeeperFeature</term><description>8c7de3b7d51a4b49a46990d8dbc84853</description></item>
    /// </list>
    /// </remarks>
    ///
    /// <param name="merge">
    /// If mergeBehavior is ComponentMerge.Merge and the component already exists, this expression is called to merge the components.
    /// </param>
    /// <param name="mergeBehavior">
    /// Handling if the component already exists since the component is unique. Defaults to ComponentMerge.Fail.
    /// </param>
    public TBuilder AddEnergyDamageImmunity(
        DamageEnergyType? energyType = null,
        bool? healOnDamage = null,
        AddEnergyDamageImmunity.HealingRate? healRate = null,
        Action<BlueprintComponent, BlueprintComponent>? merge = null,
        ComponentMerge mergeBehavior = ComponentMerge.Merge)
    {
      var component = new AddEnergyDamageImmunity();
      component.EnergyType = energyType ?? component.EnergyType;
      component.HealOnDamage = healOnDamage ?? component.HealOnDamage;
      component.m_HealRate = healRate ?? component.m_HealRate;
      return AddUniqueComponent(component, mergeBehavior, merge);
    }

    /// <summary>
    /// Adds <see cref="AddEnergyImmunity"/>
    /// </summary>
    ///
    /// <remarks>
    ///
    /// <para>
    /// ComponentName: Buffs/AddEffect/EnergyImmunity
    /// </para>
    ///
    /// <list type="bullet">
    /// <listheader>Used by</listheader>
    /// <item><term>AbyssalCreatureAcidTemplate</term><description>6e6fda1c8a35069468e7398082cd30f5</description></item>
    /// <item><term>FireDomainCapstone</term><description>6c46620d4cab41b42be8dd8cfb1aa9d2</description></item>
    /// <item><term>WelcomeRespiteFeature</term><description>a02a6cd1f02a95442805e417b9ec0a32</description></item>
    /// </list>
    /// </remarks>
    ///
    /// <param name="merge">
    /// If mergeBehavior is ComponentMerge.Merge and the component already exists, this expression is called to merge the components.
    /// </param>
    /// <param name="mergeBehavior">
    /// Handling if the component already exists since the component is unique. Defaults to ComponentMerge.Fail.
    /// </param>
    public TBuilder AddEnergyImmunity(
        Action<BlueprintComponent, BlueprintComponent>? merge = null,
        ComponentMerge mergeBehavior = ComponentMerge.Merge,
        DamageEnergyType? type = null)
    {
      var component = new AddEnergyImmunity();
      component.Type = type ?? component.Type;
      return AddUniqueComponent(component, mergeBehavior, merge);
    }

    /// <summary>
    /// Adds <see cref="AddEnergyVulnerability"/>
    /// </summary>
    ///
    /// <remarks>
    ///
    /// <para>
    /// ComponentName: Buffs/AddEffect/EnergyVulnerability
    /// </para>
    ///
    /// <list type="bullet">
    /// <listheader>Used by</listheader>
    /// <item><term>AcidVulnerability</term><description>1b7cf095756cce543a0191e3996118a1</description></item>
    /// <item><term>MorningstarRoyalLegendaryFrostFeature</term><description>4dff3d78cdf7bf74e9f0ef1af346f52a</description></item>
    /// <item><term>WintersMarkMainBuff</term><description>e0f30718f7f00c243965ede9619c6216</description></item>
    /// </list>
    /// </remarks>
    ///
    /// <param name="merge">
    /// If mergeBehavior is ComponentMerge.Merge and the component already exists, this expression is called to merge the components.
    /// </param>
    /// <param name="mergeBehavior">
    /// Handling if the component already exists since the component is unique. Defaults to ComponentMerge.Fail.
    /// </param>
    public TBuilder AddEnergyVulnerability(
        Action<BlueprintComponent, BlueprintComponent>? merge = null,
        ComponentMerge mergeBehavior = ComponentMerge.Merge,
        DamageEnergyType? type = null)
    {
      var component = new AddEnergyVulnerability();
      component.Type = type ?? component.Type;
      return AddUniqueComponent(component, mergeBehavior, merge);
    }

    /// <summary>
    /// Adds <see cref="AddEquipmentEntity"/>
    /// </summary>
    ///
    /// <remarks>
    ///
    /// <list type="bullet">
    /// <listheader>Used by</listheader>
    /// <item><term>BuffWingsAngel</term><description>d596694ff285f3f429528547f441b1c0</description></item>
    /// <item><term>BuffWingsDraconicRed</term><description>08ae1c01155a2184db869e9ebedc758d</description></item>
    /// <item><term>KineticKnightElementalFocusWater</term><description>5e839c743c6da6649a43cdeb70b6018f</description></item>
    /// </list>
    /// </remarks>
    public TBuilder AddEquipmentEntity(
        EquipmentEntityLink? equipmentEntity = null)
    {
      var component = new AddEquipmentEntity();
      Validate(equipmentEntity);
      component.EquipmentEntity = equipmentEntity ?? component.EquipmentEntity;
      return AddComponent(component);
    }

    /// <summary>
    /// Adds <see cref="AddFactsFromCaster"/>
    /// </summary>
    ///
    /// <remarks>
    ///
    /// <list type="bullet">
    /// <listheader>Used by</listheader>
    /// <item><term>BattleProwessEffectBuff</term><description>8c8cb2f8d83035e45843a88655da8321</description></item>
    /// <item><term>MarilithLeadershipBuff</term><description>9343766524f6cae488a5f921e32f0fd8</description></item>
    /// <item><term>ZeorisDaggerHeadband_GoverningBuff</term><description>984776fe2ad9466fa2e7ce5d9b404afd</description></item>
    /// </list>
    /// </remarks>
    ///
    /// <param name="facts">
    /// <para>
    /// Blueprint of type BlueprintUnitFact. You can pass in the blueprint using:
    /// <list type ="bullet">
    ///   <item><term>A blueprint instance</term></item>
    ///   <item><term>A blueprint reference</term></item>
    ///   <item><term>A blueprint id as a string, Guid, or BlueprintGuid</term></item>
    ///   <item><term>A blueprint name registered with <see cref="BlueprintCore.Utils.BlueprintTool">BlueprintTool</see></term></item>
    /// </list>
    /// See <see cref="BlueprintCore.Utils.Blueprint{{T, TRef}}">Blueprint</see> for more details.
    /// </para>
    /// </param>
    /// <param name="selection">
    /// <para>
    /// Blueprint of type BlueprintFeatureSelection. You can pass in the blueprint using:
    /// <list type ="bullet">
    ///   <item><term>A blueprint instance</term></item>
    ///   <item><term>A blueprint reference</term></item>
    ///   <item><term>A blueprint id as a string, Guid, or BlueprintGuid</term></item>
    ///   <item><term>A blueprint name registered with <see cref="BlueprintCore.Utils.BlueprintTool">BlueprintTool</see></term></item>
    /// </list>
    /// See <see cref="BlueprintCore.Utils.Blueprint{{T, TRef}}">Blueprint</see> for more details.
    /// </para>
    /// </param>
    public TBuilder AddFactsFromCaster(
        List<Blueprint<BlueprintUnitFact, BlueprintUnitFactReference>>? facts = null,
        bool? featureFromSelection = null,
        Blueprint<BlueprintFeatureSelection, BlueprintFeatureSelectionReference>? selection = null)
    {
      var component = new AddFactsFromCaster();
      component.m_Facts = facts?.Select(bp => bp.Reference)?.ToArray() ?? component.m_Facts;
      if (component.m_Facts is null)
      {
        component.m_Facts = new BlueprintUnitFactReference[0];
      }
      component.FeatureFromSelection = featureFromSelection ?? component.FeatureFromSelection;
      component.m_Selection = selection?.Reference ?? component.m_Selection;
      if (component.m_Selection is null)
      {
        component.m_Selection = BlueprintTool.GetRef<BlueprintFeatureSelectionReference>(null);
      }
      return AddComponent(component);
    }

    /// <summary>
    /// Adds <see cref="AddFactsToMount"/>
    /// </summary>
    ///
    /// <remarks>
    ///
    /// <list type="bullet">
    /// <listheader>Used by</listheader>
    /// <item><term>ArcaneAccuracyMountBuff</term><description>aa7883d0df2b4467874f9a149ed7939e</description></item>
    /// <item><term>ArcaneWeaponSpeedMountBuff</term><description>c7ebf443f3504f71a1fe736b1ad64489</description></item>
    /// <item><term>TrampleBuff</term><description>f85bd259a0d8a8648854ed7c33ba4ca2</description></item>
    /// </list>
    /// </remarks>
    ///
    /// <param name="facts">
    /// <para>
    /// Blueprint of type BlueprintUnitFact. You can pass in the blueprint using:
    /// <list type ="bullet">
    ///   <item><term>A blueprint instance</term></item>
    ///   <item><term>A blueprint reference</term></item>
    ///   <item><term>A blueprint id as a string, Guid, or BlueprintGuid</term></item>
    ///   <item><term>A blueprint name registered with <see cref="BlueprintCore.Utils.BlueprintTool">BlueprintTool</see></term></item>
    /// </list>
    /// See <see cref="BlueprintCore.Utils.Blueprint{{T, TRef}}">Blueprint</see> for more details.
    /// </para>
    /// </param>
    public TBuilder AddFactsToMount(
        int? casterLevel = null,
        List<Blueprint<BlueprintUnitFact, BlueprintUnitFactReference>>? facts = null)
    {
      var component = new AddFactsToMount();
      component.CasterLevel = casterLevel ?? component.CasterLevel;
      component.m_Facts = facts?.Select(bp => bp.Reference)?.ToArray() ?? component.m_Facts;
      if (component.m_Facts is null)
      {
        component.m_Facts = new BlueprintUnitFactReference[0];
      }
      return AddComponent(component);
    }

    /// <summary>
    /// Adds <see cref="AddFallProneTrigger"/>
    /// </summary>
    ///
    /// <remarks>
    ///
    /// <list type="bullet">
    /// <listheader>Used by</listheader>
    /// <item><term>ObsidianFlowDifficultTerrainBuff</term><description>6e2eeb312ec681d4b9d089e53399a168</description></item>
    /// </list>
    /// </remarks>
    public TBuilder AddFallProneTrigger(
        ActionsBuilder? action = null)
    {
      var component = new AddFallProneTrigger();
      component.Action = action?.Build() ?? component.Action;
      if (component.Action is null)
      {
        component.Action = Utils.Constants.Empty.Actions;
      }
      return AddComponent(component);
    }

    /// <summary>
    /// Adds <see cref="AddFamiliar"/>
    /// </summary>
    ///
    /// <remarks>
    ///
    /// <list type="bullet">
    /// <listheader>Used by</listheader>
    /// <item><term>AzataITierVisualBuff</term><description>86a359319267535438dfd93ae3adba6d</description></item>
    /// <item><term>ImperialDragon_Buff</term><description>a534ec8a643e46be903b617a6f032129</description></item>
    /// <item><term>ViperFamiliarBuff</term><description>db64dcb29cbaf3049b2df85e4ba66385</description></item>
    /// </list>
    /// </remarks>
    public TBuilder AddFamiliar(
        bool? hideInCapital = null,
        FamiliarLink? prefabLink = null)
    {
      var component = new AddFamiliar();
      component.HideInCapital = hideInCapital ?? component.HideInCapital;
      Validate(prefabLink);
      component.PrefabLink = prefabLink ?? component.PrefabLink;
      return AddComponent(component);
    }

    /// <summary>
    /// Adds <see cref="AddFortification"/>
    /// </summary>
    ///
    /// <remarks>
    ///
    /// <list type="bullet">
    /// <listheader>Used by</listheader>
    /// <item><term>AdaptivePhysiologyFeature</term><description>cec88d5f7ebda294c93b95cd7360f504</description></item>
    /// <item><term>GreyGarrison_SuperMythicBuff</term><description>4b11247a4988c254fb9d1cd67f0b1e4a</description></item>
    /// <item><term>StoneBodyFeature</term><description>b0b503a803a94f97bd54a9abfd3b8e34</description></item>
    /// </list>
    /// </remarks>
    public TBuilder AddFortification(
        int? bonus = null,
        bool? useContextValue = null,
        ContextValue? value = null)
    {
      var component = new AddFortification();
      component.Bonus = bonus ?? component.Bonus;
      component.UseContextValue = useContextValue ?? component.UseContextValue;
      component.Value = value ?? component.Value;
      if (component.Value is null)
      {
        component.Value = ContextValues.Constant(0);
      }
      return AddComponent(component);
    }

    /// <summary>
    /// Adds <see cref="AddFortificationObsolete"/>
    /// </summary>
    ///
    /// <remarks>
    ///
    /// <list type="bullet">
    /// <listheader>Used by</listheader>
    /// <item><term>TalwynsArmorFeature</term><description>e5c7cbf08a7000e40b8036081d296b74</description></item>
    /// </list>
    /// </remarks>
    public TBuilder AddFortificationObsolete(
        int? chance = null)
    {
      var component = new AddFortificationObsolete();
      component.Chance = chance ?? component.Chance;
      return AddComponent(component);
    }

    /// <summary>
    /// Adds <see cref="AddHealTrigger"/>
    /// </summary>
    ///
    /// <remarks>
    ///
    /// <list type="bullet">
    /// <listheader>Used by</listheader>
    /// <item><term>Bleed1d4Buff</term><description>5eb68bfe186d71a438d4f85579ce40c1</description></item>
    /// <item><term>DeathThroesBuff</term><description>167e29bb47236e341abf7f6df1349d91</description></item>
    /// <item><term>WoundingBattleaxeBleedBuff</term><description>b6452a2ac912260409a18aa8e69e60f7</description></item>
    /// </list>
    /// </remarks>
    ///
    /// <param name="allowZeroHealDamage">
    /// <para>
    /// InfoBox: For example: If unit is Full HP already
    /// </para>
    /// </param>
    public TBuilder AddHealTrigger(
        ActionsBuilder? action = null,
        bool? allowZeroHealDamage = null,
        bool? allowZeroHealEnergyDrain = null,
        bool? allowZeroHealStatDamage = null,
        ActionsBuilder? healerAction = null,
        bool? onHealDamage = null,
        bool? onHealEnergyDrain = null,
        bool? onHealStatDamage = null)
    {
      var component = new AddHealTrigger();
      component.Action = action?.Build() ?? component.Action;
      if (component.Action is null)
      {
        component.Action = Utils.Constants.Empty.Actions;
      }
      component.AllowZeroHealDamage = allowZeroHealDamage ?? component.AllowZeroHealDamage;
      component.AllowZeroHealEnergyDrain = allowZeroHealEnergyDrain ?? component.AllowZeroHealEnergyDrain;
      component.AllowZeroHealStatDamage = allowZeroHealStatDamage ?? component.AllowZeroHealStatDamage;
      component.HealerAction = healerAction?.Build() ?? component.HealerAction;
      if (component.HealerAction is null)
      {
        component.HealerAction = Utils.Constants.Empty.Actions;
      }
      component.OnHealDamage = onHealDamage ?? component.OnHealDamage;
      component.OnHealEnergyDrain = onHealEnergyDrain ?? component.OnHealEnergyDrain;
      component.OnHealStatDamage = onHealStatDamage ?? component.OnHealStatDamage;
      return AddComponent(component);
    }

    /// <summary>
    /// Adds <see cref="AddIdentifyBonus"/>
    /// </summary>
    ///
    /// <remarks>
    ///
    /// <list type="bullet">
    /// <listheader>Used by</listheader>
    /// <item><term>IdentifyingGlassesFeature</term><description>e7992dc57b23cab4d98ae6e434d2d2c4</description></item>
    /// <item><term>LoremasterGreaterLore</term><description>d9961b36abaf72d48b154a07e631aac3</description></item>
    /// </list>
    /// </remarks>
    public TBuilder AddIdentifyBonus(
        bool? allowUsingUntrainedSkill = null,
        ContextValue? bonus = null,
        ContextValue? spellBonus = null)
    {
      var component = new AddIdentifyBonus();
      component.AllowUsingUntrainedSkill = allowUsingUntrainedSkill ?? component.AllowUsingUntrainedSkill;
      component.Bonus = bonus ?? component.Bonus;
      if (component.Bonus is null)
      {
        component.Bonus = ContextValues.Constant(0);
      }
      component.SpellBonus = spellBonus ?? component.SpellBonus;
      if (component.SpellBonus is null)
      {
        component.SpellBonus = ContextValues.Constant(0);
      }
      return AddComponent(component);
    }

    /// <summary>
    /// Adds <see cref="AddImmortality"/>
    /// </summary>
    ///
    /// <remarks>
    ///
    /// <para>
    /// ComponentName: Buffs/AddEffect/Immortality
    /// </para>
    ///
    /// <list type="bullet">
    /// <listheader>Used by</listheader>
    /// <item><term>AngelPhoenixGiftBuff</term><description>9988e25ec217c0249a28213e7dc0017c</description></item>
    /// <item><term>DenyDeathBuffParalyze</term><description>4ca5192ded94cc140b564e8f4fd32559</description></item>
    /// <item><term>NPC_Immortality</term><description>281a1f606d92728409ee5cbf5599855d</description></item>
    /// </list>
    /// </remarks>
    public TBuilder AddImmortality()
    {
      return AddComponent(new AddImmortality());
    }

    /// <summary>
    /// Adds <see cref="AddImmunityFirebrand"/>
    /// </summary>
    ///
    /// <remarks>
    ///
    /// <list type="bullet">
    /// <listheader>Used by</listheader>
    /// <item><term>FirebrandBuff</term><description>c6cc1c5356db4674dbd2be20ea205c86</description></item>
    /// </list>
    /// </remarks>
    public TBuilder AddImmunityFirebrand()
    {
      return AddComponent(new AddImmunityFirebrand());
    }

    /// <summary>
    /// Adds <see cref="AddImmunityToAbilityScoreDamage"/>
    /// </summary>
    ///
    /// <remarks>
    ///
    /// <list type="bullet">
    /// <listheader>Used by</listheader>
    /// <item><term>AngelWardFromHarmBuff</term><description>8801f41b253263249a3d3a46cdf3b276</description></item>
    /// <item><term>IronBodyBuff</term><description>2eabea6a1f9a58246a822f207e8ca79e</description></item>
    /// <item><term>WalkingDeadImmortalityBuff</term><description>9c55730e682cb574ab2fbc4727517752</description></item>
    /// </list>
    /// </remarks>
    public TBuilder AddImmunityToAbilityScoreDamage(
        bool? drain = null,
        StatType[]? statTypes = null)
    {
      var component = new AddImmunityToAbilityScoreDamage();
      component.Drain = drain ?? component.Drain;
      component.StatTypes = statTypes ?? component.StatTypes;
      if (component.StatTypes is null)
      {
        component.StatTypes = new StatType[0];
      }
      return AddComponent(component);
    }

    /// <summary>
    /// Adds <see cref="AddImmunityToCriticalHits"/>
    /// </summary>
    ///
    /// <remarks>
    ///
    /// <list type="bullet">
    /// <listheader>Used by</listheader>
    /// <item><term>Amorphous</term><description>2393af104c191b04ea33e47ebe4f0045</description></item>
    /// <item><term>ImmunityToCritical</term><description>ced0f4e5d02d5914a9f9ff74acacf26d</description></item>
    /// <item><term>WildShapeElementalWaterLargeBuff</term><description>5993b78c793667e45bf0380e9275fab7</description></item>
    /// </list>
    /// </remarks>
    public TBuilder AddImmunityToCriticalHits()
    {
      return AddComponent(new AddImmunityToCriticalHits());
    }

    /// <summary>
    /// Adds <see cref="AddImmunityToEnergyDrain"/>
    /// </summary>
    ///
    /// <remarks>
    ///
    /// <list type="bullet">
    /// <listheader>Used by</listheader>
    /// <item><term>AngelSwordAntiUndeadBuff</term><description>efadad11136c7bb418d060a1a231327d</description></item>
    /// <item><term>NPC_HealthGuard50</term><description>0908c83fa243917459a8d40357b588c2</description></item>
    /// <item><term>WalkingDeadImmortalityBuff</term><description>9c55730e682cb574ab2fbc4727517752</description></item>
    /// </list>
    /// </remarks>
    public TBuilder AddImmunityToEnergyDrain()
    {
      return AddComponent(new AddImmunityToEnergyDrain());
    }

    /// <summary>
    /// Adds <see cref="AddImmunityToPrecisionDamage"/>
    /// </summary>
    ///
    /// <remarks>
    ///
    /// <list type="bullet">
    /// <listheader>Used by</listheader>
    /// <item><term>Amorphous</term><description>2393af104c191b04ea33e47ebe4f0045</description></item>
    /// <item><term>Mephisto_Feature_AshenEssence</term><description>2c22e20bd7ec441db9a452f479bacd21</description></item>
    /// <item><term>WildShapeElementalWaterLargeBuff</term><description>5993b78c793667e45bf0380e9275fab7</description></item>
    /// </list>
    /// </remarks>
    public TBuilder AddImmunityToPrecisionDamage()
    {
      return AddComponent(new AddImmunityToPrecisionDamage());
    }

    /// <summary>
    /// Adds <see cref="AddIncomingDamageWeaponProperty"/>
    /// </summary>
    ///
    /// <remarks>
    ///
    /// <list type="bullet">
    /// <listheader>Used by</listheader>
    /// <item><term>AuraOfFaithEffectBuff</term><description>f84a39e55230f5e499588c5cd19548cd</description></item>
    /// </list>
    /// </remarks>
    ///
    /// <param name="merge">
    /// If mergeBehavior is ComponentMerge.Merge and the component already exists, this expression is called to merge the components.
    /// </param>
    /// <param name="mergeBehavior">
    /// Handling if the component already exists since the component is unique. Defaults to ComponentMerge.Fail.
    /// </param>
    /// <param name="weaponType">
    /// <para>
    /// Blueprint of type BlueprintWeaponType. You can pass in the blueprint using:
    /// <list type ="bullet">
    ///   <item><term>A blueprint instance</term></item>
    ///   <item><term>A blueprint reference</term></item>
    ///   <item><term>A blueprint id as a string, Guid, or BlueprintGuid</term></item>
    ///   <item><term>A blueprint name registered with <see cref="BlueprintCore.Utils.BlueprintTool">BlueprintTool</see></term></item>
    /// </list>
    /// See <see cref="BlueprintCore.Utils.Blueprint{{T, TRef}}">Blueprint</see> for more details.
    /// </para>
    /// </param>
    public TBuilder AddIncomingDamageWeaponProperty(
        bool? addAlignment = null,
        bool? addForm = null,
        bool? addMagic = null,
        bool? addMaterial = null,
        bool? addReality = null,
        DamageAlignment? alignment = null,
        bool? checkRange = null,
        bool? checkWeaponType = null,
        PhysicalDamageForm? form = null,
        bool? isRanged = null,
        PhysicalDamageMaterial? material = null,
        Action<BlueprintComponent, BlueprintComponent>? merge = null,
        ComponentMerge mergeBehavior = ComponentMerge.Merge,
        DamageRealityType? reality = null,
        Blueprint<BlueprintWeaponType, BlueprintWeaponTypeReference>? weaponType = null)
    {
      var component = new AddIncomingDamageWeaponProperty();
      component.AddAlignment = addAlignment ?? component.AddAlignment;
      component.AddForm = addForm ?? component.AddForm;
      component.AddMagic = addMagic ?? component.AddMagic;
      component.AddMaterial = addMaterial ?? component.AddMaterial;
      component.AddReality = addReality ?? component.AddReality;
      component.Alignment = alignment ?? component.Alignment;
      component.CheckRange = checkRange ?? component.CheckRange;
      component.CheckWeaponType = checkWeaponType ?? component.CheckWeaponType;
      component.Form = form ?? component.Form;
      component.IsRanged = isRanged ?? component.IsRanged;
      component.Material = material ?? component.Material;
      component.Reality = reality ?? component.Reality;
      component.m_WeaponType = weaponType?.Reference ?? component.m_WeaponType;
      if (component.m_WeaponType is null)
      {
        component.m_WeaponType = BlueprintTool.GetRef<BlueprintWeaponTypeReference>(null);
      }
      return AddUniqueComponent(component, mergeBehavior, merge);
    }

    /// <summary>
    /// Adds <see cref="AddIncorporealDamageDivisor"/>
    /// </summary>
    ///
    /// <remarks>
    ///
    /// <list type="bullet">
    /// <listheader>Used by</listheader>
    /// <item><term>Incorporeal</term><description>c4a7f98d743bc784c9d4cf2105852c39</description></item>
    /// </list>
    /// </remarks>
    public TBuilder AddIncorporealDamageDivisor()
    {
      return AddComponent(new AddIncorporealDamageDivisor());
    }

    /// <summary>
    /// Adds <see cref="AddInitiatorHealTrigger"/>
    /// </summary>
    ///
    /// <remarks>
    ///
    /// <list type="bullet">
    /// <listheader>Used by</listheader>
    /// <item><term>MythicPowersFromDLC1EffectBuff</term><description>08eba577806847ac9a814694013f7783</description></item>
    /// <item><term>TricksterSneakyQuack</term><description>bf41d492ff138ae4e9775e6fd9c8011e</description></item>
    /// </list>
    /// </remarks>
    public TBuilder AddInitiatorHealTrigger(
        ActionsBuilder? action = null,
        ActionsBuilder? healerAction = null,
        bool? onHealDamage = null,
        bool? onHealEnergyDrain = null,
        bool? onHealStatDamage = null)
    {
      var component = new AddInitiatorHealTrigger();
      component.Action = action?.Build() ?? component.Action;
      if (component.Action is null)
      {
        component.Action = Utils.Constants.Empty.Actions;
      }
      component.HealerAction = healerAction?.Build() ?? component.HealerAction;
      if (component.HealerAction is null)
      {
        component.HealerAction = Utils.Constants.Empty.Actions;
      }
      component.OnHealDamage = onHealDamage ?? component.OnHealDamage;
      component.OnHealEnergyDrain = onHealEnergyDrain ?? component.OnHealEnergyDrain;
      component.OnHealStatDamage = onHealStatDamage ?? component.OnHealStatDamage;
      return AddComponent(component);
    }

    /// <summary>
    /// Adds <see cref="AddItemCasterLevelBonus"/>
    /// </summary>
    ///
    /// <remarks>
    ///
    /// <list type="bullet">
    /// <listheader>Used by</listheader>
    /// <item><term>LibrariansCloakFeature</term><description>29c3befb0c416f44083ac0a68f041e70</description></item>
    /// <item><term>Mephisto_Feature_AshenEssence</term><description>2c22e20bd7ec441db9a452f479bacd21</description></item>
    /// <item><term>SpecialistBeltFeature</term><description>339b18ee515238c44a85f5d8ca556d73</description></item>
    /// </list>
    /// </remarks>
    ///
    /// <param name="merge">
    /// If mergeBehavior is ComponentMerge.Merge and the component already exists, this expression is called to merge the components.
    /// </param>
    /// <param name="mergeBehavior">
    /// Handling if the component already exists since the component is unique. Defaults to ComponentMerge.Fail.
    /// </param>
    public TBuilder AddItemCasterLevelBonus(
        int? bonus = null,
        UsableItemType? itemType = null,
        Action<BlueprintComponent, BlueprintComponent>? merge = null,
        ComponentMerge mergeBehavior = ComponentMerge.Merge)
    {
      var component = new AddItemCasterLevelBonus();
      component.Bonus = bonus ?? component.Bonus;
      component.ItemType = itemType ?? component.ItemType;
      return AddUniqueComponent(component, mergeBehavior, merge);
    }

    /// <summary>
    /// Adds <see cref="AddKnownSpell"/>
    /// </summary>
    ///
    /// <remarks>
    ///
    /// <list type="bullet">
    /// <listheader>Used by</listheader>
    /// <item><term>BeastTamerBonusSpells</term><description>e5ca84b6bd3548e4796a73500a23773d</description></item>
    /// <item><term>EnlightenedPhilosopherLifeSpells</term><description>6ea903d2711be5f44864fc523ee4ef82</description></item>
    /// <item><term>WolfScarredFaceCurseFeatureLevel5</term><description>43c1305f3e4596f46b8d2ed782693ef7</description></item>
    /// </list>
    /// </remarks>
    ///
    /// <param name="archetype">
    /// <para>
    /// Blueprint of type BlueprintArchetype. You can pass in the blueprint using:
    /// <list type ="bullet">
    ///   <item><term>A blueprint instance</term></item>
    ///   <item><term>A blueprint reference</term></item>
    ///   <item><term>A blueprint id as a string, Guid, or BlueprintGuid</term></item>
    ///   <item><term>A blueprint name registered with <see cref="BlueprintCore.Utils.BlueprintTool">BlueprintTool</see></term></item>
    /// </list>
    /// See <see cref="BlueprintCore.Utils.Blueprint{{T, TRef}}">Blueprint</see> for more details.
    /// </para>
    /// </param>
    /// <param name="characterClass">
    /// <para>
    /// Blueprint of type BlueprintCharacterClass. You can pass in the blueprint using:
    /// <list type ="bullet">
    ///   <item><term>A blueprint instance</term></item>
    ///   <item><term>A blueprint reference</term></item>
    ///   <item><term>A blueprint id as a string, Guid, or BlueprintGuid</term></item>
    ///   <item><term>A blueprint name registered with <see cref="BlueprintCore.Utils.BlueprintTool">BlueprintTool</see></term></item>
    /// </list>
    /// See <see cref="BlueprintCore.Utils.Blueprint{{T, TRef}}">Blueprint</see> for more details.
    /// </para>
    /// </param>
    /// <param name="merge">
    /// If mergeBehavior is ComponentMerge.Merge and the component already exists, this expression is called to merge the components.
    /// </param>
    /// <param name="mergeBehavior">
    /// Handling if the component already exists since the component is unique. Defaults to ComponentMerge.Fail.
    /// </param>
    /// <param name="spell">
    /// <para>
    /// Blueprint of type BlueprintAbility. You can pass in the blueprint using:
    /// <list type ="bullet">
    ///   <item><term>A blueprint instance</term></item>
    ///   <item><term>A blueprint reference</term></item>
    ///   <item><term>A blueprint id as a string, Guid, or BlueprintGuid</term></item>
    ///   <item><term>A blueprint name registered with <see cref="BlueprintCore.Utils.BlueprintTool">BlueprintTool</see></term></item>
    /// </list>
    /// See <see cref="BlueprintCore.Utils.Blueprint{{T, TRef}}">Blueprint</see> for more details.
    /// </para>
    /// </param>
    public TBuilder AddKnownSpell(
        Blueprint<BlueprintArchetype, BlueprintArchetypeReference>? archetype = null,
        Blueprint<BlueprintCharacterClass, BlueprintCharacterClassReference>? characterClass = null,
        Action<BlueprintComponent, BlueprintComponent>? merge = null,
        ComponentMerge mergeBehavior = ComponentMerge.Merge,
        Blueprint<BlueprintAbility, BlueprintAbilityReference>? spell = null,
        int? spellLevel = null)
    {
      var component = new AddKnownSpell();
      component.m_Archetype = archetype?.Reference ?? component.m_Archetype;
      if (component.m_Archetype is null)
      {
        component.m_Archetype = BlueprintTool.GetRef<BlueprintArchetypeReference>(null);
      }
      component.m_CharacterClass = characterClass?.Reference ?? component.m_CharacterClass;
      if (component.m_CharacterClass is null)
      {
        component.m_CharacterClass = BlueprintTool.GetRef<BlueprintCharacterClassReference>(null);
      }
      component.m_Spell = spell?.Reference ?? component.m_Spell;
      if (component.m_Spell is null)
      {
        component.m_Spell = BlueprintTool.GetRef<BlueprintAbilityReference>(null);
      }
      component.SpellLevel = spellLevel ?? component.SpellLevel;
      return AddUniqueComponent(component, mergeBehavior, merge);
    }

    /// <summary>
    /// Adds <see cref="AddLocalMapMarker"/>
    /// </summary>
    ///
    /// <remarks>
    ///
    /// <list type="bullet">
    /// <listheader>Used by</listheader>
    /// <item><term>Chief_Sull_LannQ1</term><description>6929f1ee076685a4084e01a0c29c82b6</description></item>
    /// <item><term>LocalMapMarker_VIT_ShowAlways</term><description>fbbe330f105d1384db6602127925c939</description></item>
    /// <item><term>RamienCapital</term><description>fa415b5b75d813e45a9f0304874852ec</description></item>
    /// </list>
    /// </remarks>
    public TBuilder AddLocalMapMarker(
        bool? showIfNotRevealed = null,
        LocalMapMarkType? type = null)
    {
      var component = new AddLocalMapMarker();
      component.ShowIfNotRevealed = showIfNotRevealed ?? component.ShowIfNotRevealed;
      component.Type = type ?? component.Type;
      return AddComponent(component);
    }

    /// <summary>
    /// Adds <see cref="AddMechanicsFeature"/>
    /// </summary>
    ///
    /// <remarks>
    ///
    /// <list type="bullet">
    /// <listheader>Used by</listheader>
    /// <item><term>AcrobatsFootwearFeature</term><description>bb115b9d89d7b4b48814d059ecd29164</description></item>
    /// <item><term>FormOfTheDragonISilverBuff</term><description>feb2ab7613e563e45bcf9f7ffe4e05c6</description></item>
    /// <item><term>XantirWithoutSwarm_MidnightFaneInThePast</term><description>a44bf782e3a95194493874cf122c4f99</description></item>
    /// </list>
    /// </remarks>
    ///
    /// <param name="merge">
    /// If mergeBehavior is ComponentMerge.Merge and the component already exists, this expression is called to merge the components.
    /// </param>
    /// <param name="mergeBehavior">
    /// Handling if the component already exists since the component is unique. Defaults to ComponentMerge.Fail.
    /// </param>
    public TBuilder AddMechanicsFeature(
        AddMechanicsFeature.MechanicsFeatureType? feature = null,
        Action<BlueprintComponent, BlueprintComponent>? merge = null,
        ComponentMerge mergeBehavior = ComponentMerge.Merge)
    {
      var component = new AddMechanicsFeature();
      component.m_Feature = feature ?? component.m_Feature;
      return AddUniqueComponent(component, mergeBehavior, merge);
    }

    /// <summary>
    /// Adds <see cref="AddMetamagicFeat"/>
    /// </summary>
    ///
    /// <remarks>
    ///
    /// <list type="bullet">
    /// <listheader>Used by</listheader>
    /// <item><term>AlushinyrraCasterMiniboss_Features_Stage1</term><description>167558e0daed473aa55f0f30558787e8</description></item>
    /// <item><term>Keketar_Feature_Metamagic</term><description>443c0a37fe7e46e78537c285c52ceaea</description></item>
    /// <item><term>Zanedra_Metamagic</term><description>ad77aded6888c69458669e5ecd2fa979</description></item>
    /// </list>
    /// </remarks>
    public TBuilder AddMetamagicFeat(
        Metamagic? metamagic = null)
    {
      var component = new AddMetamagicFeat();
      component.Metamagic = metamagic ?? component.Metamagic;
      return AddComponent(component);
    }

    /// <summary>
    /// Adds <see cref="AddMythicEnemyHitPointsBonus"/>
    /// </summary>
    ///
    /// <remarks>
    ///
    /// <list type="bullet">
    /// <listheader>Used by</listheader>
    /// <item><term>MonsterMythicFeature1Buff</term><description>f28037f6dd9ac2d45b538011133cdc9c</description></item>
    /// </list>
    /// </remarks>
    public TBuilder AddMythicEnemyHitPointsBonus()
    {
      return AddComponent(new AddMythicEnemyHitPointsBonus());
    }

    /// <summary>
    /// Adds <see cref="AddNimbusDamageDivisor"/>
    /// </summary>
    ///
    /// <remarks>
    ///
    /// <list type="bullet">
    /// <listheader>Used by</listheader>
    /// <item><term>ProfaneNimbusBuff</term><description>bb08ad05d0b4505488775090954c2317</description></item>
    /// <item><term>SacredNimbusBuff</term><description>57b1c6a69c53f4d4ea9baec7d0a3a93a</description></item>
    /// </list>
    /// </remarks>
    public TBuilder AddNimbusDamageDivisor(
        AddNimbusDamageDivisor.NimbusType? type = null)
    {
      var component = new AddNimbusDamageDivisor();
      component.m_Type = type ?? component.m_Type;
      return AddComponent(component);
    }

    /// <summary>
    /// Adds <see cref="AddOffensiveActionTrigger"/>
    /// </summary>
    ///
    /// <remarks>
    ///
    /// <list type="bullet">
    /// <listheader>Used by</listheader>
    /// <item><term>JoltingPortentBuff</term><description>27fa15e9738aee1499aed308cdef7084</description></item>
    /// </list>
    /// </remarks>
    public TBuilder AddOffensiveActionTrigger(
        ActionsBuilder? action = null)
    {
      var component = new AddOffensiveActionTrigger();
      component.Action = action?.Build() ?? component.Action;
      if (component.Action is null)
      {
        component.Action = Utils.Constants.Empty.Actions;
      }
      return AddComponent(component);
    }

    /// <summary>
    /// Adds <see cref="AddOppositionSchool"/>
    /// </summary>
    ///
    /// <remarks>
    ///
    /// <list type="bullet">
    /// <listheader>Used by</listheader>
    /// <item><term>OppositionSchoolAbjuration</term><description>7f8c1b838ff2d2e4f971b42ccdfa0bfd</description></item>
    /// <item><term>OppositionSchoolEvocation</term><description>c3724cfbe98875f4a9f6d1aabd4011a6</description></item>
    /// <item><term>OppositionSchoolTransmutation</term><description>fc519612a3c604446888bb345bca5234</description></item>
    /// </list>
    /// </remarks>
    ///
    /// <param name="characterClass">
    /// <para>
    /// Blueprint of type BlueprintCharacterClass. You can pass in the blueprint using:
    /// <list type ="bullet">
    ///   <item><term>A blueprint instance</term></item>
    ///   <item><term>A blueprint reference</term></item>
    ///   <item><term>A blueprint id as a string, Guid, or BlueprintGuid</term></item>
    ///   <item><term>A blueprint name registered with <see cref="BlueprintCore.Utils.BlueprintTool">BlueprintTool</see></term></item>
    /// </list>
    /// See <see cref="BlueprintCore.Utils.Blueprint{{T, TRef}}">Blueprint</see> for more details.
    /// </para>
    /// </param>
    public TBuilder AddOppositionSchool(
        Blueprint<BlueprintCharacterClass, BlueprintCharacterClassReference>? characterClass = null,
        SpellSchool? school = null)
    {
      var component = new AddOppositionSchool();
      component.m_CharacterClass = characterClass?.Reference ?? component.m_CharacterClass;
      if (component.m_CharacterClass is null)
      {
        component.m_CharacterClass = BlueprintTool.GetRef<BlueprintCharacterClassReference>(null);
      }
      component.School = school ?? component.School;
      return AddComponent(component);
    }

    /// <summary>
    /// Adds <see cref="AddOutgoingDamageBonus"/>
    /// </summary>
    ///
    /// <remarks>
    ///
    /// <list type="bullet">
    /// <listheader>Used by</listheader>
    /// <item><term>AngelSwordAntiCompulsionBuff</term><description>5d679978972e8d644a2204ac8aaeba05</description></item>
    /// <item><term>AngelSwordAntiUndeadBuff</term><description>efadad11136c7bb418d060a1a231327d</description></item>
    /// <item><term>MythicPowersFromDLC1EffectBuff</term><description>08eba577806847ac9a814694013f7783</description></item>
    /// </list>
    /// </remarks>
    ///
    /// <param name="checkedFact">
    /// <para>
    /// Blueprint of type BlueprintUnitFact. You can pass in the blueprint using:
    /// <list type ="bullet">
    ///   <item><term>A blueprint instance</term></item>
    ///   <item><term>A blueprint reference</term></item>
    ///   <item><term>A blueprint id as a string, Guid, or BlueprintGuid</term></item>
    ///   <item><term>A blueprint name registered with <see cref="BlueprintCore.Utils.BlueprintTool">BlueprintTool</see></term></item>
    /// </list>
    /// See <see cref="BlueprintCore.Utils.Blueprint{{T, TRef}}">Blueprint</see> for more details.
    /// </para>
    /// </param>
    public TBuilder AddOutgoingDamageBonus(
        SpellDescriptorWrapper? checkedDescriptor = null,
        Blueprint<BlueprintUnitFact, BlueprintUnitFactReference>? checkedFact = null,
        DamageIncreaseCondition? condition = null,
        DamageTypeDescription? damageType = null,
        float? originalDamageFactor = null,
        DamageIncreaseReason? reason = null)
    {
      var component = new AddOutgoingDamageBonus();
      component.CheckedDescriptor = checkedDescriptor ?? component.CheckedDescriptor;
      component.m_CheckedFact = checkedFact?.Reference ?? component.m_CheckedFact;
      if (component.m_CheckedFact is null)
      {
        component.m_CheckedFact = BlueprintTool.GetRef<BlueprintUnitFactReference>(null);
      }
      component.Condition = condition ?? component.Condition;
      Validate(damageType);
      component.DamageType = damageType ?? component.DamageType;
      component.OriginalDamageFactor = originalDamageFactor ?? component.OriginalDamageFactor;
      component.Reason = reason ?? component.Reason;
      return AddComponent(component);
    }

    /// <summary>
    /// Adds <see cref="AddOutgoingPhysicalDamageProperty"/>
    /// </summary>
    ///
    /// <remarks>
    ///
    /// <list type="bullet">
    /// <listheader>Used by</listheader>
    /// <item><term>AngelicAspectBuff</term><description>b33f44fecadb3ca48b438dacac6454c2</description></item>
    /// <item><term>BloodlineSerpentineSerpentsFangBuffLevel4Int</term><description>4401f082a1737624e888ec674b9c538d</description></item>
    /// <item><term>WreckerDR</term><description>589aa3d4131727b43aa57bc96003bb06</description></item>
    /// </list>
    /// </remarks>
    ///
    /// <param name="merge">
    /// If mergeBehavior is ComponentMerge.Merge and the component already exists, this expression is called to merge the components.
    /// </param>
    /// <param name="mergeBehavior">
    /// Handling if the component already exists since the component is unique. Defaults to ComponentMerge.Fail.
    /// </param>
    /// <param name="unitFact">
    /// <para>
    /// Blueprint of type BlueprintUnitFact. You can pass in the blueprint using:
    /// <list type ="bullet">
    ///   <item><term>A blueprint instance</term></item>
    ///   <item><term>A blueprint reference</term></item>
    ///   <item><term>A blueprint id as a string, Guid, or BlueprintGuid</term></item>
    ///   <item><term>A blueprint name registered with <see cref="BlueprintCore.Utils.BlueprintTool">BlueprintTool</see></term></item>
    /// </list>
    /// See <see cref="BlueprintCore.Utils.Blueprint{{T, TRef}}">Blueprint</see> for more details.
    /// </para>
    /// </param>
    /// <param name="weaponType">
    /// <para>
    /// Blueprint of type BlueprintWeaponType. You can pass in the blueprint using:
    /// <list type ="bullet">
    ///   <item><term>A blueprint instance</term></item>
    ///   <item><term>A blueprint reference</term></item>
    ///   <item><term>A blueprint id as a string, Guid, or BlueprintGuid</term></item>
    ///   <item><term>A blueprint name registered with <see cref="BlueprintCore.Utils.BlueprintTool">BlueprintTool</see></term></item>
    /// </list>
    /// See <see cref="BlueprintCore.Utils.Blueprint{{T, TRef}}">Blueprint</see> for more details.
    /// </para>
    /// </param>
    public TBuilder AddOutgoingPhysicalDamageProperty(
        bool? addAlignment = null,
        bool? addForm = null,
        bool? addMagic = null,
        bool? addMaterial = null,
        bool? addReality = null,
        bool? affectAnyPhysicalDamage = null,
        bool? againstFactOwner = null,
        DamageAlignment? alignment = null,
        bool? checkRange = null,
        bool? checkWeaponType = null,
        PhysicalDamageForm? form = null,
        bool? isRanged = null,
        PhysicalDamageMaterial? material = null,
        Action<BlueprintComponent, BlueprintComponent>? merge = null,
        ComponentMerge mergeBehavior = ComponentMerge.Merge,
        bool? myAlignment = null,
        bool? naturalAttacks = null,
        DamageRealityType? reality = null,
        Blueprint<BlueprintUnitFact, BlueprintUnitFactReference>? unitFact = null,
        Blueprint<BlueprintWeaponType, BlueprintWeaponTypeReference>? weaponType = null)
    {
      var component = new AddOutgoingPhysicalDamageProperty();
      component.AddAlignment = addAlignment ?? component.AddAlignment;
      component.AddForm = addForm ?? component.AddForm;
      component.AddMagic = addMagic ?? component.AddMagic;
      component.AddMaterial = addMaterial ?? component.AddMaterial;
      component.AddReality = addReality ?? component.AddReality;
      component.AffectAnyPhysicalDamage = affectAnyPhysicalDamage ?? component.AffectAnyPhysicalDamage;
      component.AgainstFactOwner = againstFactOwner ?? component.AgainstFactOwner;
      component.Alignment = alignment ?? component.Alignment;
      component.CheckRange = checkRange ?? component.CheckRange;
      component.CheckWeaponType = checkWeaponType ?? component.CheckWeaponType;
      component.Form = form ?? component.Form;
      component.IsRanged = isRanged ?? component.IsRanged;
      component.Material = material ?? component.Material;
      component.MyAlignment = myAlignment ?? component.MyAlignment;
      component.NaturalAttacks = naturalAttacks ?? component.NaturalAttacks;
      component.Reality = reality ?? component.Reality;
      component.m_UnitFact = unitFact?.Reference ?? component.m_UnitFact;
      if (component.m_UnitFact is null)
      {
        component.m_UnitFact = BlueprintTool.GetRef<BlueprintUnitFactReference>(null);
      }
      component.m_WeaponType = weaponType?.Reference ?? component.m_WeaponType;
      if (component.m_WeaponType is null)
      {
        component.m_WeaponType = BlueprintTool.GetRef<BlueprintWeaponTypeReference>(null);
      }
      return AddUniqueComponent(component, mergeBehavior, merge);
    }

    /// <summary>
    /// Adds <see cref="AddOverHealTrigger"/>
    /// </summary>
    ///
    /// <remarks>
    ///
    /// <list type="bullet">
    /// <listheader>Used by</listheader>
    /// <item><term>OracleRevelationSpiritBoost</term><description>8cf1bc6fe4d14304392496ff66023271</description></item>
    /// </list>
    /// </remarks>
    ///
    /// <param name="sharedValue">
    /// <para>
    /// InfoBox: Shared value to store excess healed points
    /// </para>
    /// </param>
    public TBuilder AddOverHealTrigger(
        ActionsBuilder? actionOnTarget = null,
        bool? limitMaximum = null,
        ContextValue? maxValue = null,
        AbilitySharedValue? sharedValue = null)
    {
      var component = new AddOverHealTrigger();
      component.ActionOnTarget = actionOnTarget?.Build() ?? component.ActionOnTarget;
      if (component.ActionOnTarget is null)
      {
        component.ActionOnTarget = Utils.Constants.Empty.Actions;
      }
      component.LimitMaximum = limitMaximum ?? component.LimitMaximum;
      component.MaxValue = maxValue ?? component.MaxValue;
      if (component.MaxValue is null)
      {
        component.MaxValue = ContextValues.Constant(0);
      }
      component.SharedValue = sharedValue ?? component.SharedValue;
      return AddComponent(component);
    }

    /// <summary>
    /// Adds <see cref="AddParametrizedFeatures"/>
    /// </summary>
    ///
    /// <remarks>
    ///
    /// <list type="bullet">
    /// <listheader>Used by</listheader>
    /// <item><term>DisenchanterSpellFocusAbjuration</term><description>60ed5ba87ac9e3241adc8212d3f6a24c</description></item>
    /// <item><term>ZenArcherWayOfTheBowLongbowSpecialization</term><description>0d696cb262584ee4b88ccc96a07d6821</description></item>
    /// <item><term>ZenArcherWayOfTheBowShortbowSpecialization</term><description>d93aee59c93b3a042873fb6fab2ad8d8</description></item>
    /// </list>
    /// </remarks>
    public TBuilder AddParametrizedFeatures(
        AddParametrizedFeatures.FeatureData[]? features = null)
    {
      var component = new AddParametrizedFeatures();
      foreach (var item in features) { Validate(item); }
      component.m_Features = features ?? component.m_Features;
      if (component.m_Features is null)
      {
        component.m_Features = new AddParametrizedFeatures.FeatureData[0];
      }
      return AddComponent(component);
    }

    /// <summary>
    /// Adds <see cref="AddPartyEncumbrance"/>
    /// </summary>
    ///
    /// <remarks>
    ///
    /// <list type="bullet">
    /// <listheader>Used by</listheader>
    /// <item><term>ProfessorHatFeature</term><description>9f3ac6817f7cadc47b7068e3cb0e89e0</description></item>
    /// </list>
    /// </remarks>
    ///
    /// <param name="merge">
    /// If mergeBehavior is ComponentMerge.Merge and the component already exists, this expression is called to merge the components.
    /// </param>
    /// <param name="mergeBehavior">
    /// Handling if the component already exists since the component is unique. Defaults to ComponentMerge.Fail.
    /// </param>
    public TBuilder AddPartyEncumbrance(
        Action<BlueprintComponent, BlueprintComponent>? merge = null,
        ComponentMerge mergeBehavior = ComponentMerge.Merge,
        int? value = null)
    {
      var component = new AddPartyEncumbrance();
      component.Value = value ?? component.Value;
      return AddUniqueComponent(component, mergeBehavior, merge);
    }

    /// <summary>
    /// Adds <see cref="AddPet"/>
    /// </summary>
    ///
    /// <remarks>
    ///
    /// <list type="bullet">
    /// <listheader>Used by</listheader>
    /// <item><term>AnimalCompanionFeatureArmoredPony_ForNPC</term><description>19de8e1467fe4d469d3b46ebbdc3ac35</description></item>
    /// <item><term>AnimalCompanionFeatureTriceratops</term><description>2d3f409bb0956d44187e9ec8340163f8</description></item>
    /// <item><term>TriceratopsStatuetteFeature</term><description>13551e0cd7e4091499f9064b3f32ad50</description></item>
    /// </list>
    /// </remarks>
    ///
    /// <param name="levelRank">
    /// <para>
    /// Blueprint of type BlueprintFeature. You can pass in the blueprint using:
    /// <list type ="bullet">
    ///   <item><term>A blueprint instance</term></item>
    ///   <item><term>A blueprint reference</term></item>
    ///   <item><term>A blueprint id as a string, Guid, or BlueprintGuid</term></item>
    ///   <item><term>A blueprint name registered with <see cref="BlueprintCore.Utils.BlueprintTool">BlueprintTool</see></term></item>
    /// </list>
    /// See <see cref="BlueprintCore.Utils.Blueprint{{T, TRef}}">Blueprint</see> for more details.
    /// </para>
    /// </param>
    /// <param name="pet">
    /// <para>
    /// Blueprint of type BlueprintUnit. You can pass in the blueprint using:
    /// <list type ="bullet">
    ///   <item><term>A blueprint instance</term></item>
    ///   <item><term>A blueprint reference</term></item>
    ///   <item><term>A blueprint id as a string, Guid, or BlueprintGuid</term></item>
    ///   <item><term>A blueprint name registered with <see cref="BlueprintCore.Utils.BlueprintTool">BlueprintTool</see></term></item>
    /// </list>
    /// See <see cref="BlueprintCore.Utils.Blueprint{{T, TRef}}">Blueprint</see> for more details.
    /// </para>
    /// </param>
    /// <param name="upgradeFeature">
    /// <para>
    /// Blueprint of type BlueprintFeature. You can pass in the blueprint using:
    /// <list type ="bullet">
    ///   <item><term>A blueprint instance</term></item>
    ///   <item><term>A blueprint reference</term></item>
    ///   <item><term>A blueprint id as a string, Guid, or BlueprintGuid</term></item>
    ///   <item><term>A blueprint name registered with <see cref="BlueprintCore.Utils.BlueprintTool">BlueprintTool</see></term></item>
    /// </list>
    /// See <see cref="BlueprintCore.Utils.Blueprint{{T, TRef}}">Blueprint</see> for more details.
    /// </para>
    /// </param>
    public TBuilder AddPet(
        bool? destroyPetOnDeactivate = null,
        bool? forceAutoLevelup = null,
        ContextValue? levelContextValue = null,
        Blueprint<BlueprintFeature, BlueprintFeatureReference>? levelRank = null,
        Blueprint<BlueprintUnit, BlueprintUnitReference>? pet = null,
        PetProgressionType? progressionType = null,
        PetType? type = null,
        Blueprint<BlueprintFeature, BlueprintFeatureReference>? upgradeFeature = null,
        int? upgradeLevel = null,
        bool? useContextValueLevel = null)
    {
      var component = new AddPet();
      component.m_DestroyPetOnDeactivate = destroyPetOnDeactivate ?? component.m_DestroyPetOnDeactivate;
      component.m_ForceAutoLevelup = forceAutoLevelup ?? component.m_ForceAutoLevelup;
      component.m_LevelContextValue = levelContextValue ?? component.m_LevelContextValue;
      if (component.m_LevelContextValue is null)
      {
        component.m_LevelContextValue = ContextValues.Constant(0);
      }
      component.m_LevelRank = levelRank?.Reference ?? component.m_LevelRank;
      if (component.m_LevelRank is null)
      {
        component.m_LevelRank = BlueprintTool.GetRef<BlueprintFeatureReference>(null);
      }
      component.m_Pet = pet?.Reference ?? component.m_Pet;
      if (component.m_Pet is null)
      {
        component.m_Pet = BlueprintTool.GetRef<BlueprintUnitReference>(null);
      }
      component.ProgressionType = progressionType ?? component.ProgressionType;
      component.Type = type ?? component.Type;
      component.m_UpgradeFeature = upgradeFeature?.Reference ?? component.m_UpgradeFeature;
      if (component.m_UpgradeFeature is null)
      {
        component.m_UpgradeFeature = BlueprintTool.GetRef<BlueprintFeatureReference>(null);
      }
      component.UpgradeLevel = upgradeLevel ?? component.UpgradeLevel;
      component.m_UseContextValueLevel = useContextValueLevel ?? component.m_UseContextValueLevel;
      return AddComponent(component);
    }

    /// <summary>
    /// Adds <see cref="AddPhysicalImmunity"/>
    /// </summary>
    ///
    /// <remarks>
    ///
    /// <para>
    /// ComponentName: Buffs/AddEffect/EnergyImmunity
    /// </para>
    ///
    /// <list type="bullet">
    /// <listheader>Used by</listheader>
    /// <item><term>EdictOfImpenetrableFortressBuff</term><description>dcd66cb6783e94e4385fc221d75e1f22</description></item>
    /// <item><term>ImmunityToSlashing</term><description>bbbcd4db300e426a8bc96ac82c86bdec</description></item>
    /// <item><term>SwarmFeastExtraBuff</term><description>77558f3e79847bb448aa980a1aee326e</description></item>
    /// </list>
    /// </remarks>
    ///
    /// <param name="merge">
    /// If mergeBehavior is ComponentMerge.Merge and the component already exists, this expression is called to merge the components.
    /// </param>
    /// <param name="mergeBehavior">
    /// Handling if the component already exists since the component is unique. Defaults to ComponentMerge.Fail.
    /// </param>
    public TBuilder AddPhysicalImmunity(
        Action<BlueprintComponent, BlueprintComponent>? merge = null,
        ComponentMerge mergeBehavior = ComponentMerge.Merge,
        PhysicalDamageForm? physicalDamageForms = null)
    {
      var component = new AddPhysicalImmunity();
      component.m_PhysicalDamageForms = physicalDamageForms ?? component.m_PhysicalDamageForms;
      return AddUniqueComponent(component, mergeBehavior, merge);
    }

    /// <summary>
    /// Adds <see cref="AddProficiencies"/>
    /// </summary>
    ///
    /// <remarks>
    ///
    /// <para>
    /// ComponentName: Add proficiencies
    /// </para>
    ///
    /// <list type="bullet">
    /// <listheader>Used by</listheader>
    /// <item><term>AlchemistProficiencies</term><description>a1a8971f48a829d4683097f8b14e41c8</description></item>
    /// <item><term>LightArmorProficiency</term><description>6d3728d4e9c9898458fe5e9532951132</description></item>
    /// <item><term>ZenArcherProficiency</term><description>512298bc5664c8d4190fd09269aa4014</description></item>
    /// </list>
    /// </remarks>
    ///
    /// <param name="merge">
    /// If mergeBehavior is ComponentMerge.Merge and the component already exists, this expression is called to merge the components.
    /// </param>
    /// <param name="mergeBehavior">
    /// Handling if the component already exists since the component is unique. Defaults to ComponentMerge.Fail.
    /// </param>
    /// <param name="raceRestriction">
    /// <para>
    /// Blueprint of type BlueprintRace. You can pass in the blueprint using:
    /// <list type ="bullet">
    ///   <item><term>A blueprint instance</term></item>
    ///   <item><term>A blueprint reference</term></item>
    ///   <item><term>A blueprint id as a string, Guid, or BlueprintGuid</term></item>
    ///   <item><term>A blueprint name registered with <see cref="BlueprintCore.Utils.BlueprintTool">BlueprintTool</see></term></item>
    /// </list>
    /// See <see cref="BlueprintCore.Utils.Blueprint{{T, TRef}}">Blueprint</see> for more details.
    /// </para>
    /// </param>
    public TBuilder AddProficiencies(
        ArmorProficiencyGroup[]? armorProficiencies = null,
        Action<BlueprintComponent, BlueprintComponent>? merge = null,
        ComponentMerge mergeBehavior = ComponentMerge.Merge,
        Blueprint<BlueprintRace, BlueprintRaceReference>? raceRestriction = null,
        WeaponCategory[]? weaponProficiencies = null)
    {
      var component = new AddProficiencies();
      component.ArmorProficiencies = armorProficiencies ?? component.ArmorProficiencies;
      if (component.ArmorProficiencies is null)
      {
        component.ArmorProficiencies = new ArmorProficiencyGroup[0];
      }
      component.m_RaceRestriction = raceRestriction?.Reference ?? component.m_RaceRestriction;
      if (component.m_RaceRestriction is null)
      {
        component.m_RaceRestriction = BlueprintTool.GetRef<BlueprintRaceReference>(null);
      }
      component.WeaponProficiencies = weaponProficiencies ?? component.WeaponProficiencies;
      if (component.WeaponProficiencies is null)
      {
        component.WeaponProficiencies = new WeaponCategory[0];
      }
      return AddUniqueComponent(component, mergeBehavior, merge);
    }

    /// <summary>
    /// Adds <see cref="AddREVendorItem"/>
    /// </summary>
    ///
    /// <remarks>
    ///
    /// <list type="bullet">
    /// <listheader>Used by</listheader>
    /// <item><term>SkeletonTrader</term><description>5da38a2cb9e5f424dbf650667b094c51</description></item>
    /// </list>
    /// </remarks>
    public TBuilder AddREVendorItem()
    {
      return AddComponent(new AddREVendorItem());
    }

    /// <summary>
    /// Adds <see cref="AddResurrectOnRest"/>
    /// </summary>
    ///
    /// <remarks>
    ///
    /// <list type="bullet">
    /// <listheader>Used by</listheader>
    /// <item><term>AnimalCompanionUnit</term><description>67c085077a5988445984e05d330c7798</description></item>
    /// <item><term>AnimalCompanionUnitMonitor</term><description>57381165c3f4b4740a872e54f62c3a14</description></item>
    /// <item><term>TriceratopsStatuetteUnit</term><description>cc9177cc8dccc1449be084e7784ff52d</description></item>
    /// </list>
    /// </remarks>
    public TBuilder AddResurrectOnRest()
    {
      return AddComponent(new AddResurrectOnRest());
    }

    /// <summary>
    /// Adds <see cref="AddSecondaryAttacks"/>
    /// </summary>
    ///
    /// <remarks>
    ///
    /// <para>
    /// ComponentName: Add secondary attacks
    /// </para>
    ///
    /// <list type="bullet">
    /// <listheader>Used by</listheader>
    /// <item><term>AnimalCompanionNotUpgradedHorse</term><description>2fd62963c50b47b419e2de6577cf001e</description></item>
    /// <item><term>AnimalFuryRageBuff</term><description>a67b51a8074ae47438280be0a87b01b6</description></item>
    /// <item><term>DemonicFirstAscensionBuff</term><description>1a5bf4d647f4ab742b2faf9cace526e9</description></item>
    /// </list>
    /// </remarks>
    ///
    /// <param name="merge">
    /// If mergeBehavior is ComponentMerge.Merge and the component already exists, this expression is called to merge the components.
    /// </param>
    /// <param name="mergeBehavior">
    /// Handling if the component already exists since the component is unique. Defaults to ComponentMerge.Fail.
    /// </param>
    /// <param name="weapon">
    /// <para>
    /// Blueprint of type BlueprintItemWeapon. You can pass in the blueprint using:
    /// <list type ="bullet">
    ///   <item><term>A blueprint instance</term></item>
    ///   <item><term>A blueprint reference</term></item>
    ///   <item><term>A blueprint id as a string, Guid, or BlueprintGuid</term></item>
    ///   <item><term>A blueprint name registered with <see cref="BlueprintCore.Utils.BlueprintTool">BlueprintTool</see></term></item>
    /// </list>
    /// See <see cref="BlueprintCore.Utils.Blueprint{{T, TRef}}">Blueprint</see> for more details.
    /// </para>
    /// </param>
    public TBuilder AddSecondaryAttacks(
        Action<BlueprintComponent, BlueprintComponent>? merge = null,
        ComponentMerge mergeBehavior = ComponentMerge.Merge,
        List<Blueprint<BlueprintItemWeapon, BlueprintItemWeaponReference>>? weapon = null)
    {
      var component = new AddSecondaryAttacks();
      component.m_Weapon = weapon?.Select(bp => bp.Reference)?.ToArray() ?? component.m_Weapon;
      if (component.m_Weapon is null)
      {
        component.m_Weapon = new BlueprintItemWeaponReference[0];
      }
      return AddUniqueComponent(component, mergeBehavior, merge);
    }

    /// <summary>
    /// Adds <see cref="AddSkillPointPerCharacterLevel"/>
    /// </summary>
    ///
    /// <remarks>
    ///
    /// <list type="bullet">
    /// <listheader>Used by</listheader>
    /// <item><term>FastLearner</term><description>7ad59ca648c14c0a92adec798d51eb6d</description></item>
    /// <item><term>HalfOrcSkilled</term><description>4e8fe10f42f314e4fa7c7918bcfadbd5</description></item>
    /// <item><term>HumanSkilled</term><description>3adf9274a210b164cb68f472dc1e4544</description></item>
    /// </list>
    /// </remarks>
    public TBuilder AddSkillPointPerCharacterLevel()
    {
      return AddComponent(new AddSkillPointPerCharacterLevel());
    }

    /// <summary>
    /// Adds <see cref="AddSpecialSpellList"/>
    /// </summary>
    ///
    /// <remarks>
    ///
    /// <list type="bullet">
    /// <listheader>Used by</listheader>
    /// <item><term>AirDomainSpellListFeature</term><description>421ddcc7dbb6ee7479de949aaa81108d</description></item>
    /// <item><term>LifeSpiritSpellListFeature</term><description>d920be3b06dabf74f9b01aa9752402dc</description></item>
    /// <item><term>WindSpiritSpellListFeature</term><description>1e3380a7b127725418ebe738979f3a65</description></item>
    /// </list>
    /// </remarks>
    ///
    /// <param name="archetype">
    /// <para>
    /// Blueprint of type BlueprintArchetype. You can pass in the blueprint using:
    /// <list type ="bullet">
    ///   <item><term>A blueprint instance</term></item>
    ///   <item><term>A blueprint reference</term></item>
    ///   <item><term>A blueprint id as a string, Guid, or BlueprintGuid</term></item>
    ///   <item><term>A blueprint name registered with <see cref="BlueprintCore.Utils.BlueprintTool">BlueprintTool</see></term></item>
    /// </list>
    /// See <see cref="BlueprintCore.Utils.Blueprint{{T, TRef}}">Blueprint</see> for more details.
    /// </para>
    /// </param>
    /// <param name="characterClass">
    /// <para>
    /// Blueprint of type BlueprintCharacterClass. You can pass in the blueprint using:
    /// <list type ="bullet">
    ///   <item><term>A blueprint instance</term></item>
    ///   <item><term>A blueprint reference</term></item>
    ///   <item><term>A blueprint id as a string, Guid, or BlueprintGuid</term></item>
    ///   <item><term>A blueprint name registered with <see cref="BlueprintCore.Utils.BlueprintTool">BlueprintTool</see></term></item>
    /// </list>
    /// See <see cref="BlueprintCore.Utils.Blueprint{{T, TRef}}">Blueprint</see> for more details.
    /// </para>
    /// </param>
    /// <param name="merge">
    /// If mergeBehavior is ComponentMerge.Merge and the component already exists, this expression is called to merge the components.
    /// </param>
    /// <param name="mergeBehavior">
    /// Handling if the component already exists since the component is unique. Defaults to ComponentMerge.Fail.
    /// </param>
    /// <param name="spellList">
    /// <para>
    /// Blueprint of type BlueprintSpellList. You can pass in the blueprint using:
    /// <list type ="bullet">
    ///   <item><term>A blueprint instance</term></item>
    ///   <item><term>A blueprint reference</term></item>
    ///   <item><term>A blueprint id as a string, Guid, or BlueprintGuid</term></item>
    ///   <item><term>A blueprint name registered with <see cref="BlueprintCore.Utils.BlueprintTool">BlueprintTool</see></term></item>
    /// </list>
    /// See <see cref="BlueprintCore.Utils.Blueprint{{T, TRef}}">Blueprint</see> for more details.
    /// </para>
    /// </param>
    public TBuilder AddSpecialSpellList(
        Blueprint<BlueprintArchetype, BlueprintArchetypeReference>? archetype = null,
        Blueprint<BlueprintCharacterClass, BlueprintCharacterClassReference>? characterClass = null,
        bool? forArchetypeOnly = null,
        Action<BlueprintComponent, BlueprintComponent>? merge = null,
        ComponentMerge mergeBehavior = ComponentMerge.Merge,
        Blueprint<BlueprintSpellList, BlueprintSpellListReference>? spellList = null)
    {
      var component = new AddSpecialSpellList();
      component.m_Archetype = archetype?.Reference ?? component.m_Archetype;
      if (component.m_Archetype is null)
      {
        component.m_Archetype = BlueprintTool.GetRef<BlueprintArchetypeReference>(null);
      }
      component.m_CharacterClass = characterClass?.Reference ?? component.m_CharacterClass;
      if (component.m_CharacterClass is null)
      {
        component.m_CharacterClass = BlueprintTool.GetRef<BlueprintCharacterClassReference>(null);
      }
      component.ForArchetypeOnly = forArchetypeOnly ?? component.ForArchetypeOnly;
      component.m_SpellList = spellList?.Reference ?? component.m_SpellList;
      if (component.m_SpellList is null)
      {
        component.m_SpellList = BlueprintTool.GetRef<BlueprintSpellListReference>(null);
      }
      return AddUniqueComponent(component, mergeBehavior, merge);
    }

    /// <summary>
    /// Adds <see cref="AddSpecialSpellListForArchetype"/>
    /// </summary>
    ///
    /// <remarks>
    ///
    /// <list type="bullet">
    /// <listheader>Used by</listheader>
    /// <item><term>AirDomainAllowed</term><description>6e5f4ff5a7010754ca78708ce1a9b233</description></item>
    /// <item><term>LiberationDomainAllowed</term><description>801ca88338451a546bca2ee59da87c53</description></item>
    /// <item><term>WeatherDomainAllowed</term><description>9dfdfd4904e98fa48b80c8f63ec2cf11</description></item>
    /// </list>
    /// </remarks>
    ///
    /// <param name="archetype">
    /// <para>
    /// Blueprint of type BlueprintArchetype. You can pass in the blueprint using:
    /// <list type ="bullet">
    ///   <item><term>A blueprint instance</term></item>
    ///   <item><term>A blueprint reference</term></item>
    ///   <item><term>A blueprint id as a string, Guid, or BlueprintGuid</term></item>
    ///   <item><term>A blueprint name registered with <see cref="BlueprintCore.Utils.BlueprintTool">BlueprintTool</see></term></item>
    /// </list>
    /// See <see cref="BlueprintCore.Utils.Blueprint{{T, TRef}}">Blueprint</see> for more details.
    /// </para>
    /// </param>
    /// <param name="characterClass">
    /// <para>
    /// Blueprint of type BlueprintCharacterClass. You can pass in the blueprint using:
    /// <list type ="bullet">
    ///   <item><term>A blueprint instance</term></item>
    ///   <item><term>A blueprint reference</term></item>
    ///   <item><term>A blueprint id as a string, Guid, or BlueprintGuid</term></item>
    ///   <item><term>A blueprint name registered with <see cref="BlueprintCore.Utils.BlueprintTool">BlueprintTool</see></term></item>
    /// </list>
    /// See <see cref="BlueprintCore.Utils.Blueprint{{T, TRef}}">Blueprint</see> for more details.
    /// </para>
    /// </param>
    /// <param name="spellList">
    /// <para>
    /// Blueprint of type BlueprintSpellList. You can pass in the blueprint using:
    /// <list type ="bullet">
    ///   <item><term>A blueprint instance</term></item>
    ///   <item><term>A blueprint reference</term></item>
    ///   <item><term>A blueprint id as a string, Guid, or BlueprintGuid</term></item>
    ///   <item><term>A blueprint name registered with <see cref="BlueprintCore.Utils.BlueprintTool">BlueprintTool</see></term></item>
    /// </list>
    /// See <see cref="BlueprintCore.Utils.Blueprint{{T, TRef}}">Blueprint</see> for more details.
    /// </para>
    /// </param>
    public TBuilder AddSpecialSpellListForArchetype(
        Blueprint<BlueprintArchetype, BlueprintArchetypeReference>? archetype = null,
        Blueprint<BlueprintCharacterClass, BlueprintCharacterClassReference>? characterClass = null,
        Blueprint<BlueprintSpellList, BlueprintSpellListReference>? spellList = null)
    {
      var component = new AddSpecialSpellListForArchetype();
      component.m_Archetype = archetype?.Reference ?? component.m_Archetype;
      if (component.m_Archetype is null)
      {
        component.m_Archetype = BlueprintTool.GetRef<BlueprintArchetypeReference>(null);
      }
      component.m_CharacterClass = characterClass?.Reference ?? component.m_CharacterClass;
      if (component.m_CharacterClass is null)
      {
        component.m_CharacterClass = BlueprintTool.GetRef<BlueprintCharacterClassReference>(null);
      }
      component.m_SpellList = spellList?.Reference ?? component.m_SpellList;
      if (component.m_SpellList is null)
      {
        component.m_SpellList = BlueprintTool.GetRef<BlueprintSpellListReference>(null);
      }
      return AddComponent(component);
    }

    /// <summary>
    /// Adds <see cref="AddSpellFailureChance"/>
    /// </summary>
    ///
    /// <remarks>
    ///
    /// <list type="bullet">
    /// <listheader>Used by</listheader>
    /// <item><term>AnomalyDistortionMindDesynchronizationBuff</term><description>86fd452c180b446fb6f1b0e29ffae5e7</description></item>
    /// <item><term>BlinkBuff</term><description>c168c6a0e471e924b8c69b31c6352587</description></item>
    /// </list>
    /// </remarks>
    public TBuilder AddSpellFailureChance(
        int? chance = null,
        GameObject? failFx = null)
    {
      var component = new AddSpellFailureChance();
      component.Chance = chance ?? component.Chance;
      Validate(failFx);
      component.FailFx = failFx ?? component.FailFx;
      return AddComponent(component);
    }

    /// <summary>
    /// Adds <see cref="AddSpellImmunity"/>
    /// </summary>
    ///
    /// <remarks>
    ///
    /// <list type="bullet">
    /// <listheader>Used by</listheader>
    /// <item><term>AdamantineGolemImmunity</term><description>5f77c76c45df559479c158cb079600f1</description></item>
    /// <item><term>MageShieldBuff</term><description>9c0fa9b438ada3f43864be8dd8b3e741</description></item>
    /// <item><term>WitchHexAuraOfPurityEffectBuff</term><description>c6e331831f3fbc642b4a1232b9f9e66e</description></item>
    /// </list>
    /// </remarks>
    ///
    /// <param name="casterIgnoreImmunityFact">
    /// <para>
    /// Blueprint of type BlueprintUnitFact. You can pass in the blueprint using:
    /// <list type ="bullet">
    ///   <item><term>A blueprint instance</term></item>
    ///   <item><term>A blueprint reference</term></item>
    ///   <item><term>A blueprint id as a string, Guid, or BlueprintGuid</term></item>
    ///   <item><term>A blueprint name registered with <see cref="BlueprintCore.Utils.BlueprintTool">BlueprintTool</see></term></item>
    /// </list>
    /// See <see cref="BlueprintCore.Utils.Blueprint{{T, TRef}}">Blueprint</see> for more details.
    /// </para>
    /// </param>
    /// <param name="exceptions">
    /// <para>
    /// Blueprint of type BlueprintAbility. You can pass in the blueprint using:
    /// <list type ="bullet">
    ///   <item><term>A blueprint instance</term></item>
    ///   <item><term>A blueprint reference</term></item>
    ///   <item><term>A blueprint id as a string, Guid, or BlueprintGuid</term></item>
    ///   <item><term>A blueprint name registered with <see cref="BlueprintCore.Utils.BlueprintTool">BlueprintTool</see></term></item>
    /// </list>
    /// See <see cref="BlueprintCore.Utils.Blueprint{{T, TRef}}">Blueprint</see> for more details.
    /// </para>
    /// </param>
    public TBuilder AddSpellImmunity(
        Blueprint<BlueprintUnitFact, BlueprintUnitFactReference>? casterIgnoreImmunityFact = null,
        List<Blueprint<BlueprintAbility, BlueprintAbilityReference>>? exceptions = null,
        bool? invertedDescriptors = null,
        SpellDescriptorWrapper? spellDescriptor = null,
        SpellImmunityType? type = null)
    {
      var component = new AddSpellImmunity();
      component.m_CasterIgnoreImmunityFact = casterIgnoreImmunityFact?.Reference ?? component.m_CasterIgnoreImmunityFact;
      if (component.m_CasterIgnoreImmunityFact is null)
      {
        component.m_CasterIgnoreImmunityFact = BlueprintTool.GetRef<BlueprintUnitFactReference>(null);
      }
      component.m_Exceptions = exceptions?.Select(bp => bp.Reference)?.ToArray() ?? component.m_Exceptions;
      if (component.m_Exceptions is null)
      {
        component.m_Exceptions = new BlueprintAbilityReference[0];
      }
      component.InvertedDescriptors = invertedDescriptors ?? component.InvertedDescriptors;
      component.SpellDescriptor = spellDescriptor ?? component.SpellDescriptor;
      component.Type = type ?? component.Type;
      return AddComponent(component);
    }

    /// <summary>
    /// Adds <see cref="AddSpellKnownTemporary"/>
    /// </summary>
    ///
    /// <remarks>
    ///
    /// <list type="bullet">
    /// <listheader>Used by</listheader>
    /// <item><term>BorealMightFeature</term><description>fcef74b5753dc9249b0b1879629fd73c</description></item>
    /// <item><term>EmberStormOfBurningRighteousnessFeature</term><description>ab6a8d5aca4b4d33bf40e725bdcf386f</description></item>
    /// <item><term>StormlordsResolveFeature</term><description>ea99aafffd17fcb45b1a8031c1e69321</description></item>
    /// </list>
    /// </remarks>
    ///
    /// <param name="characterClass">
    /// <para>
    /// Blueprint of type BlueprintCharacterClass. You can pass in the blueprint using:
    /// <list type ="bullet">
    ///   <item><term>A blueprint instance</term></item>
    ///   <item><term>A blueprint reference</term></item>
    ///   <item><term>A blueprint id as a string, Guid, or BlueprintGuid</term></item>
    ///   <item><term>A blueprint name registered with <see cref="BlueprintCore.Utils.BlueprintTool">BlueprintTool</see></term></item>
    /// </list>
    /// See <see cref="BlueprintCore.Utils.Blueprint{{T, TRef}}">Blueprint</see> for more details.
    /// </para>
    /// </param>
    /// <param name="merge">
    /// If mergeBehavior is ComponentMerge.Merge and the component already exists, this expression is called to merge the components.
    /// </param>
    /// <param name="mergeBehavior">
    /// Handling if the component already exists since the component is unique. Defaults to ComponentMerge.Fail.
    /// </param>
    /// <param name="spell">
    /// <para>
    /// Blueprint of type BlueprintAbility. You can pass in the blueprint using:
    /// <list type ="bullet">
    ///   <item><term>A blueprint instance</term></item>
    ///   <item><term>A blueprint reference</term></item>
    ///   <item><term>A blueprint id as a string, Guid, or BlueprintGuid</term></item>
    ///   <item><term>A blueprint name registered with <see cref="BlueprintCore.Utils.BlueprintTool">BlueprintTool</see></term></item>
    /// </list>
    /// See <see cref="BlueprintCore.Utils.Blueprint{{T, TRef}}">Blueprint</see> for more details.
    /// </para>
    /// </param>
    public TBuilder AddSpellKnownTemporary(
        Blueprint<BlueprintCharacterClass, BlueprintCharacterClassReference>? characterClass = null,
        int? level = null,
        Action<BlueprintComponent, BlueprintComponent>? merge = null,
        ComponentMerge mergeBehavior = ComponentMerge.Merge,
        bool? onlySpontaneous = null,
        Blueprint<BlueprintAbility, BlueprintAbilityReference>? spell = null)
    {
      var component = new AddSpellKnownTemporary();
      component.m_CharacterClass = characterClass?.Reference ?? component.m_CharacterClass;
      if (component.m_CharacterClass is null)
      {
        component.m_CharacterClass = BlueprintTool.GetRef<BlueprintCharacterClassReference>(null);
      }
      component.Level = level ?? component.Level;
      component.OnlySpontaneous = onlySpontaneous ?? component.OnlySpontaneous;
      component.m_Spell = spell?.Reference ?? component.m_Spell;
      if (component.m_Spell is null)
      {
        component.m_Spell = BlueprintTool.GetRef<BlueprintAbilityReference>(null);
      }
      return AddUniqueComponent(component, mergeBehavior, merge);
    }

    /// <summary>
    /// Adds <see cref="AddSpellResistance"/>
    /// </summary>
    ///
    /// <remarks>
    ///
    /// <list type="bullet">
    /// <listheader>Used by</listheader>
    /// <item><term>AnomalyDistortionMindDesynchronizationBuff</term><description>86fd452c180b446fb6f1b0e29ffae5e7</description></item>
    /// <item><term>PF2_DLC1_ValmallosAndPlayerNegativeBuff</term><description>454dbf13535b446bade750b8aacb10c7</description></item>
    /// <item><term>Woljif_DemonFeature</term><description>9b1a3628ce1140128a32ce7c89a75b27</description></item>
    /// </list>
    /// </remarks>
    ///
    /// <param name="allSpellResistancePenaltyDoNotUse">
    /// <para>
    /// InfoBox: I don't know what does it mean but if AllSpellResistancePenaltyDoNotUse == false then Value is Spell Resistance and if AllSpellResistancePenaltyDoNotUse == true then Value is Spell Resistance Penalty
    /// </para>
    /// </param>
    public TBuilder AddSpellResistance(
        bool? addCR = null,
        bool? allSpellResistancePenaltyDoNotUse = null,
        ContextValue? value = null)
    {
      var component = new AddSpellResistance();
      component.AddCR = addCR ?? component.AddCR;
      component.AllSpellResistancePenaltyDoNotUse = allSpellResistancePenaltyDoNotUse ?? component.AllSpellResistancePenaltyDoNotUse;
      component.Value = value ?? component.Value;
      if (component.Value is null)
      {
        component.Value = ContextValues.Constant(0);
      }
      return AddComponent(component);
    }

    /// <summary>
    /// Adds <see cref="AddSpellTypeFailureChance"/>
    /// </summary>
    ///
    /// <remarks>
    ///
    /// <list type="bullet">
    /// <listheader>Used by</listheader>
    /// <item><term>FaithStealingStrikeBuff</term><description>0ea4445a13230c34f9a8cd52c8725229</description></item>
    /// </list>
    /// </remarks>
    public TBuilder AddSpellTypeFailureChance(
        bool? alchemist = null,
        bool? arcane = null,
        int? chance = null,
        bool? divine = null,
        GameObject? failFx = null)
    {
      var component = new AddSpellTypeFailureChance();
      component.Alchemist = alchemist ?? component.Alchemist;
      component.Arcane = arcane ?? component.Arcane;
      component.Chance = chance ?? component.Chance;
      component.Divine = divine ?? component.Divine;
      Validate(failFx);
      component.FailFx = failFx ?? component.FailFx;
      return AddComponent(component);
    }

    /// <summary>
    /// Adds <see cref="AddStartingEquipment"/>
    /// </summary>
    ///
    /// <remarks>
    ///
    /// <list type="bullet">
    /// <listheader>Used by</listheader>
    /// <item><term>AbadarFeature</term><description>6122dacf418611540a3c91e67197ee4e</description></item>
    /// <item><term>GroetusFeature</term><description>c3e4d5681906d5246ab8b0637b98cbfe</description></item>
    /// <item><term>ZonKuthonFeature</term><description>f7eed400baa66a744ad361d4df0e6f1b</description></item>
    /// </list>
    /// </remarks>
    ///
    /// <param name="basicItems">
    /// <para>
    /// Blueprint of type BlueprintItem. You can pass in the blueprint using:
    /// <list type ="bullet">
    ///   <item><term>A blueprint instance</term></item>
    ///   <item><term>A blueprint reference</term></item>
    ///   <item><term>A blueprint id as a string, Guid, or BlueprintGuid</term></item>
    ///   <item><term>A blueprint name registered with <see cref="BlueprintCore.Utils.BlueprintTool">BlueprintTool</see></term></item>
    /// </list>
    /// See <see cref="BlueprintCore.Utils.Blueprint{{T, TRef}}">Blueprint</see> for more details.
    /// </para>
    /// </param>
    /// <param name="customCategoryDefaults">
    /// <para>
    /// Blueprint of type BlueprintCategoryDefaults. You can pass in the blueprint using:
    /// <list type ="bullet">
    ///   <item><term>A blueprint instance</term></item>
    ///   <item><term>A blueprint reference</term></item>
    ///   <item><term>A blueprint id as a string, Guid, or BlueprintGuid</term></item>
    ///   <item><term>A blueprint name registered with <see cref="BlueprintCore.Utils.BlueprintTool">BlueprintTool</see></term></item>
    /// </list>
    /// See <see cref="BlueprintCore.Utils.Blueprint{{T, TRef}}">Blueprint</see> for more details.
    /// </para>
    /// </param>
    /// <param name="merge">
    /// If mergeBehavior is ComponentMerge.Merge and the component already exists, this expression is called to merge the components.
    /// </param>
    /// <param name="mergeBehavior">
    /// Handling if the component already exists since the component is unique. Defaults to ComponentMerge.Fail.
    /// </param>
    /// <param name="restrictedByClass">
    /// <para>
    /// Blueprint of type BlueprintCharacterClass. You can pass in the blueprint using:
    /// <list type ="bullet">
    ///   <item><term>A blueprint instance</term></item>
    ///   <item><term>A blueprint reference</term></item>
    ///   <item><term>A blueprint id as a string, Guid, or BlueprintGuid</term></item>
    ///   <item><term>A blueprint name registered with <see cref="BlueprintCore.Utils.BlueprintTool">BlueprintTool</see></term></item>
    /// </list>
    /// See <see cref="BlueprintCore.Utils.Blueprint{{T, TRef}}">Blueprint</see> for more details.
    /// </para>
    /// </param>
    public TBuilder AddStartingEquipment(
        List<Blueprint<BlueprintItem, BlueprintItemReference>>? basicItems = null,
        WeaponCategory[]? categoryItems = null,
        Blueprint<BlueprintCategoryDefaults, BlueprintCategoryDefaultsReference>? customCategoryDefaults = null,
        Action<BlueprintComponent, BlueprintComponent>? merge = null,
        ComponentMerge mergeBehavior = ComponentMerge.Merge,
        bool? parametrizedCategory = null,
        List<Blueprint<BlueprintCharacterClass, BlueprintCharacterClassReference>>? restrictedByClass = null)
    {
      var component = new AddStartingEquipment();
      component.m_BasicItems = basicItems?.Select(bp => bp.Reference)?.ToArray() ?? component.m_BasicItems;
      if (component.m_BasicItems is null)
      {
        component.m_BasicItems = new BlueprintItemReference[0];
      }
      component.CategoryItems = categoryItems ?? component.CategoryItems;
      if (component.CategoryItems is null)
      {
        component.CategoryItems = new WeaponCategory[0];
      }
      component.m_CustomCategoryDefaults = customCategoryDefaults?.Reference ?? component.m_CustomCategoryDefaults;
      if (component.m_CustomCategoryDefaults is null)
      {
        component.m_CustomCategoryDefaults = BlueprintTool.GetRef<BlueprintCategoryDefaultsReference>(null);
      }
      component.ParametrizedCategory = parametrizedCategory ?? component.ParametrizedCategory;
      component.m_RestrictedByClass = restrictedByClass?.Select(bp => bp.Reference)?.ToArray() ?? component.m_RestrictedByClass;
      if (component.m_RestrictedByClass is null)
      {
        component.m_RestrictedByClass = new BlueprintCharacterClassReference[0];
      }
      return AddUniqueComponent(component, mergeBehavior, merge);
    }

    /// <summary>
    /// Adds <see cref="AddStatBonus"/>
    /// </summary>
    ///
    /// <remarks>
    ///
    /// <para>
    /// ComponentName: Add stat bonus
    /// </para>
    ///
    /// <list type="bullet">
    /// <listheader>Used by</listheader>
    /// <item><term>1_FirstStage_AcidBuff</term><description>6afe27c9a2d64eb890673ff3649dacb3</description></item>
    /// <item><term>ExterminatorFeature</term><description>7a472f4c0f7d36b4c8f52d3b17e7b292</description></item>
    /// <item><term>ZeorisDaggerRing_BetrayalEffectBuff</term><description>252279901e3644ce8b5b3275bea8f7bd</description></item>
    /// </list>
    /// </remarks>
    ///
    /// <param name="merge">
    /// If mergeBehavior is ComponentMerge.Merge and the component already exists, this expression is called to merge the components.
    /// </param>
    /// <param name="mergeBehavior">
    /// Handling if the component already exists since the component is unique. Defaults to ComponentMerge.Fail.
    /// </param>
    public TBuilder AddStatBonus(
        ModifierDescriptor? descriptor = null,
        Action<BlueprintComponent, BlueprintComponent>? merge = null,
        ComponentMerge mergeBehavior = ComponentMerge.Merge,
        bool? scaleByBasicAttackBonus = null,
        StatType? stat = null,
        int? value = null)
    {
      var component = new AddStatBonus();
      component.Descriptor = descriptor ?? component.Descriptor;
      component.ScaleByBasicAttackBonus = scaleByBasicAttackBonus ?? component.ScaleByBasicAttackBonus;
      component.Stat = stat ?? component.Stat;
      component.Value = value ?? component.Value;
      return AddUniqueComponent(component, mergeBehavior, merge);
    }

    /// <summary>
    /// Adds <see cref="AddStatModifier"/>
    /// </summary>
    ///
    /// <remarks>
    ///
    /// <list type="bullet">
    /// <listheader>Used by</listheader>
    /// <item><term>Ankou_ShadowDoubleHPBuff</term><description>6d3e036f4a09e274ebae0482922116c5</description></item>
    /// <item><term>ArmyInfernalArchersPoisonOnHitBuff</term><description>215d5b519c8f4f8588e992d1df329563</description></item>
    /// <item><term>RitualBearsEnduranceBuff</term><description>f307f19bc3432064e90b01de05b69e8d</description></item>
    /// </list>
    /// </remarks>
    ///
    /// <param name="merge">
    /// If mergeBehavior is ComponentMerge.Merge and the component already exists, this expression is called to merge the components.
    /// </param>
    /// <param name="mergeBehavior">
    /// Handling if the component already exists since the component is unique. Defaults to ComponentMerge.Fail.
    /// </param>
    public TBuilder AddStatModifier(
        ModifierDescriptor? descriptor = null,
        Action<BlueprintComponent, BlueprintComponent>? merge = null,
        ComponentMerge mergeBehavior = ComponentMerge.Merge,
        ContextValue? modifierPercents = null,
        StatType? stat = null,
        bool? updateIfStatChanged = null,
        bool? useBaseValue = null)
    {
      var component = new AddStatModifier();
      component.Descriptor = descriptor ?? component.Descriptor;
      component.ModifierPercents = modifierPercents ?? component.ModifierPercents;
      if (component.ModifierPercents is null)
      {
        component.ModifierPercents = ContextValues.Constant(0);
      }
      component.Stat = stat ?? component.Stat;
      component.UpdateIfStatChanged = updateIfStatChanged ?? component.UpdateIfStatChanged;
      component.UseBaseValue = useBaseValue ?? component.UseBaseValue;
      return AddUniqueComponent(component, mergeBehavior, merge);
    }

    /// <summary>
    /// Adds <see cref="AddUndetectableAlignment"/>
    /// </summary>
    ///
    /// <remarks>
    ///
    /// <list type="bullet">
    /// <listheader>Used by</listheader>
    /// <item><term>CameliaAmuletFeature</term><description>14e09d21335cd81478252653ba1a8464</description></item>
    /// </list>
    /// </remarks>
    public TBuilder AddUndetectableAlignment()
    {
      return AddComponent(new AddUndetectableAlignment());
    }

    /// <summary>
    /// Adds <see cref="AddUnitScale"/>
    /// </summary>
    ///
    /// <remarks>
    ///
    /// <para>
    /// ComponentName: Buffs/AddEffect/Scale
    /// </para>
    ///
    /// <list type="bullet">
    /// <listheader>Used by</listheader>
    /// <item><term>AeonTrueFeature</term><description>bd69eff3a3364eba8b4ff20dce87bb84</description></item>
    /// <item><term>ArmyKineticist</term><description>f76d591a08c84fc784ea7d9be756ad70</description></item>
    /// <item><term>TricksterTrueFeature</term><description>e162a9136677410f9755a6651f2cfac9</description></item>
    /// </list>
    /// </remarks>
    ///
    /// <param name="scaleIncreaseCoefficient">
    /// <para>
    /// InfoBox: Creature scale coefficients. Value of 0.25 means size increase by 1.4
    /// </para>
    /// </param>
    public TBuilder AddUnitScale(
        float? scaleIncreaseCoefficient = null)
    {
      var component = new AddUnitScale();
      component.ScaleIncreaseCoefficient = scaleIncreaseCoefficient ?? component.ScaleIncreaseCoefficient;
      return AddComponent(component);
    }

    /// <summary>
    /// Adds <see cref="AddUnlimitedSpell"/>
    /// </summary>
    ///
    /// <remarks>
    ///
    /// <list type="bullet">
    /// <listheader>Used by</listheader>
    /// <item><term>BoundlessHealing</term><description>c8bbb330aaecaf54dbc7570200653f8c</description></item>
    /// <item><term>OracleRevelationEnhancedCures</term><description>973a22b02c793ca49b48652e3d70ae80</description></item>
    /// </list>
    /// </remarks>
    ///
    /// <param name="abilities">
    /// <para>
    /// Blueprint of type BlueprintAbility. You can pass in the blueprint using:
    /// <list type ="bullet">
    ///   <item><term>A blueprint instance</term></item>
    ///   <item><term>A blueprint reference</term></item>
    ///   <item><term>A blueprint id as a string, Guid, or BlueprintGuid</term></item>
    ///   <item><term>A blueprint name registered with <see cref="BlueprintCore.Utils.BlueprintTool">BlueprintTool</see></term></item>
    /// </list>
    /// See <see cref="BlueprintCore.Utils.Blueprint{{T, TRef}}">Blueprint</see> for more details.
    /// </para>
    /// </param>
    public TBuilder AddUnlimitedSpell(
        List<Blueprint<BlueprintAbility, BlueprintAbilityReference>>? abilities = null)
    {
      var component = new AddUnlimitedSpell();
      component.m_Abilities = abilities?.Select(bp => bp.Reference)?.ToArray() ?? component.m_Abilities;
      if (component.m_Abilities is null)
      {
        component.m_Abilities = new BlueprintAbilityReference[0];
      }
      return AddComponent(component);
    }

    /// <summary>
    /// Adds <see cref="AdditionalDamageOnSneakAttack"/>
    /// </summary>
    ///
    /// <remarks>
    ///
    /// <list type="bullet">
    /// <listheader>Used by</listheader>
    /// <item><term>QuestElectriSneakAttackBuff</term><description>03a92b5b02c9caf4d9aaf84ff486efb7</description></item>
    /// </list>
    /// </remarks>
    ///
    /// <param name="merge">
    /// If mergeBehavior is ComponentMerge.Merge and the component already exists, this expression is called to merge the components.
    /// </param>
    /// <param name="mergeBehavior">
    /// Handling if the component already exists since the component is unique. Defaults to ComponentMerge.Fail.
    /// </param>
    public TBuilder AdditionalDamageOnSneakAttack(
        Action<BlueprintComponent, BlueprintComponent>? merge = null,
        ComponentMerge mergeBehavior = ComponentMerge.Merge,
        bool? onlyRanged = null,
        int? value = null)
    {
      var component = new AdditionalDamageOnSneakAttack();
      component.OnlyRanged = onlyRanged ?? component.OnlyRanged;
      component.Value = value ?? component.Value;
      return AddUniqueComponent(component, mergeBehavior, merge);
    }

    /// <summary>
    /// Adds <see cref="AeonSavedStateFeature"/>
    /// </summary>
    ///
    /// <remarks>
    ///
    /// <list type="bullet">
    /// <listheader>Used by</listheader>
    /// <item><term>AeonRewind</term><description>00dcda6221d72af4989d7efb6081f882</description></item>
    /// </list>
    /// </remarks>
    ///
    /// <param name="delaySeconds">
    /// <para>
    /// InfoBox: Delay before unit translocation and spawn of appear fx
    /// </para>
    /// </param>
    /// <param name="invulnerabilityBuff">
    /// <para>
    /// InfoBox: Buff which should protect unit and forbid direct control
    /// </para>
    /// <para>
    /// Blueprint of type BlueprintBuff. You can pass in the blueprint using:
    /// <list type ="bullet">
    ///   <item><term>A blueprint instance</term></item>
    ///   <item><term>A blueprint reference</term></item>
    ///   <item><term>A blueprint id as a string, Guid, or BlueprintGuid</term></item>
    ///   <item><term>A blueprint name registered with <see cref="BlueprintCore.Utils.BlueprintTool">BlueprintTool</see></term></item>
    /// </list>
    /// See <see cref="BlueprintCore.Utils.Blueprint{{T, TRef}}">Blueprint</see> for more details.
    /// </para>
    /// </param>
    /// <param name="rank">
    /// <para>
    /// Blueprint of type BlueprintFeature. You can pass in the blueprint using:
    /// <list type ="bullet">
    ///   <item><term>A blueprint instance</term></item>
    ///   <item><term>A blueprint reference</term></item>
    ///   <item><term>A blueprint id as a string, Guid, or BlueprintGuid</term></item>
    ///   <item><term>A blueprint name registered with <see cref="BlueprintCore.Utils.BlueprintTool">BlueprintTool</see></term></item>
    /// </list>
    /// See <see cref="BlueprintCore.Utils.Blueprint{{T, TRef}}">Blueprint</see> for more details.
    /// </para>
    /// </param>
    /// <param name="resource">
    /// <para>
    /// Blueprint of type BlueprintAbilityResource. You can pass in the blueprint using:
    /// <list type ="bullet">
    ///   <item><term>A blueprint instance</term></item>
    ///   <item><term>A blueprint reference</term></item>
    ///   <item><term>A blueprint id as a string, Guid, or BlueprintGuid</term></item>
    ///   <item><term>A blueprint name registered with <see cref="BlueprintCore.Utils.BlueprintTool">BlueprintTool</see></term></item>
    /// </list>
    /// See <see cref="BlueprintCore.Utils.Blueprint{{T, TRef}}">Blueprint</see> for more details.
    /// </para>
    /// </param>
    public TBuilder AddAeonSavedStateFeature(
        PrefabLink? appearFx = null,
        float? delaySeconds = null,
        PrefabLink? disappearFx = null,
        Blueprint<BlueprintBuff, BlueprintBuffReference>? invulnerabilityBuff = null,
        float? invulnerabilitySeconds = null,
        Blueprint<BlueprintFeature, BlueprintFeatureReference>? rank = null,
        Blueprint<BlueprintAbilityResource, BlueprintAbilityResourceReference>? resource = null)
    {
      var component = new AeonSavedStateFeature();
      component.AppearFx = appearFx ?? component.AppearFx;
      if (component.AppearFx is null)
      {
        component.AppearFx = Utils.Constants.Empty.PrefabLink;
      }
      component.DelaySeconds = delaySeconds ?? component.DelaySeconds;
      component.DisappearFx = disappearFx ?? component.DisappearFx;
      if (component.DisappearFx is null)
      {
        component.DisappearFx = Utils.Constants.Empty.PrefabLink;
      }
      component.m_InvulnerabilityBuff = invulnerabilityBuff?.Reference ?? component.m_InvulnerabilityBuff;
      if (component.m_InvulnerabilityBuff is null)
      {
        component.m_InvulnerabilityBuff = BlueprintTool.GetRef<BlueprintBuffReference>(null);
      }
      component.InvulnerabilitySeconds = invulnerabilitySeconds ?? component.InvulnerabilitySeconds;
      component.m_Rank = rank?.Reference ?? component.m_Rank;
      if (component.m_Rank is null)
      {
        component.m_Rank = BlueprintTool.GetRef<BlueprintFeatureReference>(null);
      }
      component.m_Resource = resource?.Reference ?? component.m_Resource;
      if (component.m_Resource is null)
      {
        component.m_Resource = BlueprintTool.GetRef<BlueprintAbilityResourceReference>(null);
      }
      return AddComponent(component);
    }

    /// <summary>
    /// Adds <see cref="AllowDyingCondition"/>
    /// </summary>
    ///
    /// <remarks>
    ///
    /// <para>
    /// ComponentName: Allow dying condition
    /// </para>
    ///
    /// <list type="bullet">
    /// <listheader>Used by</listheader>
    /// <item><term>!Octavia_Companion_Mage_Test</term><description>f9161aa0b3f519c47acbce01f53ee217</description></item>
    /// <item><term>MountTestCharacter_OreadFemale7</term><description>741873f3c8924d9883b6b6d0878f8eb8</description></item>
    /// <item><term>WoljifTestLeve9</term><description>b6a343d8b3f47784dab47911fb42a84a</description></item>
    /// </list>
    /// </remarks>
    public TBuilder AddAllowDyingCondition()
    {
      return AddComponent(new AllowDyingCondition());
    }

    /// <summary>
    /// Adds <see cref="ApplyClassProgression"/>
    /// </summary>
    ///
    /// <remarks>
    ///
    /// <list type="bullet">
    /// <listheader>Used by</listheader>
    /// <item><term>AeonInThePast_DemonLordDeskar</term><description>f896dd504b3509b4abd42f01e26140da</description></item>
    /// <item><term>CR26_BalorMythicBloodrager_RE</term><description>85eba255013867c41a3990c8ef691ab4</description></item>
    /// <item><term>Ygefeles</term><description>aedf061b223b6d54e8ffae6175515b29</description></item>
    /// </list>
    /// </remarks>
    ///
    /// <param name="clazz">
    /// <para>
    /// Blueprint of type BlueprintCharacterClass. You can pass in the blueprint using:
    /// <list type ="bullet">
    ///   <item><term>A blueprint instance</term></item>
    ///   <item><term>A blueprint reference</term></item>
    ///   <item><term>A blueprint id as a string, Guid, or BlueprintGuid</term></item>
    ///   <item><term>A blueprint name registered with <see cref="BlueprintCore.Utils.BlueprintTool">BlueprintTool</see></term></item>
    /// </list>
    /// See <see cref="BlueprintCore.Utils.Blueprint{{T, TRef}}">Blueprint</see> for more details.
    /// </para>
    /// </param>
    /// <param name="features">
    /// <para>
    /// Blueprint of type BlueprintFeature. You can pass in the blueprint using:
    /// <list type ="bullet">
    ///   <item><term>A blueprint instance</term></item>
    ///   <item><term>A blueprint reference</term></item>
    ///   <item><term>A blueprint id as a string, Guid, or BlueprintGuid</term></item>
    ///   <item><term>A blueprint name registered with <see cref="BlueprintCore.Utils.BlueprintTool">BlueprintTool</see></term></item>
    /// </list>
    /// See <see cref="BlueprintCore.Utils.Blueprint{{T, TRef}}">Blueprint</see> for more details.
    /// </para>
    /// </param>
    /// <param name="memorizeSpells">
    /// <para>
    /// Blueprint of type BlueprintAbility. You can pass in the blueprint using:
    /// <list type ="bullet">
    ///   <item><term>A blueprint instance</term></item>
    ///   <item><term>A blueprint reference</term></item>
    ///   <item><term>A blueprint id as a string, Guid, or BlueprintGuid</term></item>
    ///   <item><term>A blueprint name registered with <see cref="BlueprintCore.Utils.BlueprintTool">BlueprintTool</see></term></item>
    /// </list>
    /// See <see cref="BlueprintCore.Utils.Blueprint{{T, TRef}}">Blueprint</see> for more details.
    /// </para>
    /// </param>
    /// <param name="selectSpells">
    /// <para>
    /// Blueprint of type BlueprintAbility. You can pass in the blueprint using:
    /// <list type ="bullet">
    ///   <item><term>A blueprint instance</term></item>
    ///   <item><term>A blueprint reference</term></item>
    ///   <item><term>A blueprint id as a string, Guid, or BlueprintGuid</term></item>
    ///   <item><term>A blueprint name registered with <see cref="BlueprintCore.Utils.BlueprintTool">BlueprintTool</see></term></item>
    /// </list>
    /// See <see cref="BlueprintCore.Utils.Blueprint{{T, TRef}}">Blueprint</see> for more details.
    /// </para>
    /// </param>
    public TBuilder AddApplyClassProgression(
        Blueprint<BlueprintCharacterClass, BlueprintCharacterClassReference>? clazz = null,
        List<Blueprint<BlueprintFeature, BlueprintFeatureReference>>? features = null,
        int? level = null,
        List<Blueprint<BlueprintAbility, BlueprintAbilityReference>>? memorizeSpells = null,
        ParameterizedFeatureEntry[]? parameterizedFeatures = null,
        List<Blueprint<BlueprintAbility, BlueprintAbilityReference>>? selectSpells = null)
    {
      var component = new ApplyClassProgression();
      component.m_Class = clazz?.Reference ?? component.m_Class;
      if (component.m_Class is null)
      {
        component.m_Class = BlueprintTool.GetRef<BlueprintCharacterClassReference>(null);
      }
      component.m_Features = features?.Select(bp => bp.Reference)?.ToArray() ?? component.m_Features;
      if (component.m_Features is null)
      {
        component.m_Features = new BlueprintFeatureReference[0];
      }
      component.Level = level ?? component.Level;
      component.m_MemorizeSpells = memorizeSpells?.Select(bp => bp.Reference)?.ToArray() ?? component.m_MemorizeSpells;
      if (component.m_MemorizeSpells is null)
      {
        component.m_MemorizeSpells = new BlueprintAbilityReference[0];
      }
      foreach (var item in parameterizedFeatures) { Validate(item); }
      component.ParameterizedFeatures = parameterizedFeatures ?? component.ParameterizedFeatures;
      if (component.ParameterizedFeatures is null)
      {
        component.ParameterizedFeatures = new ParameterizedFeatureEntry[0];
      }
      component.m_SelectSpells = selectSpells?.Select(bp => bp.Reference)?.ToArray() ?? component.m_SelectSpells;
      if (component.m_SelectSpells is null)
      {
        component.m_SelectSpells = new BlueprintAbilityReference[0];
      }
      return AddComponent(component);
    }

    /// <summary>
    /// Adds <see cref="AreaEffectImmunity"/>
    /// </summary>
    ///
    /// <remarks>
    ///
    /// <list type="bullet">
    /// <listheader>Used by</listheader>
    /// <item><term>AeonAreaEffectsGazeAllyBuff</term><description>5f628dc321f74a6bbadec25f665a402d</description></item>
    /// <item><term>Valmallos_Buff_AeonGazeAlly</term><description>67e8a3dd2d6a47a2bcf20e059a01fc72</description></item>
    /// <item><term>Valmallos_Buff_AeonGazeAlly_Core</term><description>8c43b0cd1ba54777b2eecb0c16caf5cf</description></item>
    /// </list>
    /// </remarks>
    ///
    /// <param name="areaEffects">
    /// <para>
    /// Blueprint of type BlueprintAbilityAreaEffect. You can pass in the blueprint using:
    /// <list type ="bullet">
    ///   <item><term>A blueprint instance</term></item>
    ///   <item><term>A blueprint reference</term></item>
    ///   <item><term>A blueprint id as a string, Guid, or BlueprintGuid</term></item>
    ///   <item><term>A blueprint name registered with <see cref="BlueprintCore.Utils.BlueprintTool">BlueprintTool</see></term></item>
    /// </list>
    /// See <see cref="BlueprintCore.Utils.Blueprint{{T, TRef}}">Blueprint</see> for more details.
    /// </para>
    /// </param>
    /// <param name="merge">
    /// If mergeBehavior is ComponentMerge.Merge and the component already exists, this expression is called to merge the components.
    /// </param>
    /// <param name="mergeBehavior">
    /// Handling if the component already exists since the component is unique. Defaults to ComponentMerge.Fail.
    /// </param>
    public TBuilder AddAreaEffectImmunity(
        List<Blueprint<BlueprintAbilityAreaEffect, BlueprintAbilityAreaEffectReference>>? areaEffects = null,
        Kingmaker.UnitLogic.Abilities.Components.TargetType? casterType = null,
        Action<BlueprintComponent, BlueprintComponent>? merge = null,
        ComponentMerge mergeBehavior = ComponentMerge.Merge,
        bool? specificAreaEffects = null)
    {
      var component = new AreaEffectImmunity();
      component.m_AreaEffects = areaEffects?.Select(bp => bp.Reference)?.ToList() ?? component.m_AreaEffects;
      if (component.m_AreaEffects is null)
      {
        component.m_AreaEffects = new();
      }
      component.m_CasterType = casterType ?? component.m_CasterType;
      component.m_SpecificAreaEffects = specificAreaEffects ?? component.m_SpecificAreaEffects;
      return AddUniqueComponent(component, mergeBehavior, merge);
    }

    /// <summary>
    /// Adds <see cref="AttackStatReplacement"/>
    /// </summary>
    ///
    /// <remarks>
    ///
    /// <para>
    /// ComponentName: Replace attack stat
    /// </para>
    ///
    /// <list type="bullet">
    /// <listheader>Used by</listheader>
    /// <item><term>Incorporeal</term><description>c4a7f98d743bc784c9d4cf2105852c39</description></item>
    /// <item><term>ShadowGreater_Feature_StrengthDamage</term><description>89d9954f32fa1624bb132342c1878e90</description></item>
    /// <item><term>ZenArcherZenArcheryFeature</term><description>379c0da9f384e7547a70c259445377f5</description></item>
    /// </list>
    /// </remarks>
    ///
    /// <param name="weaponTypes">
    /// <para>
    /// Blueprint of type BlueprintWeaponType. You can pass in the blueprint using:
    /// <list type ="bullet">
    ///   <item><term>A blueprint instance</term></item>
    ///   <item><term>A blueprint reference</term></item>
    ///   <item><term>A blueprint id as a string, Guid, or BlueprintGuid</term></item>
    ///   <item><term>A blueprint name registered with <see cref="BlueprintCore.Utils.BlueprintTool">BlueprintTool</see></term></item>
    /// </list>
    /// See <see cref="BlueprintCore.Utils.Blueprint{{T, TRef}}">Blueprint</see> for more details.
    /// </para>
    /// </param>
    public TBuilder AddAttackStatReplacement(
        bool? checkWeaponTypes = null,
        StatType? replacementStat = null,
        WeaponSubCategory? subCategory = null,
        List<Blueprint<BlueprintWeaponType, BlueprintWeaponTypeReference>>? weaponTypes = null)
    {
      var component = new AttackStatReplacement();
      component.CheckWeaponTypes = checkWeaponTypes ?? component.CheckWeaponTypes;
      component.ReplacementStat = replacementStat ?? component.ReplacementStat;
      component.SubCategory = subCategory ?? component.SubCategory;
      component.m_WeaponTypes = weaponTypes?.Select(bp => bp.Reference)?.ToArray() ?? component.m_WeaponTypes;
      if (component.m_WeaponTypes is null)
      {
        component.m_WeaponTypes = new BlueprintWeaponTypeReference[0];
      }
      return AddComponent(component);
    }

    /// <summary>
    /// Adds <see cref="AutoFailCastingDefensively"/>
    /// </summary>
    ///
    /// <remarks>
    ///
    /// <list type="bullet">
    /// <listheader>Used by</listheader>
    /// <item><term>BloodragerArcaneCastersBaneEffectBuff</term><description>cdb1ad4a4a5a41eb82083a91b97f8979</description></item>
    /// </list>
    /// </remarks>
    public TBuilder AddAutoFailCastingDefensively()
    {
      return AddComponent(new AutoFailCastingDefensively());
    }

    /// <summary>
    /// Adds <see cref="BuffDescriptorImmunity"/>
    /// </summary>
    ///
    /// <remarks>
    ///
    /// <list type="bullet">
    /// <listheader>Used by</listheader>
    /// <item><term>AirBlessingMajorBuff</term><description>ac410725d8fc6fe4b81d47269f4f3ea1</description></item>
    /// <item><term>FreedomOfMovementBuffPermanent</term><description>235533b62159790499ced35860636bb2</description></item>
    /// <item><term>WoundWormsLairDragonBuff</term><description>d095cd5fa7e97ff4f8b7a32b69fc0713</description></item>
    /// </list>
    /// </remarks>
    ///
    /// <param name="factToCheck">
    /// <para>
    /// Blueprint of type BlueprintUnitFact. You can pass in the blueprint using:
    /// <list type ="bullet">
    ///   <item><term>A blueprint instance</term></item>
    ///   <item><term>A blueprint reference</term></item>
    ///   <item><term>A blueprint id as a string, Guid, or BlueprintGuid</term></item>
    ///   <item><term>A blueprint name registered with <see cref="BlueprintCore.Utils.BlueprintTool">BlueprintTool</see></term></item>
    /// </list>
    /// See <see cref="BlueprintCore.Utils.Blueprint{{T, TRef}}">Blueprint</see> for more details.
    /// </para>
    /// </param>
    /// <param name="ignoreFeature">
    /// <para>
    /// Blueprint of type BlueprintUnitFact. You can pass in the blueprint using:
    /// <list type ="bullet">
    ///   <item><term>A blueprint instance</term></item>
    ///   <item><term>A blueprint reference</term></item>
    ///   <item><term>A blueprint id as a string, Guid, or BlueprintGuid</term></item>
    ///   <item><term>A blueprint name registered with <see cref="BlueprintCore.Utils.BlueprintTool">BlueprintTool</see></term></item>
    /// </list>
    /// See <see cref="BlueprintCore.Utils.Blueprint{{T, TRef}}">Blueprint</see> for more details.
    /// </para>
    /// </param>
    /// <param name="merge">
    /// If mergeBehavior is ComponentMerge.Merge and the component already exists, this expression is called to merge the components.
    /// </param>
    /// <param name="mergeBehavior">
    /// Handling if the component already exists since the component is unique. Defaults to ComponentMerge.Fail.
    /// </param>
    public TBuilder AddBuffDescriptorImmunity(
        bool? checkFact = null,
        SpellDescriptorWrapper? descriptor = null,
        Blueprint<BlueprintUnitFact, BlueprintUnitFactReference>? factToCheck = null,
        Blueprint<BlueprintUnitFact, BlueprintUnitFactReference>? ignoreFeature = null,
        Action<BlueprintComponent, BlueprintComponent>? merge = null,
        ComponentMerge mergeBehavior = ComponentMerge.Merge)
    {
      var component = new BuffDescriptorImmunity();
      component.CheckFact = checkFact ?? component.CheckFact;
      component.Descriptor = descriptor ?? component.Descriptor;
      component.m_FactToCheck = factToCheck?.Reference ?? component.m_FactToCheck;
      if (component.m_FactToCheck is null)
      {
        component.m_FactToCheck = BlueprintTool.GetRef<BlueprintUnitFactReference>(null);
      }
      component.m_IgnoreFeature = ignoreFeature?.Reference ?? component.m_IgnoreFeature;
      if (component.m_IgnoreFeature is null)
      {
        component.m_IgnoreFeature = BlueprintTool.GetRef<BlueprintUnitFactReference>(null);
      }
      return AddUniqueComponent(component, mergeBehavior, merge);
    }

    /// <summary>
    /// Adds <see cref="ChangeFaction"/>
    /// </summary>
    ///
    /// <remarks>
    ///
    /// <list type="bullet">
    /// <listheader>Used by</listheader>
    /// <item><term>ArmyDominateBuff</term><description>2ab491a0101344bc8ad3e62ba6a6dac6</description></item>
    /// <item><term>CR4_Marauder_Human_RogueAxe_Male</term><description>b2ee6a030ec740dabefab7d5c18b02be</description></item>
    /// <item><term>WitchHexAnimalServantBuff</term><description>c976bf2495a8d854ca4593318de1664d</description></item>
    /// </list>
    /// </remarks>
    ///
    /// <param name="faction">
    /// <para>
    /// Blueprint of type BlueprintFaction. You can pass in the blueprint using:
    /// <list type ="bullet">
    ///   <item><term>A blueprint instance</term></item>
    ///   <item><term>A blueprint reference</term></item>
    ///   <item><term>A blueprint id as a string, Guid, or BlueprintGuid</term></item>
    ///   <item><term>A blueprint name registered with <see cref="BlueprintCore.Utils.BlueprintTool">BlueprintTool</see></term></item>
    /// </list>
    /// See <see cref="BlueprintCore.Utils.Blueprint{{T, TRef}}">Blueprint</see> for more details.
    /// </para>
    /// </param>
    public TBuilder AddChangeFaction(
        bool? allowDirectControl = null,
        Blueprint<BlueprintFaction, BlueprintFactionReference>? faction = null,
        ChangeFaction.ChangeType? type = null)
    {
      var component = new ChangeFaction();
      component.m_AllowDirectControl = allowDirectControl ?? component.m_AllowDirectControl;
      component.m_Faction = faction?.Reference ?? component.m_Faction;
      if (component.m_Faction is null)
      {
        component.m_Faction = BlueprintTool.GetRef<BlueprintFactionReference>(null);
      }
      component.m_Type = type ?? component.m_Type;
      return AddComponent(component);
    }

    /// <summary>
    /// Adds <see cref="ChangeImpatience"/>
    /// </summary>
    ///
    /// <remarks>
    ///
    /// <list type="bullet">
    /// <listheader>Used by</listheader>
    /// <item><term>AeonInThePast_DemonLordDeskar</term><description>f896dd504b3509b4abd42f01e26140da</description></item>
    /// <item><term>CR21_ZombieLordFighter_DLC1</term><description>a356271a621747158164fcb22c5f7935</description></item>
    /// <item><term>WoundWormsLair_BlackDragon</term><description>c540d81c08822c14da75761493427e4c</description></item>
    /// </list>
    /// </remarks>
    ///
    /// <param name="delta">
    /// <para>
    /// InfoBox: -1 - low (passive), 0 - normal, 1 - high (active)
    /// </para>
    /// </param>
    public TBuilder AddChangeImpatience(
        int? delta = null)
    {
      var component = new ChangeImpatience();
      component.Delta = delta ?? component.Delta;
      return AddComponent(component);
    }

    /// <summary>
    /// Adds <see cref="ChangeIncomingDamageType"/>
    /// </summary>
    ///
    /// <remarks>
    ///
    /// <list type="bullet">
    /// <listheader>Used by</listheader>
    /// <item><term>DeathOfElementsConsumingElementsBuff</term><description>4cc43b1a8bed0744f9cc06dd66ddaf59</description></item>
    /// </list>
    /// </remarks>
    public TBuilder AddChangeIncomingDamageType(
        DamageTypeDescription? type = null)
    {
      var component = new ChangeIncomingDamageType();
      Validate(type);
      component.Type = type ?? component.Type;
      return AddComponent(component);
    }

    /// <summary>
    /// Adds <see cref="ChangeOutgoingDamageType"/>
    /// </summary>
    ///
    /// <remarks>
    ///
    /// <list type="bullet">
    /// <listheader>Used by</listheader>
    /// <item><term>AngelSwordHolyDamageEffectBuff</term><description>4b2fa2b2075348b6bde90c3f6ff0b3f1</description></item>
    /// <item><term>DeathOfElementsDeathOfElementsBuff</term><description>7b9e460440993204281169694460ae6c</description></item>
    /// <item><term>DragonLevel3Immunities</term><description>f1631a20b6f14e58924a32c81da95840</description></item>
    /// </list>
    /// </remarks>
    public TBuilder AddChangeOutgoingDamageType(
        DamageTypeDescription? type = null)
    {
      var component = new ChangeOutgoingDamageType();
      Validate(type);
      component.Type = type ?? component.Type;
      return AddComponent(component);
    }

    /// <summary>
    /// Adds <see cref="ChangeSpellCommandType"/>
    /// </summary>
    ///
    /// <remarks>
    ///
    /// <list type="bullet">
    /// <listheader>Used by</listheader>
    /// <item><term>AeonPrimordialMagicSupportGazeAllyHiddenBuff</term><description>52871ffb3c75465c92fc0bed6956e381</description></item>
    /// <item><term>AeonPrimordialMagicSupportGazeEnemyBuff</term><description>2f6033ea4af54dcb81002cdaa41e3d91</description></item>
    /// </list>
    /// </remarks>
    ///
    /// <param name="spellTargetType">
    /// <para>
    /// InfoBox: Friend means CanTargetFriends = true and CanTargetEnemies = false in BlueprintAbility Enemy means CanTargetFriends = false and CanTargetEnemies = true All means CanTargetFriends = true and CanTargetEnemies = true
    /// </para>
    /// </param>
    public TBuilder AddChangeSpellCommandType(
        AbilityType? abilityType = null,
        UnitCommand.CommandType? newCommandType = null,
        bool? requireFullRound = null,
        bool? specificAbilityType = null,
        bool? specificSpellCommandType = null,
        UnitCommand.CommandType? spellCommandType = null,
        Kingmaker.AI.Blueprints.TargetType? spellTargetType = null)
    {
      var component = new ChangeSpellCommandType();
      component.m_AbilityType = abilityType ?? component.m_AbilityType;
      component.m_NewCommandType = newCommandType ?? component.m_NewCommandType;
      component.m_RequireFullRound = requireFullRound ?? component.m_RequireFullRound;
      component.m_SpecificAbilityType = specificAbilityType ?? component.m_SpecificAbilityType;
      component.m_SpecificSpellCommandType = specificSpellCommandType ?? component.m_SpecificSpellCommandType;
      component.m_SpellCommandType = spellCommandType ?? component.m_SpellCommandType;
      component.m_SpellTargetType = spellTargetType ?? component.m_SpellTargetType;
      return AddComponent(component);
    }

    /// <summary>
    /// Adds <see cref="CombatLogNotification"/>
    /// </summary>
    ///
    /// <remarks>
    ///
    /// <list type="bullet">
    /// <listheader>Used by</listheader>
    /// </list>
    /// </remarks>
    public TBuilder AddCombatLogNotification()
    {
      return AddComponent(new CombatLogNotification());
    }

    /// <summary>
    /// Adds <see cref="CombatManeuverOnCriticalHit"/>
    /// </summary>
    ///
    /// <remarks>
    ///
    /// <list type="bullet">
    /// <listheader>Used by</listheader>
    /// <item><term>DisarmingStrikeBuff</term><description>a2a60c12e69603e47bb20218602a1119</description></item>
    /// </list>
    /// </remarks>
    public TBuilder AddCombatManeuverOnCriticalHit(
        CombatManeuver? maneuver = null,
        ActionsBuilder? onSuccess = null)
    {
      var component = new CombatManeuverOnCriticalHit();
      component.Maneuver = maneuver ?? component.Maneuver;
      component.OnSuccess = onSuccess?.Build() ?? component.OnSuccess;
      if (component.OnSuccess is null)
      {
        component.OnSuccess = Utils.Constants.Empty.Actions;
      }
      return AddComponent(component);
    }

    /// <summary>
    /// Adds <see cref="CompanionImmortality"/>
    /// </summary>
    ///
    /// <remarks>
    ///
    /// <list type="bullet">
    /// <listheader>Used by</listheader>
    /// <item><term>Arueshalae_Level9</term><description>ef139c9b492f5154fb8607000aebbaa5</description></item>
    /// <item><term>ArueshalaeImmortalityBuff</term><description>7ad9d9982302e2244a7dd73fee6c381b</description></item>
    /// <item><term>LinziRingFeature</term><description>4c0f0c9fafc3f8745a0e81ba95908c01</description></item>
    /// </list>
    /// </remarks>
    public TBuilder AddCompanionImmortality(
        ActionsBuilder? actions = null,
        float? disappearDelay = null,
        PrefabLink? disappearFx = null,
        LocalizedString? fakeDeathMessage = null)
    {
      var component = new CompanionImmortality();
      component.Actions = actions?.Build() ?? component.Actions;
      if (component.Actions is null)
      {
        component.Actions = Utils.Constants.Empty.Actions;
      }
      component.DisappearDelay = disappearDelay ?? component.DisappearDelay;
      component.DisappearFx = disappearFx ?? component.DisappearFx;
      if (component.DisappearFx is null)
      {
        component.DisappearFx = Utils.Constants.Empty.PrefabLink;
      }
      component.FakeDeathMessage = fakeDeathMessage ?? component.FakeDeathMessage;
      if (component.FakeDeathMessage is null)
      {
        component.FakeDeathMessage = Utils.Constants.Empty.String;
      }
      return AddComponent(component);
    }

    /// <summary>
    /// Adds <see cref="CompleteDamageImmunity"/>
    /// </summary>
    ///
    /// <remarks>
    ///
    /// <list type="bullet">
    /// <listheader>Used by</listheader>
    /// <item><term>FighterPrecisePredictionBuff</term><description>b4692932777320045a605b4844a6e69b</description></item>
    /// <item><term>RangedLegerdemainUntargetable</term><description>5f632e786b68d8d4c8bb66275fc600a7</description></item>
    /// </list>
    /// </remarks>
    ///
    /// <param name="merge">
    /// If mergeBehavior is ComponentMerge.Merge and the component already exists, this expression is called to merge the components.
    /// </param>
    /// <param name="mergeBehavior">
    /// Handling if the component already exists since the component is unique. Defaults to ComponentMerge.Fail.
    /// </param>
    public TBuilder AddCompleteDamageImmunity(
        Action<BlueprintComponent, BlueprintComponent>? merge = null,
        ComponentMerge mergeBehavior = ComponentMerge.Merge)
    {
      var component = new CompleteDamageImmunity();
      return AddUniqueComponent(component, mergeBehavior, merge);
    }

    /// <summary>
    /// Adds <see cref="ConduitSurge"/>
    /// </summary>
    ///
    /// <remarks>
    ///
    /// <list type="bullet">
    /// <listheader>Used by</listheader>
    /// <item><term>LeyLineGuardianConduitSurgeBuff</term><description>4770ff0074ebb6246ab1d09b9b261103</description></item>
    /// </list>
    /// </remarks>
    ///
    /// <param name="buff">
    /// <para>
    /// Blueprint of type BlueprintBuff. You can pass in the blueprint using:
    /// <list type ="bullet">
    ///   <item><term>A blueprint instance</term></item>
    ///   <item><term>A blueprint reference</term></item>
    ///   <item><term>A blueprint id as a string, Guid, or BlueprintGuid</term></item>
    ///   <item><term>A blueprint name registered with <see cref="BlueprintCore.Utils.BlueprintTool">BlueprintTool</see></term></item>
    /// </list>
    /// See <see cref="BlueprintCore.Utils.Blueprint{{T, TRef}}">Blueprint</see> for more details.
    /// </para>
    /// </param>
    /// <param name="merge">
    /// If mergeBehavior is ComponentMerge.Merge and the component already exists, this expression is called to merge the components.
    /// </param>
    /// <param name="mergeBehavior">
    /// Handling if the component already exists since the component is unique. Defaults to ComponentMerge.Fail.
    /// </param>
    public TBuilder AddConduitSurge(
        Blueprint<BlueprintBuff, BlueprintBuffReference>? buff = null,
        Action<BlueprintComponent, BlueprintComponent>? merge = null,
        ComponentMerge mergeBehavior = ComponentMerge.Merge,
        ContextValue? value = null)
    {
      var component = new ConduitSurge();
      component.m_Buff = buff?.Reference ?? component.m_Buff;
      if (component.m_Buff is null)
      {
        component.m_Buff = BlueprintTool.GetRef<BlueprintBuffReference>(null);
      }
      component.Value = value ?? component.Value;
      if (component.Value is null)
      {
        component.Value = ContextValues.Constant(0);
      }
      return AddUniqueComponent(component, mergeBehavior, merge);
    }

    /// <summary>
    /// Adds <see cref="DeflectArrows"/>
    /// </summary>
    ///
    /// <remarks>
    ///
    /// <list type="bullet">
    /// <listheader>Used by</listheader>
    /// <item><term>ArrowDeflectionFeature</term><description>b23dbc39553f0434792dadc741521e4b</description></item>
    /// <item><term>DuelistDeflectArrows</term><description>c44158612f496fc4b863a0a7691401e3</description></item>
    /// <item><term>RageDeflectArrowsBuff</term><description>6b19f5aaca52493faf8ced3d344f32c1</description></item>
    /// </list>
    /// </remarks>
    public TBuilder AddDeflectArrows(
        DeflectArrows.RestrictionType? restriction = null)
    {
      var component = new DeflectArrows();
      component.m_Restriction = restriction ?? component.m_Restriction;
      return AddComponent(component);
    }

    /// <summary>
    /// Adds <see cref="DisableClassAdditionalVisualSettings"/>
    /// </summary>
    ///
    /// <remarks>
    ///
    /// <list type="bullet">
    /// <listheader>Used by</listheader>
    /// <item><term>FakeLegendFeature</term><description>63dbc00439ff894489a624abaa8ba79c</description></item>
    /// <item><term>LegendFeature</term><description>7f99961610390044391f300c7ef5e0c8</description></item>
    /// </list>
    /// </remarks>
    public TBuilder AddDisableClassAdditionalVisualSettings()
    {
      return AddComponent(new DisableClassAdditionalVisualSettings());
    }

    /// <summary>
    /// Adds <see cref="DisableEquipmentSlot"/>
    /// </summary>
    ///
    /// <remarks>
    ///
    /// <list type="bullet">
    /// <listheader>Used by</listheader>
    /// <item><term>DemodandTarry_Buff_Adhesion</term><description>7f34a6d3681966f41a518adf1b5b2a88</description></item>
    /// <item><term>DisarmOffHandBuff</term><description>afb1ea46a8c41e04eaab833b7b1b9321</description></item>
    /// <item><term>SunderArmorBuff</term><description>f508d20a350acb34db6293f5654f0b24</description></item>
    /// </list>
    /// </remarks>
    public TBuilder AddDisableEquipmentSlot(
        DisableEquipmentSlot.SlotType? slotType = null)
    {
      var component = new DisableEquipmentSlot();
      component.m_SlotType = slotType ?? component.m_SlotType;
      return AddComponent(component);
    }

    /// <summary>
    /// Adds <see cref="DuelistParry"/>
    /// </summary>
    ///
    /// <remarks>
    ///
    /// <list type="bullet">
    /// <listheader>Used by</listheader>
    /// <item><term>ArmyMeleeParry</term><description>2161643b2d3995e45964bd1030392dd7</description></item>
    /// <item><term>DuelistParryOthersBuffEachRound</term><description>24d410e30873fc54aa45c4712ff76e72</description></item>
    /// <item><term>DuelistParrySelfBuffEachRound</term><description>4c535eb8ce7b4f040a1e62a497a7d3b9</description></item>
    /// </list>
    /// </remarks>
    ///
    /// <param name="cloakFact">
    /// <para>
    /// InfoBox: Changes the mechanic if the White Wind Cloak is equipped by a Duelist
    /// </para>
    /// <para>
    /// Blueprint of type BlueprintUnitFact. You can pass in the blueprint using:
    /// <list type ="bullet">
    ///   <item><term>A blueprint instance</term></item>
    ///   <item><term>A blueprint reference</term></item>
    ///   <item><term>A blueprint id as a string, Guid, or BlueprintGuid</term></item>
    ///   <item><term>A blueprint name registered with <see cref="BlueprintCore.Utils.BlueprintTool">BlueprintTool</see></term></item>
    /// </list>
    /// See <see cref="BlueprintCore.Utils.Blueprint{{T, TRef}}">Blueprint</see> for more details.
    /// </para>
    /// </param>
    public TBuilder AddDuelistParry(
        ConditionsBuilder? attackerCondition = null,
        Blueprint<BlueprintUnitFact, BlueprintUnitFactReference>? cloakFact = null,
        DuelistParry.TargetType? target = null)
    {
      var component = new DuelistParry();
      component.AttackerCondition = attackerCondition?.Build() ?? component.AttackerCondition;
      if (component.AttackerCondition is null)
      {
        component.AttackerCondition = Utils.Constants.Empty.Conditions;
      }
      component.m_CloakFact = cloakFact?.Reference ?? component.m_CloakFact;
      if (component.m_CloakFact is null)
      {
        component.m_CloakFact = BlueprintTool.GetRef<BlueprintUnitFactReference>(null);
      }
      component.m_Target = target ?? component.m_Target;
      return AddComponent(component);
    }

    /// <summary>
    /// Adds <see cref="DweomerLeapLogic"/>
    /// </summary>
    ///
    /// <remarks>
    ///
    /// <list type="bullet">
    /// <listheader>Used by</listheader>
    /// <item><term>AnomalyTemplateDefensive_AnomalyShiftBuff</term><description>57d6d4fd4bc342faac72b8db009a13c8</description></item>
    /// <item><term>DweomercatDweomerleapLogic</term><description>7da86cf7330eac346b0cf71a8cb1884f</description></item>
    /// </list>
    /// </remarks>
    ///
    /// <param name="ability">
    /// <para>
    /// Blueprint of type BlueprintAbility. You can pass in the blueprint using:
    /// <list type ="bullet">
    ///   <item><term>A blueprint instance</term></item>
    ///   <item><term>A blueprint reference</term></item>
    ///   <item><term>A blueprint id as a string, Guid, or BlueprintGuid</term></item>
    ///   <item><term>A blueprint name registered with <see cref="BlueprintCore.Utils.BlueprintTool">BlueprintTool</see></term></item>
    /// </list>
    /// See <see cref="BlueprintCore.Utils.Blueprint{{T, TRef}}">Blueprint</see> for more details.
    /// </para>
    /// </param>
    public TBuilder AddDweomerLeapLogic(
        Blueprint<BlueprintAbility, BlueprintAbilityReference>? ability = null)
    {
      var component = new DweomerLeapLogic();
      component.m_Ability = ability?.Reference ?? component.m_Ability;
      if (component.m_Ability is null)
      {
        component.m_Ability = BlueprintTool.GetRef<BlueprintAbilityReference>(null);
      }
      return AddComponent(component);
    }

    /// <summary>
    /// Adds <see cref="EnhancePotion"/>
    /// </summary>
    ///
    /// <remarks>
    ///
    /// <list type="bullet">
    /// <listheader>Used by</listheader>
    /// <item><term>CauldromWitchEnhancePotion</term><description>621268fc9361a714d9713dcb8353eae3</description></item>
    /// <item><term>EnhancePotion</term><description>2673ccdd6df742d42a8c94977c76a984</description></item>
    /// </list>
    /// </remarks>
    ///
    /// <param name="archetypes">
    /// <para>
    /// Blueprint of type BlueprintArchetype. You can pass in the blueprint using:
    /// <list type ="bullet">
    ///   <item><term>A blueprint instance</term></item>
    ///   <item><term>A blueprint reference</term></item>
    ///   <item><term>A blueprint id as a string, Guid, or BlueprintGuid</term></item>
    ///   <item><term>A blueprint name registered with <see cref="BlueprintCore.Utils.BlueprintTool">BlueprintTool</see></term></item>
    /// </list>
    /// See <see cref="BlueprintCore.Utils.Blueprint{{T, TRef}}">Blueprint</see> for more details.
    /// </para>
    /// </param>
    /// <param name="classes">
    /// <para>
    /// Blueprint of type BlueprintCharacterClass. You can pass in the blueprint using:
    /// <list type ="bullet">
    ///   <item><term>A blueprint instance</term></item>
    ///   <item><term>A blueprint reference</term></item>
    ///   <item><term>A blueprint id as a string, Guid, or BlueprintGuid</term></item>
    ///   <item><term>A blueprint name registered with <see cref="BlueprintCore.Utils.BlueprintTool">BlueprintTool</see></term></item>
    /// </list>
    /// See <see cref="BlueprintCore.Utils.Blueprint{{T, TRef}}">Blueprint</see> for more details.
    /// </para>
    /// </param>
    public TBuilder AddEnhancePotion(
        List<Blueprint<BlueprintArchetype, BlueprintArchetypeReference>>? archetypes = null,
        List<Blueprint<BlueprintCharacterClass, BlueprintCharacterClassReference>>? classes = null)
    {
      var component = new EnhancePotion();
      component.m_Archetypes = archetypes?.Select(bp => bp.Reference)?.ToArray() ?? component.m_Archetypes;
      if (component.m_Archetypes is null)
      {
        component.m_Archetypes = new BlueprintArchetypeReference[0];
      }
      component.m_Classes = classes?.Select(bp => bp.Reference)?.ToArray() ?? component.m_Classes;
      if (component.m_Classes is null)
      {
        component.m_Classes = new BlueprintCharacterClassReference[0];
      }
      return AddComponent(component);
    }

    /// <summary>
    /// Adds <see cref="FastBombs"/>
    /// </summary>
    ///
    /// <remarks>
    ///
    /// <list type="bullet">
    /// <listheader>Used by</listheader>
    /// <item><term>FastBombsBuff</term><description>c42ae8f9652bbc14eb13b31d12d20f8a</description></item>
    /// </list>
    /// </remarks>
    ///
    /// <param name="abilities">
    /// <para>
    /// Blueprint of type BlueprintAbility. You can pass in the blueprint using:
    /// <list type ="bullet">
    ///   <item><term>A blueprint instance</term></item>
    ///   <item><term>A blueprint reference</term></item>
    ///   <item><term>A blueprint id as a string, Guid, or BlueprintGuid</term></item>
    ///   <item><term>A blueprint name registered with <see cref="BlueprintCore.Utils.BlueprintTool">BlueprintTool</see></term></item>
    /// </list>
    /// See <see cref="BlueprintCore.Utils.Blueprint{{T, TRef}}">Blueprint</see> for more details.
    /// </para>
    /// </param>
    public TBuilder AddFastBombs(
        List<Blueprint<BlueprintAbility, BlueprintAbilityReference>>? abilities = null)
    {
      var component = new FastBombs();
      component.m_Abilities = abilities?.Select(bp => bp.Reference)?.ToArray() ?? component.m_Abilities;
      if (component.m_Abilities is null)
      {
        component.m_Abilities = new BlueprintAbilityReference[0];
      }
      return AddComponent(component);
    }

    /// <summary>
    /// Adds <see cref="FavoredEnemy"/>
    /// </summary>
    ///
    /// <remarks>
    ///
    /// <list type="bullet">
    /// <listheader>Used by</listheader>
    /// <item><term>FavoriteEnemyAberrations</term><description>7081934ab5f8573429dbd26522adcc39</description></item>
    /// <item><term>FavoriteEnemyGnome</term><description>04314be4be2b7f444883ca8caf78a8a8</description></item>
    /// <item><term>FavoriteEnemyVermin</term><description>f6dac9009747b91408644fa834dd0d99</description></item>
    /// </list>
    /// </remarks>
    ///
    /// <param name="checkedFacts">
    /// <para>
    /// Blueprint of type BlueprintUnitFact. You can pass in the blueprint using:
    /// <list type ="bullet">
    ///   <item><term>A blueprint instance</term></item>
    ///   <item><term>A blueprint reference</term></item>
    ///   <item><term>A blueprint id as a string, Guid, or BlueprintGuid</term></item>
    ///   <item><term>A blueprint name registered with <see cref="BlueprintCore.Utils.BlueprintTool">BlueprintTool</see></term></item>
    /// </list>
    /// See <see cref="BlueprintCore.Utils.Blueprint{{T, TRef}}">Blueprint</see> for more details.
    /// </para>
    /// </param>
    public TBuilder AddFavoredEnemy(
        List<Blueprint<BlueprintUnitFact, BlueprintUnitFactReference>>? checkedFacts = null)
    {
      var component = new FavoredEnemy();
      component.m_CheckedFacts = checkedFacts?.Select(bp => bp.Reference)?.ToArray() ?? component.m_CheckedFacts;
      if (component.m_CheckedFacts is null)
      {
        component.m_CheckedFacts = new BlueprintUnitFactReference[0];
      }
      return AddComponent(component);
    }

    /// <summary>
    /// Adds <see cref="FavoredTerrain"/>
    /// </summary>
    ///
    /// <remarks>
    ///
    /// <list type="bullet">
    /// <listheader>Used by</listheader>
    /// <item><term>FavoriteTerrainAbyss</term><description>b3f10ef830d9fc44eab628ca1c1ed4fb</description></item>
    /// <item><term>FavoriteTerrainHighlands</term><description>8dc89bc3543a8724895477cd1472f591</description></item>
    /// <item><term>FavoriteTerrainUrban</term><description>515cafe9efb8e1c48be3d6ec41bc23ef</description></item>
    /// </list>
    /// </remarks>
    ///
    /// <param name="merge">
    /// If mergeBehavior is ComponentMerge.Merge and the component already exists, this expression is called to merge the components.
    /// </param>
    /// <param name="mergeBehavior">
    /// Handling if the component already exists since the component is unique. Defaults to ComponentMerge.Fail.
    /// </param>
    public TBuilder AddFavoredTerrain(
        Action<BlueprintComponent, BlueprintComponent>? merge = null,
        ComponentMerge mergeBehavior = ComponentMerge.Merge,
        AreaSetting? setting = null)
    {
      var component = new FavoredTerrain();
      component.Setting = setting ?? component.Setting;
      return AddUniqueComponent(component, mergeBehavior, merge);
    }

    /// <summary>
    /// Adds <see cref="FavoredTerrainExpertise"/>
    /// </summary>
    ///
    /// <remarks>
    ///
    /// <list type="bullet">
    /// <listheader>Used by</listheader>
    /// <item><term>TerrainExpertiseAbyss</term><description>c0fdbea534083554ab79f5654e4d2032</description></item>
    /// <item><term>TerrainExpertiseHighlands</term><description>3dc48f3b99dae6d41a0f533a02a2a6b2</description></item>
    /// <item><term>TerrainExpertiseUrban</term><description>6e21a09a954950745a7691f6a42ec355</description></item>
    /// </list>
    /// </remarks>
    public TBuilder AddFavoredTerrainExpertise(
        AreaSetting? setting = null)
    {
      var component = new FavoredTerrainExpertise();
      component.Setting = setting ?? component.Setting;
      return AddComponent(component);
    }

    /// <summary>
    /// Adds <see cref="ForbidRotation"/>
    /// </summary>
    ///
    /// <remarks>
    ///
    /// <list type="bullet">
    /// <listheader>Used by</listheader>
    /// <item><term>CarnivorousCrystal_Buff_PolymorphRoot</term><description>801e2cdccd9c031498ed198bc93bfa98</description></item>
    /// <item><term>MimicPolymorphRootBuff</term><description>4dc3906d92f614a49a913bd682a055ef</description></item>
    /// <item><term>Valmallos_Buff_ProtectiveDome</term><description>ac10126afb1e4769b291c8f122d54881</description></item>
    /// </list>
    /// </remarks>
    public TBuilder AddForbidRotation()
    {
      return AddComponent(new ForbidRotation());
    }

    /// <summary>
    /// Adds <see cref="ForbidSpecificSpellsCast"/>
    /// </summary>
    ///
    /// <remarks>
    ///
    /// <list type="bullet">
    /// <listheader>Used by</listheader>
    /// <item><term>DLC1_DimensionLock_Buff</term><description>6e339c2bc7ea488c9b655b029984405d</description></item>
    /// <item><term>MidnightFane_DimensionLock_Buff</term><description>4b0cd08a3cea2844dba9889c1d34d667</description></item>
    /// <item><term>SwordofValorEffectBuff</term><description>f10145ae0837a0c4f97d8a320e2bf2e1</description></item>
    /// </list>
    /// </remarks>
    ///
    /// <param name="spells">
    /// <para>
    /// Blueprint of type BlueprintAbility. You can pass in the blueprint using:
    /// <list type ="bullet">
    ///   <item><term>A blueprint instance</term></item>
    ///   <item><term>A blueprint reference</term></item>
    ///   <item><term>A blueprint id as a string, Guid, or BlueprintGuid</term></item>
    ///   <item><term>A blueprint name registered with <see cref="BlueprintCore.Utils.BlueprintTool">BlueprintTool</see></term></item>
    /// </list>
    /// See <see cref="BlueprintCore.Utils.Blueprint{{T, TRef}}">Blueprint</see> for more details.
    /// </para>
    /// </param>
    public TBuilder AddForbidSpecificSpellsCast(
        ActionsBuilder? onForbiddenCastAttempt = null,
        SpellDescriptorWrapper? spellDescriptor = null,
        List<Blueprint<BlueprintAbility, BlueprintAbilityReference>>? spells = null,
        bool? useSpellDescriptor = null)
    {
      var component = new ForbidSpecificSpellsCast();
      component.OnForbiddenCastAttempt = onForbiddenCastAttempt?.Build() ?? component.OnForbiddenCastAttempt;
      if (component.OnForbiddenCastAttempt is null)
      {
        component.OnForbiddenCastAttempt = Utils.Constants.Empty.Actions;
      }
      component.SpellDescriptor = spellDescriptor ?? component.SpellDescriptor;
      component.m_Spells = spells?.Select(bp => bp.Reference)?.ToArray() ?? component.m_Spells;
      if (component.m_Spells is null)
      {
        component.m_Spells = new BlueprintAbilityReference[0];
      }
      component.UseSpellDescriptor = useSpellDescriptor ?? component.UseSpellDescriptor;
      return AddComponent(component);
    }

    /// <summary>
    /// Adds <see cref="ForbidSpellCasting"/>
    /// </summary>
    ///
    /// <remarks>
    ///
    /// <list type="bullet">
    /// <listheader>Used by</listheader>
    /// <item><term>DeadlyMagicEffectBuff</term><description>f23c2a086af9ccd45b8d1903601b9a99</description></item>
    /// <item><term>InspiredRageEffectBuffBeforeMasterSkald</term><description>345d36cd45f5614409824209f26d0130</description></item>
    /// <item><term>VoidsKissShortswordBuff</term><description>9a0c3bd41a3247febae0a68e992c2194</description></item>
    /// </list>
    /// </remarks>
    ///
    /// <param name="ignoreFeature">
    /// <para>
    /// Blueprint of type BlueprintFeature. You can pass in the blueprint using:
    /// <list type ="bullet">
    ///   <item><term>A blueprint instance</term></item>
    ///   <item><term>A blueprint reference</term></item>
    ///   <item><term>A blueprint id as a string, Guid, or BlueprintGuid</term></item>
    ///   <item><term>A blueprint name registered with <see cref="BlueprintCore.Utils.BlueprintTool">BlueprintTool</see></term></item>
    /// </list>
    /// See <see cref="BlueprintCore.Utils.Blueprint{{T, TRef}}">Blueprint</see> for more details.
    /// </para>
    /// </param>
    public TBuilder AddForbidSpellCasting(
        bool? forbidMagicItems = null,
        Blueprint<BlueprintFeature, BlueprintFeatureReference>? ignoreFeature = null)
    {
      var component = new ForbidSpellCasting();
      component.ForbidMagicItems = forbidMagicItems ?? component.ForbidMagicItems;
      component.m_IgnoreFeature = ignoreFeature?.Reference ?? component.m_IgnoreFeature;
      if (component.m_IgnoreFeature is null)
      {
        component.m_IgnoreFeature = BlueprintTool.GetRef<BlueprintFeatureReference>(null);
      }
      return AddComponent(component);
    }

    /// <summary>
    /// Adds <see cref="ForbidSpellbookOnAlignmentDeviation"/>
    /// </summary>
    ///
    /// <remarks>
    ///
    /// <list type="bullet">
    /// <listheader>Used by</listheader>
    /// <item><term>AbadarFeature</term><description>6122dacf418611540a3c91e67197ee4e</description></item>
    /// <item><term>IomedaeFeature</term><description>88d5da04361b16746bf5b65795e0c38c</description></item>
    /// <item><term>ZonKuthonFeature</term><description>f7eed400baa66a744ad361d4df0e6f1b</description></item>
    /// </list>
    /// </remarks>
    ///
    /// <param name="ignoreFact">
    /// <para>
    /// Blueprint of type BlueprintUnitFact. You can pass in the blueprint using:
    /// <list type ="bullet">
    ///   <item><term>A blueprint instance</term></item>
    ///   <item><term>A blueprint reference</term></item>
    ///   <item><term>A blueprint id as a string, Guid, or BlueprintGuid</term></item>
    ///   <item><term>A blueprint name registered with <see cref="BlueprintCore.Utils.BlueprintTool">BlueprintTool</see></term></item>
    /// </list>
    /// See <see cref="BlueprintCore.Utils.Blueprint{{T, TRef}}">Blueprint</see> for more details.
    /// </para>
    /// </param>
    /// <param name="merge">
    /// If mergeBehavior is ComponentMerge.Merge and the component already exists, this expression is called to merge the components.
    /// </param>
    /// <param name="mergeBehavior">
    /// Handling if the component already exists since the component is unique. Defaults to ComponentMerge.Fail.
    /// </param>
    /// <param name="spellbooks">
    /// <para>
    /// Blueprint of type BlueprintSpellbook. You can pass in the blueprint using:
    /// <list type ="bullet">
    ///   <item><term>A blueprint instance</term></item>
    ///   <item><term>A blueprint reference</term></item>
    ///   <item><term>A blueprint id as a string, Guid, or BlueprintGuid</term></item>
    ///   <item><term>A blueprint name registered with <see cref="BlueprintCore.Utils.BlueprintTool">BlueprintTool</see></term></item>
    /// </list>
    /// See <see cref="BlueprintCore.Utils.Blueprint{{T, TRef}}">Blueprint</see> for more details.
    /// </para>
    /// </param>
    public TBuilder AddForbidSpellbookOnAlignmentDeviation(
        AlignmentMaskType? alignment = null,
        Blueprint<BlueprintUnitFact, BlueprintUnitFactReference>? ignoreFact = null,
        Action<BlueprintComponent, BlueprintComponent>? merge = null,
        ComponentMerge mergeBehavior = ComponentMerge.Merge,
        List<Blueprint<BlueprintSpellbook, BlueprintSpellbookReference>>? spellbooks = null)
    {
      var component = new ForbidSpellbookOnAlignmentDeviation();
      component.Alignment = alignment ?? component.Alignment;
      component.m_IgnoreFact = ignoreFact?.Reference ?? component.m_IgnoreFact;
      if (component.m_IgnoreFact is null)
      {
        component.m_IgnoreFact = BlueprintTool.GetRef<BlueprintUnitFactReference>(null);
      }
      component.m_Spellbooks = spellbooks?.Select(bp => bp.Reference)?.ToArray() ?? component.m_Spellbooks;
      if (component.m_Spellbooks is null)
      {
        component.m_Spellbooks = new BlueprintSpellbookReference[0];
      }
      return AddUniqueComponent(component, mergeBehavior, merge);
    }

    /// <summary>
    /// Adds <see cref="ForbidSpellbookOnArmorEquip"/>
    /// </summary>
    ///
    /// <remarks>
    ///
    /// <list type="bullet">
    /// <listheader>Used by</listheader>
    /// <item><term>EcclesitheurgeRestriction</term><description>82fa26ea2b628e44a8fc35c248831890</description></item>
    /// </list>
    /// </remarks>
    ///
    /// <param name="merge">
    /// If mergeBehavior is ComponentMerge.Merge and the component already exists, this expression is called to merge the components.
    /// </param>
    /// <param name="mergeBehavior">
    /// Handling if the component already exists since the component is unique. Defaults to ComponentMerge.Fail.
    /// </param>
    /// <param name="spellbooks">
    /// <para>
    /// Blueprint of type BlueprintSpellbook. You can pass in the blueprint using:
    /// <list type ="bullet">
    ///   <item><term>A blueprint instance</term></item>
    ///   <item><term>A blueprint reference</term></item>
    ///   <item><term>A blueprint id as a string, Guid, or BlueprintGuid</term></item>
    ///   <item><term>A blueprint name registered with <see cref="BlueprintCore.Utils.BlueprintTool">BlueprintTool</see></term></item>
    /// </list>
    /// See <see cref="BlueprintCore.Utils.Blueprint{{T, TRef}}">Blueprint</see> for more details.
    /// </para>
    /// </param>
    public TBuilder AddForbidSpellbookOnArmorEquip(
        Action<BlueprintComponent, BlueprintComponent>? merge = null,
        ComponentMerge mergeBehavior = ComponentMerge.Merge,
        List<Blueprint<BlueprintSpellbook, BlueprintSpellbookReference>>? spellbooks = null)
    {
      var component = new ForbidSpellbookOnArmorEquip();
      component.m_Spellbooks = spellbooks?.Select(bp => bp.Reference)?.ToArray() ?? component.m_Spellbooks;
      if (component.m_Spellbooks is null)
      {
        component.m_Spellbooks = new BlueprintSpellbookReference[0];
      }
      return AddUniqueComponent(component, mergeBehavior, merge);
    }

    /// <summary>
    /// Adds <see cref="FreeActionSpell"/>
    /// </summary>
    ///
    /// <remarks>
    ///
    /// <list type="bullet">
    /// <listheader>Used by</listheader>
    /// <item><term>ImprovedQuarry</term><description>25e009b7e53f86141adee3a1213af5af</description></item>
    /// </list>
    /// </remarks>
    ///
    /// <param name="ability">
    /// <para>
    /// Blueprint of type BlueprintAbility. You can pass in the blueprint using:
    /// <list type ="bullet">
    ///   <item><term>A blueprint instance</term></item>
    ///   <item><term>A blueprint reference</term></item>
    ///   <item><term>A blueprint id as a string, Guid, or BlueprintGuid</term></item>
    ///   <item><term>A blueprint name registered with <see cref="BlueprintCore.Utils.BlueprintTool">BlueprintTool</see></term></item>
    /// </list>
    /// See <see cref="BlueprintCore.Utils.Blueprint{{T, TRef}}">Blueprint</see> for more details.
    /// </para>
    /// </param>
    public TBuilder AddFreeActionSpell(
        Blueprint<BlueprintAbility, BlueprintAbilityReference>? ability = null)
    {
      var component = new FreeActionSpell();
      component.m_Ability = ability?.Reference ?? component.m_Ability;
      if (component.m_Ability is null)
      {
        component.m_Ability = BlueprintTool.GetRef<BlueprintAbilityReference>(null);
      }
      return AddComponent(component);
    }

    /// <summary>
    /// Adds <see cref="GentlePersuasionConditioning"/>
    /// </summary>
    ///
    /// <remarks>
    ///
    /// <list type="bullet">
    /// <listheader>Used by</listheader>
    /// <item><term>GentlePersuasionFeature</term><description>90639fbe91016ed4893d434e68f6b466</description></item>
    /// </list>
    /// </remarks>
    ///
    /// <param name="merge">
    /// If mergeBehavior is ComponentMerge.Merge and the component already exists, this expression is called to merge the components.
    /// </param>
    /// <param name="mergeBehavior">
    /// Handling if the component already exists since the component is unique. Defaults to ComponentMerge.Fail.
    /// </param>
    /// <param name="punishmentBuff">
    /// <para>
    /// Blueprint of type BlueprintBuff. You can pass in the blueprint using:
    /// <list type ="bullet">
    ///   <item><term>A blueprint instance</term></item>
    ///   <item><term>A blueprint reference</term></item>
    ///   <item><term>A blueprint id as a string, Guid, or BlueprintGuid</term></item>
    ///   <item><term>A blueprint name registered with <see cref="BlueprintCore.Utils.BlueprintTool">BlueprintTool</see></term></item>
    /// </list>
    /// See <see cref="BlueprintCore.Utils.Blueprint{{T, TRef}}">Blueprint</see> for more details.
    /// </para>
    /// </param>
    /// <param name="rewardBuff">
    /// <para>
    /// Blueprint of type BlueprintBuff. You can pass in the blueprint using:
    /// <list type ="bullet">
    ///   <item><term>A blueprint instance</term></item>
    ///   <item><term>A blueprint reference</term></item>
    ///   <item><term>A blueprint id as a string, Guid, or BlueprintGuid</term></item>
    ///   <item><term>A blueprint name registered with <see cref="BlueprintCore.Utils.BlueprintTool">BlueprintTool</see></term></item>
    /// </list>
    /// See <see cref="BlueprintCore.Utils.Blueprint{{T, TRef}}">Blueprint</see> for more details.
    /// </para>
    /// </param>
    public TBuilder AddGentlePersuasionConditioning(
        Action<BlueprintComponent, BlueprintComponent>? merge = null,
        ComponentMerge mergeBehavior = ComponentMerge.Merge,
        Blueprint<BlueprintBuff, BlueprintBuffReference>? punishmentBuff = null,
        Blueprint<BlueprintBuff, BlueprintBuffReference>? rewardBuff = null)
    {
      var component = new GentlePersuasionConditioning();
      component.m_PunishmentBuff = punishmentBuff?.Reference ?? component.m_PunishmentBuff;
      if (component.m_PunishmentBuff is null)
      {
        component.m_PunishmentBuff = BlueprintTool.GetRef<BlueprintBuffReference>(null);
      }
      component.m_RewardBuff = rewardBuff?.Reference ?? component.m_RewardBuff;
      if (component.m_RewardBuff is null)
      {
        component.m_RewardBuff = BlueprintTool.GetRef<BlueprintBuffReference>(null);
      }
      return AddUniqueComponent(component, mergeBehavior, merge);
    }

    /// <summary>
    /// Adds <see cref="GhostCriticalAndPrecisionImmunity"/>
    /// </summary>
    ///
    /// <remarks>
    ///
    /// <list type="bullet">
    /// <listheader>Used by</listheader>
    /// <item><term>Incorporeal</term><description>c4a7f98d743bc784c9d4cf2105852c39</description></item>
    /// </list>
    /// </remarks>
    public TBuilder AddGhostCriticalAndPrecisionImmunity()
    {
      return AddComponent(new GhostCriticalAndPrecisionImmunity());
    }

    /// <summary>
    /// Adds <see cref="GreaterCombatMeneuver"/>
    /// </summary>
    ///
    /// <remarks>
    ///
    /// <list type="bullet">
    /// <listheader>Used by</listheader>
    /// <item><term>GreaterBullRush</term><description>72ba6ad46d94ecd41bad8e64739ea392</description></item>
    /// </list>
    /// </remarks>
    public TBuilder AddGreaterCombatMeneuver(
        CombatManeuver? maneuver = null)
    {
      var component = new GreaterCombatMeneuver();
      component.Maneuver = maneuver ?? component.Maneuver;
      return AddComponent(component);
    }

    /// <summary>
    /// Adds <see cref="HalveIncomingAreaDamage"/>
    /// </summary>
    ///
    /// <remarks>
    ///
    /// <list type="bullet">
    /// <listheader>Used by</listheader>
    /// <item><term>SupersonicSpeedFeature</term><description>505456aa17dd18a4e8bd8172811a4fdc</description></item>
    /// </list>
    /// </remarks>
    public TBuilder AddHalveIncomingAreaDamage()
    {
      return AddComponent(new HalveIncomingAreaDamage());
    }

    /// <summary>
    /// Adds <see cref="HideFactsWhileEtudePlaying"/>
    /// </summary>
    ///
    /// <remarks>
    ///
    /// <list type="bullet">
    /// <listheader>Used by</listheader>
    /// <item><term>DLC1_Nenio_Companion</term><description>5642e394eac9447e819646723ffa25a3</description></item>
    /// <item><term>NenioTestLevel14</term><description>938bfee6b9fab804f973539260a1ed37</description></item>
    /// <item><term>NenioTestLevel19</term><description>b8366f6c59f84672b699878296f81f72</description></item>
    /// </list>
    /// </remarks>
    ///
    /// <param name="etude">
    /// <para>
    /// Blueprint of type BlueprintEtude. You can pass in the blueprint using:
    /// <list type ="bullet">
    ///   <item><term>A blueprint instance</term></item>
    ///   <item><term>A blueprint reference</term></item>
    ///   <item><term>A blueprint id as a string, Guid, or BlueprintGuid</term></item>
    ///   <item><term>A blueprint name registered with <see cref="BlueprintCore.Utils.BlueprintTool">BlueprintTool</see></term></item>
    /// </list>
    /// See <see cref="BlueprintCore.Utils.Blueprint{{T, TRef}}">Blueprint</see> for more details.
    /// </para>
    /// </param>
    /// <param name="facts">
    /// <para>
    /// Blueprint of type BlueprintUnitFact. You can pass in the blueprint using:
    /// <list type ="bullet">
    ///   <item><term>A blueprint instance</term></item>
    ///   <item><term>A blueprint reference</term></item>
    ///   <item><term>A blueprint id as a string, Guid, or BlueprintGuid</term></item>
    ///   <item><term>A blueprint name registered with <see cref="BlueprintCore.Utils.BlueprintTool">BlueprintTool</see></term></item>
    /// </list>
    /// See <see cref="BlueprintCore.Utils.Blueprint{{T, TRef}}">Blueprint</see> for more details.
    /// </para>
    /// </param>
    /// <param name="replaceRace">
    /// <para>
    /// Blueprint of type BlueprintRace. You can pass in the blueprint using:
    /// <list type ="bullet">
    ///   <item><term>A blueprint instance</term></item>
    ///   <item><term>A blueprint reference</term></item>
    ///   <item><term>A blueprint id as a string, Guid, or BlueprintGuid</term></item>
    ///   <item><term>A blueprint name registered with <see cref="BlueprintCore.Utils.BlueprintTool">BlueprintTool</see></term></item>
    /// </list>
    /// See <see cref="BlueprintCore.Utils.Blueprint{{T, TRef}}">Blueprint</see> for more details.
    /// </para>
    /// </param>
    public TBuilder AddHideFactsWhileEtudePlaying(
        HashSet<BlueprintUnitFact>? cachedFacts = null,
        Blueprint<BlueprintEtude, BlueprintEtudeReference>? etude = null,
        List<Blueprint<BlueprintUnitFact, BlueprintUnitFactReference>>? facts = null,
        Blueprint<BlueprintRace, BlueprintRaceReference>? replaceRace = null)
    {
      var component = new HideFactsWhileEtudePlaying();
      foreach (var item in cachedFacts) { Validate(item); }
      component.m_CachedFacts = cachedFacts ?? component.m_CachedFacts;
      if (component.m_CachedFacts is null)
      {
        component.m_CachedFacts = new();
      }
      component.m_Etude = etude?.Reference ?? component.m_Etude;
      if (component.m_Etude is null)
      {
        component.m_Etude = BlueprintTool.GetRef<BlueprintEtudeReference>(null);
      }
      component.m_Facts = facts?.Select(bp => bp.Reference)?.ToArray() ?? component.m_Facts;
      if (component.m_Facts is null)
      {
        component.m_Facts = new BlueprintUnitFactReference[0];
      }
      component.m_ReplaceRace = replaceRace?.Reference ?? component.m_ReplaceRace;
      if (component.m_ReplaceRace is null)
      {
        component.m_ReplaceRace = BlueprintTool.GetRef<BlueprintRaceReference>(null);
      }
      return AddComponent(component);
    }

    /// <summary>
    /// Adds <see cref="HigherMythicsReplace"/>
    /// </summary>
    ///
    /// <remarks>
    ///
    /// <list type="bullet">
    /// <listheader>Used by</listheader>
    /// <item><term>HigherMythicReplaceFeature</term><description>5677a9beca6350b41b6bd94ff1284997</description></item>
    /// </list>
    /// </remarks>
    ///
    /// <param name="merge">
    /// If mergeBehavior is ComponentMerge.Merge and the component already exists, this expression is called to merge the components.
    /// </param>
    /// <param name="mergeBehavior">
    /// Handling if the component already exists since the component is unique. Defaults to ComponentMerge.Fail.
    /// </param>
    public TBuilder AddHigherMythicsReplace(
        Action<BlueprintComponent, BlueprintComponent>? merge = null,
        ComponentMerge mergeBehavior = ComponentMerge.Merge)
    {
      var component = new HigherMythicsReplace();
      return AddUniqueComponent(component, mergeBehavior, merge);
    }

    /// <summary>
    /// Adds <see cref="IgnoreIncommingDamage"/>
    /// </summary>
    ///
    /// <remarks>
    ///
    /// <list type="bullet">
    /// <listheader>Used by</listheader>
    /// <item><term>CheatImmortalityBuff</term><description>c3d503cfdab99a348a277752f2297155</description></item>
    /// <item><term>WalkingDeadImmortalityBuff</term><description>9c55730e682cb574ab2fbc4727517752</description></item>
    /// </list>
    /// </remarks>
    ///
    /// <param name="merge">
    /// If mergeBehavior is ComponentMerge.Merge and the component already exists, this expression is called to merge the components.
    /// </param>
    /// <param name="mergeBehavior">
    /// Handling if the component already exists since the component is unique. Defaults to ComponentMerge.Fail.
    /// </param>
    public TBuilder AddIgnoreIncommingDamage(
        Action<BlueprintComponent, BlueprintComponent>? merge = null,
        ComponentMerge mergeBehavior = ComponentMerge.Merge)
    {
      var component = new IgnoreIncommingDamage();
      return AddUniqueComponent(component, mergeBehavior, merge);
    }

    /// <summary>
    /// Adds <see cref="IgnoreSpellImmunity"/>
    /// </summary>
    ///
    /// <remarks>
    ///
    /// <list type="bullet">
    /// <listheader>Used by</listheader>
    /// <item><term>DeadlyMagicBuff</term><description>27ebfae71cce46045814eb3ba4fefa6b</description></item>
    /// </list>
    /// </remarks>
    public TBuilder AddIgnoreSpellImmunity(
        SpellDescriptorWrapper? spellDescriptor = null)
    {
      var component = new IgnoreSpellImmunity();
      component.SpellDescriptor = spellDescriptor ?? component.SpellDescriptor;
      return AddComponent(component);
    }

    /// <summary>
    /// Adds <see cref="IncorporealACBonus"/>
    /// </summary>
    ///
    /// <remarks>
    ///
    /// <para>
    /// ComponentName: Incorporeal AC Bonus
    /// </para>
    ///
    /// <list type="bullet">
    /// <listheader>Used by</listheader>
    /// <item><term>Incorporeal</term><description>c4a7f98d743bc784c9d4cf2105852c39</description></item>
    /// </list>
    /// </remarks>
    ///
    /// <param name="merge">
    /// If mergeBehavior is ComponentMerge.Merge and the component already exists, this expression is called to merge the components.
    /// </param>
    /// <param name="mergeBehavior">
    /// Handling if the component already exists since the component is unique. Defaults to ComponentMerge.Fail.
    /// </param>
    public TBuilder AddIncorporealACBonus(
        Action<BlueprintComponent, BlueprintComponent>? merge = null,
        ComponentMerge mergeBehavior = ComponentMerge.Merge)
    {
      var component = new IncorporealACBonus();
      return AddUniqueComponent(component, mergeBehavior, merge);
    }

    /// <summary>
    /// Adds <see cref="IncreaseActivatableAbilityGroupSize"/>
    /// </summary>
    ///
    /// <remarks>
    ///
    /// <list type="bullet">
    /// <listheader>Used by</listheader>
    /// <item><term>AeonGazeFeatureExtraGaze</term><description>9b3399bb6cea0044faa42cd61169cc29</description></item>
    /// <item><term>RingOfCircumstancesFeatureMoreAbilities</term><description>c5fb1d9df9517224c9ca65f4db11b75b</description></item>
    /// <item><term>WeaponBondPlus6</term><description>b936ee90c070edb46bd76025dc1c5936</description></item>
    /// </list>
    /// </remarks>
    ///
    /// <param name="merge">
    /// If mergeBehavior is ComponentMerge.Merge and the component already exists, this expression is called to merge the components.
    /// </param>
    /// <param name="mergeBehavior">
    /// Handling if the component already exists since the component is unique. Defaults to ComponentMerge.Fail.
    /// </param>
    public TBuilder AddIncreaseActivatableAbilityGroupSize(
        ActivatableAbilityGroup? group = null,
        Action<BlueprintComponent, BlueprintComponent>? merge = null,
        ComponentMerge mergeBehavior = ComponentMerge.Merge)
    {
      var component = new IncreaseActivatableAbilityGroupSize();
      component.Group = group ?? component.Group;
      return AddUniqueComponent(component, mergeBehavior, merge);
    }

    /// <summary>
    /// Adds <see cref="IncreaseResourceAmount"/>
    /// </summary>
    ///
    /// <remarks>
    ///
    /// <list type="bullet">
    /// <listheader>Used by</listheader>
    /// <item><term>AlchemicSourceAlchemistBuff</term><description>273df9b935cd61440a0e3a169b6b2307</description></item>
    /// <item><term>HeadbandOfRigorousTrainingFeature</term><description>6d8b7b79f146ad54aa9dae02e9512a48</description></item>
    /// <item><term>XavornsCrossFeature</term><description>35f473c44b5a94b42898be80f3248ca0</description></item>
    /// </list>
    /// </remarks>
    ///
    /// <param name="merge">
    /// If mergeBehavior is ComponentMerge.Merge and the component already exists, this expression is called to merge the components.
    /// </param>
    /// <param name="mergeBehavior">
    /// Handling if the component already exists since the component is unique. Defaults to ComponentMerge.Fail.
    /// </param>
    /// <param name="resource">
    /// <para>
    /// Blueprint of type BlueprintAbilityResource. You can pass in the blueprint using:
    /// <list type ="bullet">
    ///   <item><term>A blueprint instance</term></item>
    ///   <item><term>A blueprint reference</term></item>
    ///   <item><term>A blueprint id as a string, Guid, or BlueprintGuid</term></item>
    ///   <item><term>A blueprint name registered with <see cref="BlueprintCore.Utils.BlueprintTool">BlueprintTool</see></term></item>
    /// </list>
    /// See <see cref="BlueprintCore.Utils.Blueprint{{T, TRef}}">Blueprint</see> for more details.
    /// </para>
    /// </param>
    public TBuilder AddIncreaseResourceAmount(
        Action<BlueprintComponent, BlueprintComponent>? merge = null,
        ComponentMerge mergeBehavior = ComponentMerge.Merge,
        Blueprint<BlueprintAbilityResource, BlueprintAbilityResourceReference>? resource = null,
        int? value = null)
    {
      var component = new IncreaseResourceAmount();
      component.m_Resource = resource?.Reference ?? component.m_Resource;
      if (component.m_Resource is null)
      {
        component.m_Resource = BlueprintTool.GetRef<BlueprintAbilityResourceReference>(null);
      }
      component.Value = value ?? component.Value;
      return AddUniqueComponent(component, mergeBehavior, merge);
    }

    /// <summary>
    /// Adds <see cref="IncreaseResourceAmountBySharedValue"/>
    /// </summary>
    ///
    /// <remarks>
    ///
    /// <list type="bullet">
    /// <listheader>Used by</listheader>
    /// <item><term>AbundantArcanePool</term><description>8acebba92ada26043873cae5b92cef7b</description></item>
    /// <item><term>TricksterLoreReligionCharmDomainFeature</term><description>8c193c5267624ff388ab43c572622dbd</description></item>
    /// <item><term>TricksterLoreReligionWeatherDomainFeature</term><description>41947e0523ff4eae8236729551a40605</description></item>
    /// </list>
    /// </remarks>
    ///
    /// <param name="merge">
    /// If mergeBehavior is ComponentMerge.Merge and the component already exists, this expression is called to merge the components.
    /// </param>
    /// <param name="mergeBehavior">
    /// Handling if the component already exists since the component is unique. Defaults to ComponentMerge.Fail.
    /// </param>
    /// <param name="resource">
    /// <para>
    /// Blueprint of type BlueprintAbilityResource. You can pass in the blueprint using:
    /// <list type ="bullet">
    ///   <item><term>A blueprint instance</term></item>
    ///   <item><term>A blueprint reference</term></item>
    ///   <item><term>A blueprint id as a string, Guid, or BlueprintGuid</term></item>
    ///   <item><term>A blueprint name registered with <see cref="BlueprintCore.Utils.BlueprintTool">BlueprintTool</see></term></item>
    /// </list>
    /// See <see cref="BlueprintCore.Utils.Blueprint{{T, TRef}}">Blueprint</see> for more details.
    /// </para>
    /// </param>
    public TBuilder AddIncreaseResourceAmountBySharedValue(
        bool? decrease = null,
        Action<BlueprintComponent, BlueprintComponent>? merge = null,
        ComponentMerge mergeBehavior = ComponentMerge.Merge,
        Blueprint<BlueprintAbilityResource, BlueprintAbilityResourceReference>? resource = null,
        ContextValue? value = null)
    {
      var component = new IncreaseResourceAmountBySharedValue();
      component.Decrease = decrease ?? component.Decrease;
      component.m_Resource = resource?.Reference ?? component.m_Resource;
      if (component.m_Resource is null)
      {
        component.m_Resource = BlueprintTool.GetRef<BlueprintAbilityResourceReference>(null);
      }
      component.Value = value ?? component.Value;
      if (component.Value is null)
      {
        component.Value = ContextValues.Constant(0);
      }
      return AddUniqueComponent(component, mergeBehavior, merge);
    }

    /// <summary>
    /// Adds <see cref="IncreaseResourcesByClass"/>
    /// </summary>
    ///
    /// <remarks>
    ///
    /// <list type="bullet">
    /// <listheader>Used by</listheader>
    /// <item><term>AzataPerformanceResourceFeature</term><description>02c96331ed2d87d43a4a3509142678b8</description></item>
    /// <item><term>LichSkeletalBardIncreaseResourceFeature</term><description>b9601abf08bfe7f41b1b409c7bf420b6</description></item>
    /// <item><term>SenseiAdvice</term><description>aed2367e51118bf4c846dc118d72e153</description></item>
    /// </list>
    /// </remarks>
    ///
    /// <param name="archetype">
    /// <para>
    /// Blueprint of type BlueprintArchetype. You can pass in the blueprint using:
    /// <list type ="bullet">
    ///   <item><term>A blueprint instance</term></item>
    ///   <item><term>A blueprint reference</term></item>
    ///   <item><term>A blueprint id as a string, Guid, or BlueprintGuid</term></item>
    ///   <item><term>A blueprint name registered with <see cref="BlueprintCore.Utils.BlueprintTool">BlueprintTool</see></term></item>
    /// </list>
    /// See <see cref="BlueprintCore.Utils.Blueprint{{T, TRef}}">Blueprint</see> for more details.
    /// </para>
    /// </param>
    /// <param name="characterClass">
    /// <para>
    /// Blueprint of type BlueprintCharacterClass. You can pass in the blueprint using:
    /// <list type ="bullet">
    ///   <item><term>A blueprint instance</term></item>
    ///   <item><term>A blueprint reference</term></item>
    ///   <item><term>A blueprint id as a string, Guid, or BlueprintGuid</term></item>
    ///   <item><term>A blueprint name registered with <see cref="BlueprintCore.Utils.BlueprintTool">BlueprintTool</see></term></item>
    /// </list>
    /// See <see cref="BlueprintCore.Utils.Blueprint{{T, TRef}}">Blueprint</see> for more details.
    /// </para>
    /// </param>
    /// <param name="resource">
    /// <para>
    /// Blueprint of type BlueprintAbilityResource. You can pass in the blueprint using:
    /// <list type ="bullet">
    ///   <item><term>A blueprint instance</term></item>
    ///   <item><term>A blueprint reference</term></item>
    ///   <item><term>A blueprint id as a string, Guid, or BlueprintGuid</term></item>
    ///   <item><term>A blueprint name registered with <see cref="BlueprintCore.Utils.BlueprintTool">BlueprintTool</see></term></item>
    /// </list>
    /// See <see cref="BlueprintCore.Utils.Blueprint{{T, TRef}}">Blueprint</see> for more details.
    /// </para>
    /// </param>
    public TBuilder AddIncreaseResourcesByClass(
        Blueprint<BlueprintArchetype, BlueprintArchetypeReference>? archetype = null,
        int? baseValue = null,
        Blueprint<BlueprintCharacterClass, BlueprintCharacterClassReference>? characterClass = null,
        Blueprint<BlueprintAbilityResource, BlueprintAbilityResourceReference>? resource = null,
        StatType? stat = null)
    {
      var component = new IncreaseResourcesByClass();
      component.m_Archetype = archetype?.Reference ?? component.m_Archetype;
      if (component.m_Archetype is null)
      {
        component.m_Archetype = BlueprintTool.GetRef<BlueprintArchetypeReference>(null);
      }
      component.BaseValue = baseValue ?? component.BaseValue;
      component.m_CharacterClass = characterClass?.Reference ?? component.m_CharacterClass;
      if (component.m_CharacterClass is null)
      {
        component.m_CharacterClass = BlueprintTool.GetRef<BlueprintCharacterClassReference>(null);
      }
      component.m_Resource = resource?.Reference ?? component.m_Resource;
      if (component.m_Resource is null)
      {
        component.m_Resource = BlueprintTool.GetRef<BlueprintAbilityResourceReference>(null);
      }
      component.Stat = stat ?? component.Stat;
      return AddComponent(component);
    }

    /// <summary>
    /// Adds <see cref="InitiatorDisarmTrapTrigger"/>
    /// </summary>
    ///
    /// <remarks>
    ///
    /// <list type="bullet">
    /// <listheader>Used by</listheader>
    /// <item><term>SaboteurFeature</term><description>35c85e465cd044a9870054e8d78dbcb7</description></item>
    /// </list>
    /// </remarks>
    public TBuilder AddInitiatorDisarmTrapTrigger(
        ActionsBuilder? onDisarmFail = null,
        ActionsBuilder? onDisarmSuccess = null)
    {
      var component = new InitiatorDisarmTrapTrigger();
      component.OnDisarmFail = onDisarmFail?.Build() ?? component.OnDisarmFail;
      if (component.OnDisarmFail is null)
      {
        component.OnDisarmFail = Utils.Constants.Empty.Actions;
      }
      component.OnDisarmSuccess = onDisarmSuccess?.Build() ?? component.OnDisarmSuccess;
      if (component.OnDisarmSuccess is null)
      {
        component.OnDisarmSuccess = Utils.Constants.Empty.Actions;
      }
      return AddComponent(component);
    }

    /// <summary>
    /// Adds <see cref="InitiatorSavingThrowTrigger"/>
    /// </summary>
    ///
    /// <remarks>
    ///
    /// <list type="bullet">
    /// <listheader>Used by</listheader>
    /// <item><term>Artifact_TricksterCloakFeature</term><description>686fb5d5b4264e8d85f434efd9e7c5de</description></item>
    /// <item><term>DesertMirageFeature</term><description>49f8d20f6eb64348bd915ab4c5ce694d</description></item>
    /// </list>
    /// </remarks>
    public TBuilder AddInitiatorSavingThrowTrigger(
        ActionsBuilder? onFailedSave = null,
        ActionsBuilder? onSuccessfulSave = null)
    {
      var component = new InitiatorSavingThrowTrigger();
      component.OnFailedSave = onFailedSave?.Build() ?? component.OnFailedSave;
      if (component.OnFailedSave is null)
      {
        component.OnFailedSave = Utils.Constants.Empty.Actions;
      }
      component.OnSuccessfulSave = onSuccessfulSave?.Build() ?? component.OnSuccessfulSave;
      if (component.OnSuccessfulSave is null)
      {
        component.OnSuccessfulSave = Utils.Constants.Empty.Actions;
      }
      return AddComponent(component);
    }

    /// <summary>
    /// Adds <see cref="KeepAlliesAlive"/>
    /// </summary>
    ///
    /// <remarks>
    ///
    /// <list type="bullet">
    /// <listheader>Used by</listheader>
    /// <item><term>LifeBondingFriendshipFeature</term><description>5b63a6690ebbaa4459df3e04fe094cbd</description></item>
    /// </list>
    /// </remarks>
    ///
    /// <param name="walkingDeadBuff">
    /// <para>
    /// Blueprint of type BlueprintBuff. You can pass in the blueprint using:
    /// <list type ="bullet">
    ///   <item><term>A blueprint instance</term></item>
    ///   <item><term>A blueprint reference</term></item>
    ///   <item><term>A blueprint id as a string, Guid, or BlueprintGuid</term></item>
    ///   <item><term>A blueprint name registered with <see cref="BlueprintCore.Utils.BlueprintTool">BlueprintTool</see></term></item>
    /// </list>
    /// See <see cref="BlueprintCore.Utils.Blueprint{{T, TRef}}">Blueprint</see> for more details.
    /// </para>
    /// </param>
    public TBuilder AddKeepAlliesAlive(
        ContextValue? maxAttacksCount = null,
        Blueprint<BlueprintBuff, BlueprintBuffReference>? walkingDeadBuff = null)
    {
      var component = new KeepAlliesAlive();
      component.m_MaxAttacksCount = maxAttacksCount ?? component.m_MaxAttacksCount;
      if (component.m_MaxAttacksCount is null)
      {
        component.m_MaxAttacksCount = ContextValues.Constant(0);
      }
      component.WalkingDeadBuff = walkingDeadBuff?.Reference ?? component.WalkingDeadBuff;
      if (component.WalkingDeadBuff is null)
      {
        component.WalkingDeadBuff = BlueprintTool.GetRef<BlueprintBuffReference>(null);
      }
      return AddComponent(component);
    }

    /// <summary>
    /// Adds <see cref="LearnSpellList"/>
    /// </summary>
    ///
    /// <remarks>
    ///
    /// <list type="bullet">
    /// <listheader>Used by</listheader>
    /// <item><term>AirDomainProgression</term><description>750bfcd133cd52f42acbd4f7bc9cc365</description></item>
    /// <item><term>LawDomainProgression</term><description>a723d11a5ae5df0488775e31fac9117d</description></item>
    /// <item><term>WeatherDomainProgression</term><description>c18a821ee662db0439fb873165da25be</description></item>
    /// </list>
    /// </remarks>
    ///
    /// <param name="archetype">
    /// <para>
    /// Blueprint of type BlueprintArchetype. You can pass in the blueprint using:
    /// <list type ="bullet">
    ///   <item><term>A blueprint instance</term></item>
    ///   <item><term>A blueprint reference</term></item>
    ///   <item><term>A blueprint id as a string, Guid, or BlueprintGuid</term></item>
    ///   <item><term>A blueprint name registered with <see cref="BlueprintCore.Utils.BlueprintTool">BlueprintTool</see></term></item>
    /// </list>
    /// See <see cref="BlueprintCore.Utils.Blueprint{{T, TRef}}">Blueprint</see> for more details.
    /// </para>
    /// </param>
    /// <param name="characterClass">
    /// <para>
    /// Blueprint of type BlueprintCharacterClass. You can pass in the blueprint using:
    /// <list type ="bullet">
    ///   <item><term>A blueprint instance</term></item>
    ///   <item><term>A blueprint reference</term></item>
    ///   <item><term>A blueprint id as a string, Guid, or BlueprintGuid</term></item>
    ///   <item><term>A blueprint name registered with <see cref="BlueprintCore.Utils.BlueprintTool">BlueprintTool</see></term></item>
    /// </list>
    /// See <see cref="BlueprintCore.Utils.Blueprint{{T, TRef}}">Blueprint</see> for more details.
    /// </para>
    /// </param>
    /// <param name="merge">
    /// If mergeBehavior is ComponentMerge.Merge and the component already exists, this expression is called to merge the components.
    /// </param>
    /// <param name="mergeBehavior">
    /// Handling if the component already exists since the component is unique. Defaults to ComponentMerge.Fail.
    /// </param>
    /// <param name="spellList">
    /// <para>
    /// Blueprint of type BlueprintSpellList. You can pass in the blueprint using:
    /// <list type ="bullet">
    ///   <item><term>A blueprint instance</term></item>
    ///   <item><term>A blueprint reference</term></item>
    ///   <item><term>A blueprint id as a string, Guid, or BlueprintGuid</term></item>
    ///   <item><term>A blueprint name registered with <see cref="BlueprintCore.Utils.BlueprintTool">BlueprintTool</see></term></item>
    /// </list>
    /// See <see cref="BlueprintCore.Utils.Blueprint{{T, TRef}}">Blueprint</see> for more details.
    /// </para>
    /// </param>
    public TBuilder AddLearnSpellList(
        Blueprint<BlueprintArchetype, BlueprintArchetypeReference>? archetype = null,
        Blueprint<BlueprintCharacterClass, BlueprintCharacterClassReference>? characterClass = null,
        Action<BlueprintComponent, BlueprintComponent>? merge = null,
        ComponentMerge mergeBehavior = ComponentMerge.Merge,
        Blueprint<BlueprintSpellList, BlueprintSpellListReference>? spellList = null)
    {
      var component = new LearnSpellList();
      component.m_Archetype = archetype?.Reference ?? component.m_Archetype;
      if (component.m_Archetype is null)
      {
        component.m_Archetype = BlueprintTool.GetRef<BlueprintArchetypeReference>(null);
      }
      component.m_CharacterClass = characterClass?.Reference ?? component.m_CharacterClass;
      if (component.m_CharacterClass is null)
      {
        component.m_CharacterClass = BlueprintTool.GetRef<BlueprintCharacterClassReference>(null);
      }
      component.m_SpellList = spellList?.Reference ?? component.m_SpellList;
      if (component.m_SpellList is null)
      {
        component.m_SpellList = BlueprintTool.GetRef<BlueprintSpellListReference>(null);
      }
      return AddUniqueComponent(component, mergeBehavior, merge);
    }

    /// <summary>
    /// Adds <see cref="LearnSpells"/>
    /// </summary>
    ///
    /// <remarks>
    ///
    /// <list type="bullet">
    /// <listheader>Used by</listheader>
    /// <item><term>AccursedWitchCantripsFeature</term><description>d83becdd1ab644b995ae4aa96a493351</description></item>
    /// <item><term>EldritchScoundrelCantripFeature</term><description>0e451b208e7b855468986e03fcd4f990</description></item>
    /// <item><term>ZombieWizardSpellList</term><description>b712f3c37e6fcce4aa6024f293260753</description></item>
    /// </list>
    /// </remarks>
    ///
    /// <param name="characterClass">
    /// <para>
    /// Blueprint of type BlueprintCharacterClass. You can pass in the blueprint using:
    /// <list type ="bullet">
    ///   <item><term>A blueprint instance</term></item>
    ///   <item><term>A blueprint reference</term></item>
    ///   <item><term>A blueprint id as a string, Guid, or BlueprintGuid</term></item>
    ///   <item><term>A blueprint name registered with <see cref="BlueprintCore.Utils.BlueprintTool">BlueprintTool</see></term></item>
    /// </list>
    /// See <see cref="BlueprintCore.Utils.Blueprint{{T, TRef}}">Blueprint</see> for more details.
    /// </para>
    /// </param>
    /// <param name="merge">
    /// If mergeBehavior is ComponentMerge.Merge and the component already exists, this expression is called to merge the components.
    /// </param>
    /// <param name="mergeBehavior">
    /// Handling if the component already exists since the component is unique. Defaults to ComponentMerge.Fail.
    /// </param>
    /// <param name="spells">
    /// <para>
    /// Blueprint of type BlueprintAbility. You can pass in the blueprint using:
    /// <list type ="bullet">
    ///   <item><term>A blueprint instance</term></item>
    ///   <item><term>A blueprint reference</term></item>
    ///   <item><term>A blueprint id as a string, Guid, or BlueprintGuid</term></item>
    ///   <item><term>A blueprint name registered with <see cref="BlueprintCore.Utils.BlueprintTool">BlueprintTool</see></term></item>
    /// </list>
    /// See <see cref="BlueprintCore.Utils.Blueprint{{T, TRef}}">Blueprint</see> for more details.
    /// </para>
    /// </param>
    public TBuilder AddLearnSpells(
        Blueprint<BlueprintCharacterClass, BlueprintCharacterClassReference>? characterClass = null,
        Action<BlueprintComponent, BlueprintComponent>? merge = null,
        ComponentMerge mergeBehavior = ComponentMerge.Merge,
        List<Blueprint<BlueprintAbility, BlueprintAbilityReference>>? spells = null)
    {
      var component = new LearnSpells();
      component.m_CharacterClass = characterClass?.Reference ?? component.m_CharacterClass;
      if (component.m_CharacterClass is null)
      {
        component.m_CharacterClass = BlueprintTool.GetRef<BlueprintCharacterClassReference>(null);
      }
      component.m_Spells = spells?.Select(bp => bp.Reference)?.ToArray() ?? component.m_Spells;
      if (component.m_Spells is null)
      {
        component.m_Spells = new BlueprintAbilityReference[0];
      }
      return AddUniqueComponent(component, mergeBehavior, merge);
    }

    /// <summary>
    /// Adds <see cref="LockEquipmentSlot"/>
    /// </summary>
    ///
    /// <remarks>
    ///
    /// <list type="bullet">
    /// <listheader>Used by</listheader>
    /// <item><term>AmiriLockedSlotFeature</term><description>596db6f87c982bb43a9d2793006a57a1</description></item>
    /// <item><term>AnimalCompanionUnitLeopard_Medium</term><description>c0b9a707f5dd46218ff5d35b1f484079</description></item>
    /// <item><term>TriceratopsStatuetteUnit</term><description>cc9177cc8dccc1449be084e7784ff52d</description></item>
    /// </list>
    /// </remarks>
    ///
    /// <param name="merge">
    /// If mergeBehavior is ComponentMerge.Merge and the component already exists, this expression is called to merge the components.
    /// </param>
    /// <param name="mergeBehavior">
    /// Handling if the component already exists since the component is unique. Defaults to ComponentMerge.Fail.
    /// </param>
    public TBuilder AddLockEquipmentSlot(
        bool? deactivate = null,
        Action<BlueprintComponent, BlueprintComponent>? merge = null,
        ComponentMerge mergeBehavior = ComponentMerge.Merge,
        LockEquipmentSlot.SlotType? slotType = null)
    {
      var component = new LockEquipmentSlot();
      component.m_Deactivate = deactivate ?? component.m_Deactivate;
      component.m_SlotType = slotType ?? component.m_SlotType;
      return AddUniqueComponent(component, mergeBehavior, merge);
    }

    /// <summary>
    /// Adds <see cref="MarkPassive"/>
    /// </summary>
    ///
    /// <remarks>
    ///
    /// <para>
    /// ComponentName: Passive/Mark passive
    /// </para>
    ///
    /// <list type="bullet">
    /// <listheader>Used by</listheader>
    /// <item><term>BoneSpearDismemberBuff</term><description>06014e98a84795a49a790283ec2d2847</description></item>
    /// <item><term>KillAndSpawnControllableProjectileBuff</term><description>fca25a203061ff149a71966c61657535</description></item>
    /// <item><term>MarkPassive</term><description>d6abca706380f4445b217f0473f254c6</description></item>
    /// </list>
    /// </remarks>
    public TBuilder AddMarkPassive()
    {
      return AddComponent(new MarkPassive());
    }

    /// <summary>
    /// Adds <see cref="MayBanterOnRest"/>
    /// </summary>
    ///
    /// <remarks>
    ///
    /// <list type="bullet">
    /// <listheader>Used by</listheader>
    /// <item><term>DLC2_Millorn</term><description>3b91296c7ae04a1391dfe972ce1e3eaf</description></item>
    /// <item><term>DLC2_NPC_Gravedigger</term><description>e8bef329125542299a0c4b023b82ca64</description></item>
    /// <item><term>DLC2_NPC_Musician</term><description>92f5b41e973b497b8cee666153ce24dc</description></item>
    /// </list>
    /// </remarks>
    public TBuilder AddMayBanterOnRest()
    {
      return AddComponent(new MayBanterOnRest());
    }

    /// <summary>
    /// Adds <see cref="MovementDistanceTrigger"/>
    /// </summary>
    ///
    /// <remarks>
    ///
    /// <list type="bullet">
    /// <listheader>Used by</listheader>
    /// <item><term>BloodragerFeyBlurringMovementBuff</term><description>0d4dc6eea3f13d6488c21bc3fd3f119e</description></item>
    /// <item><term>JoCat_ShirtFeature</term><description>706edd2eaa8c4c9dbf731085e0397333</description></item>
    /// <item><term>LongbowOfLeechingStrikeBuff</term><description>dd7722a46f520b4429cedbc8515cab2d</description></item>
    /// </list>
    /// </remarks>
    public TBuilder AddMovementDistanceTrigger(
        ActionsBuilder? action = null,
        ContextValue? distanceInFeet = null,
        bool? limitTiggerCountInOneRound = null,
        int? tiggerCountMaximumInOneRound = null)
    {
      var component = new MovementDistanceTrigger();
      component.Action = action?.Build() ?? component.Action;
      if (component.Action is null)
      {
        component.Action = Utils.Constants.Empty.Actions;
      }
      component.DistanceInFeet = distanceInFeet ?? component.DistanceInFeet;
      if (component.DistanceInFeet is null)
      {
        component.DistanceInFeet = ContextValues.Constant(0);
      }
      component.LimitTiggerCountInOneRound = limitTiggerCountInOneRound ?? component.LimitTiggerCountInOneRound;
      component.TiggerCountMaximumInOneRound = tiggerCountMaximumInOneRound ?? component.TiggerCountMaximumInOneRound;
      return AddComponent(component);
    }

    /// <summary>
    /// Adds <see cref="NenioSpecialPolymorphWhileEtudePlaying"/>
    /// </summary>
    ///
    /// <remarks>
    ///
    /// <list type="bullet">
    /// <listheader>Used by</listheader>
    /// <item><term>DLC1_Nenio_Companion</term><description>5642e394eac9447e819646723ffa25a3</description></item>
    /// <item><term>NenioTestLevel15</term><description>2e9cc80b3190bad45b191fd2b1d75209</description></item>
    /// <item><term>NenioTestLevel19</term><description>b8366f6c59f84672b699878296f81f72</description></item>
    /// </list>
    /// </remarks>
    ///
    /// <param name="etude">
    /// <para>
    /// Blueprint of type BlueprintEtude. You can pass in the blueprint using:
    /// <list type ="bullet">
    ///   <item><term>A blueprint instance</term></item>
    ///   <item><term>A blueprint reference</term></item>
    ///   <item><term>A blueprint id as a string, Guid, or BlueprintGuid</term></item>
    ///   <item><term>A blueprint name registered with <see cref="BlueprintCore.Utils.BlueprintTool">BlueprintTool</see></term></item>
    /// </list>
    /// See <see cref="BlueprintCore.Utils.Blueprint{{T, TRef}}">Blueprint</see> for more details.
    /// </para>
    /// </param>
    /// <param name="specialPolymorphBuff">
    /// <para>
    /// Blueprint of type BlueprintBuff. You can pass in the blueprint using:
    /// <list type ="bullet">
    ///   <item><term>A blueprint instance</term></item>
    ///   <item><term>A blueprint reference</term></item>
    ///   <item><term>A blueprint id as a string, Guid, or BlueprintGuid</term></item>
    ///   <item><term>A blueprint name registered with <see cref="BlueprintCore.Utils.BlueprintTool">BlueprintTool</see></term></item>
    /// </list>
    /// See <see cref="BlueprintCore.Utils.Blueprint{{T, TRef}}">Blueprint</see> for more details.
    /// </para>
    /// </param>
    /// <param name="standardPolymorphAbility">
    /// <para>
    /// Blueprint of type BlueprintActivatableAbility. You can pass in the blueprint using:
    /// <list type ="bullet">
    ///   <item><term>A blueprint instance</term></item>
    ///   <item><term>A blueprint reference</term></item>
    ///   <item><term>A blueprint id as a string, Guid, or BlueprintGuid</term></item>
    ///   <item><term>A blueprint name registered with <see cref="BlueprintCore.Utils.BlueprintTool">BlueprintTool</see></term></item>
    /// </list>
    /// See <see cref="BlueprintCore.Utils.Blueprint{{T, TRef}}">Blueprint</see> for more details.
    /// </para>
    /// </param>
    public TBuilder AddNenioSpecialPolymorphWhileEtudePlaying(
        AbilityExecutionContext? abilityExecutionContext = null,
        Blueprint<BlueprintEtude, BlueprintEtudeReference>? etude = null,
        Blueprint<BlueprintBuff, BlueprintBuffReference>? specialPolymorphBuff = null,
        Blueprint<BlueprintActivatableAbility, BlueprintActivatableAbilityReference>? standardPolymorphAbility = null)
    {
      var component = new NenioSpecialPolymorphWhileEtudePlaying();
      Validate(abilityExecutionContext);
      component.abilityExecutionContext = abilityExecutionContext ?? component.abilityExecutionContext;
      component.m_Etude = etude?.Reference ?? component.m_Etude;
      if (component.m_Etude is null)
      {
        component.m_Etude = BlueprintTool.GetRef<BlueprintEtudeReference>(null);
      }
      component.m_SpecialPolymorphBuff = specialPolymorphBuff?.Reference ?? component.m_SpecialPolymorphBuff;
      if (component.m_SpecialPolymorphBuff is null)
      {
        component.m_SpecialPolymorphBuff = BlueprintTool.GetRef<BlueprintBuffReference>(null);
      }
      component.m_StandardPolymorphAbility = standardPolymorphAbility?.Reference ?? component.m_StandardPolymorphAbility;
      if (component.m_StandardPolymorphAbility is null)
      {
        component.m_StandardPolymorphAbility = BlueprintTool.GetRef<BlueprintActivatableAbilityReference>(null);
      }
      return AddComponent(component);
    }

    /// <summary>
    /// Adds <see cref="OverrideVisionRange"/>
    /// </summary>
    ///
    /// <remarks>
    ///
    /// <para>
    /// ComponentName: Passive/Override vision range
    /// </para>
    ///
    /// <list type="bullet">
    /// <listheader>Used by</listheader>
    /// <item><term>ArueshalaeRedoubt_Cultist_Slayer_Ranged</term><description>cd73a15a1ea1a204f87adae3c7a30581</description></item>
    /// <item><term>DefenderGerats_Cultist_FighterMeleeHandaxe_sum</term><description>df1239d98c030fe4e8f7e14732857f50</description></item>
    /// <item><term>VisionRangeMax</term><description>5b87b23635ba481d8f7c7ec907926dc7</description></item>
    /// </list>
    /// </remarks>
    ///
    /// <param name="alsoInCombat">
    /// <para>
    /// InfoBox: Очень опасная галка, может ломать вход/выход из боя
    /// </para>
    /// </param>
    public TBuilder AddOverrideVisionRange(
        bool? alsoInCombat = null,
        int? visionRangeInMeters = null)
    {
      var component = new OverrideVisionRange();
      component.AlsoInCombat = alsoInCombat ?? component.AlsoInCombat;
      component.VisionRangeInMeters = visionRangeInMeters ?? component.VisionRangeInMeters;
      return AddComponent(component);
    }

    /// <summary>
    /// Adds <see cref="PreventHealing"/>
    /// </summary>
    ///
    /// <remarks>
    ///
    /// <list type="bullet">
    /// <listheader>Used by</listheader>
    /// <item><term>AizerghaulBuff</term><description>229c9692e8eb4caf827f2d318984be5d</description></item>
    /// <item><term>ArmyCannotBeHealed</term><description>69883872e3c145eeab069e04c729130d</description></item>
    /// <item><term>WalkingDeadImmortalityBuff</term><description>9c55730e682cb574ab2fbc4727517752</description></item>
    /// </list>
    /// </remarks>
    public TBuilder AddPreventHealing()
    {
      return AddComponent(new PreventHealing());
    }

    /// <summary>
    /// Adds <see cref="PriorityTarget"/>
    /// </summary>
    ///
    /// <remarks>
    ///
    /// <list type="bullet">
    /// <listheader>Used by</listheader>
    /// <item><term>HellsDecreeAbilityTargetedRageAllySelfBuff</term><description>783bcdac2a948eb448f3eb249f068f6f</description></item>
    /// <item><term>SongOfCourageousDefenderEnemyEffectBuff</term><description>3c3c89f2b79a4eb4b3e0c2ff77a17ea9</description></item>
    /// </list>
    /// </remarks>
    ///
    /// <param name="priorityFact">
    /// <para>
    /// Blueprint of type BlueprintUnitFact. You can pass in the blueprint using:
    /// <list type ="bullet">
    ///   <item><term>A blueprint instance</term></item>
    ///   <item><term>A blueprint reference</term></item>
    ///   <item><term>A blueprint id as a string, Guid, or BlueprintGuid</term></item>
    ///   <item><term>A blueprint name registered with <see cref="BlueprintCore.Utils.BlueprintTool">BlueprintTool</see></term></item>
    /// </list>
    /// See <see cref="BlueprintCore.Utils.Blueprint{{T, TRef}}">Blueprint</see> for more details.
    /// </para>
    /// </param>
    public TBuilder AddPriorityTarget(
        Blueprint<BlueprintUnitFact, BlueprintUnitFactReference>? priorityFact = null)
    {
      var component = new PriorityTarget();
      component.PriorityFact = priorityFact?.Reference ?? component.PriorityFact;
      if (component.PriorityFact is null)
      {
        component.PriorityFact = BlueprintTool.GetRef<BlueprintUnitFactReference>(null);
      }
      return AddComponent(component);
    }

    /// <summary>
    /// Adds <see cref="RaiseBAB"/>
    /// </summary>
    ///
    /// <remarks>
    ///
    /// <list type="bullet">
    /// <listheader>Used by</listheader>
    /// <item><term>DemonRageBuffLostControl</term><description>19c57421f3bd3f449aa47fdc103c2c67</description></item>
    /// <item><term>LichSkeletalFighterBABFeature</term><description>0e2f5e7fa03e3694684ff47f8b28bd3f</description></item>
    /// <item><term>TransformationBuff</term><description>287682389d2011b41b5a65195d9cbc84</description></item>
    /// </list>
    /// </remarks>
    public TBuilder AddRaiseBAB(
        ContextValue? targetValue = null)
    {
      var component = new RaiseBAB();
      component.TargetValue = targetValue ?? component.TargetValue;
      if (component.TargetValue is null)
      {
        component.TargetValue = ContextValues.Constant(0);
      }
      return AddComponent(component);
    }

    /// <summary>
    /// Adds <see cref="RaiseStatToMinimum"/>
    /// </summary>
    ///
    /// <remarks>
    ///
    /// <list type="bullet">
    /// <listheader>Used by</listheader>
    /// <item><term>DemonRageBuffLostControl</term><description>19c57421f3bd3f449aa47fdc103c2c67</description></item>
    /// <item><term>DemonRageBuffUncontrollable</term><description>325e00281f7e4a54cbc60627f2f66cec</description></item>
    /// </list>
    /// </remarks>
    public TBuilder AddRaiseStatToMinimum(
        StatType? stat = null,
        ContextValue? targetValue = null)
    {
      var component = new RaiseStatToMinimum();
      component.Stat = stat ?? component.Stat;
      component.TargetValue = targetValue ?? component.TargetValue;
      if (component.TargetValue is null)
      {
        component.TargetValue = ContextValues.Constant(0);
      }
      return AddComponent(component);
    }

    /// <summary>
    /// Adds <see cref="RangedCleave"/>
    /// </summary>
    ///
    /// <remarks>
    ///
    /// <list type="bullet">
    /// <listheader>Used by</listheader>
    /// <item><term>RangedCleave</term><description>b3fb61cecd4de98419d82e465bc588f2</description></item>
    /// </list>
    /// </remarks>
    public TBuilder AddRangedCleave(
        Feet? range = null)
    {
      var component = new RangedCleave();
      component.Range = range ?? component.Range;
      return AddComponent(component);
    }

    /// <summary>
    /// Adds <see cref="RecalculateOnOwnerFactUpdated"/>
    /// </summary>
    ///
    /// <remarks>
    ///
    /// <list type="bullet">
    /// <listheader>Used by</listheader>
    /// <item><term>BabauAspectFeature</term><description>99a34a0fa0c3a154fbc5b11fe2d18009</description></item>
    /// <item><term>OmoxAspectFeature</term><description>daf030c7563b2664eb1031d91eaae7ab</description></item>
    /// <item><term>VrolikaiAspectFeature</term><description>0ed608f1a0695cd4cb80bf6d415ab295</description></item>
    /// </list>
    /// </remarks>
    ///
    /// <param name="fact">
    /// <para>
    /// Blueprint of type BlueprintUnitFact. You can pass in the blueprint using:
    /// <list type ="bullet">
    ///   <item><term>A blueprint instance</term></item>
    ///   <item><term>A blueprint reference</term></item>
    ///   <item><term>A blueprint id as a string, Guid, or BlueprintGuid</term></item>
    ///   <item><term>A blueprint name registered with <see cref="BlueprintCore.Utils.BlueprintTool">BlueprintTool</see></term></item>
    /// </list>
    /// See <see cref="BlueprintCore.Utils.Blueprint{{T, TRef}}">Blueprint</see> for more details.
    /// </para>
    /// </param>
    public TBuilder AddRecalculateOnOwnerFactUpdated(
        Blueprint<BlueprintUnitFact, BlueprintUnitFactReference>? fact = null)
    {
      var component = new RecalculateOnOwnerFactUpdated();
      component.m_Fact = fact?.Reference ?? component.m_Fact;
      if (component.m_Fact is null)
      {
        component.m_Fact = BlueprintTool.GetRef<BlueprintUnitFactReference>(null);
      }
      return AddComponent(component);
    }

    /// <summary>
    /// Adds <see cref="RedirectDamageToPet"/>
    /// </summary>
    ///
    /// <remarks>
    ///
    /// <list type="bullet">
    /// <listheader>Used by</listheader>
    /// <item><term>Artifact_AzataCloakFeature</term><description>8794515a267c406b83983e8d8c837d13</description></item>
    /// </list>
    /// </remarks>
    ///
    /// <param name="merge">
    /// If mergeBehavior is ComponentMerge.Merge and the component already exists, this expression is called to merge the components.
    /// </param>
    /// <param name="mergeBehavior">
    /// Handling if the component already exists since the component is unique. Defaults to ComponentMerge.Fail.
    /// </param>
    public TBuilder AddRedirectDamageToPet(
        Action<BlueprintComponent, BlueprintComponent>? merge = null,
        ComponentMerge mergeBehavior = ComponentMerge.Merge,
        int? percentRedirected = null,
        PetType? petType = null)
    {
      var component = new RedirectDamageToPet();
      component.m_PercentRedirected = percentRedirected ?? component.m_PercentRedirected;
      component.m_PetType = petType ?? component.m_PetType;
      return AddUniqueComponent(component, mergeBehavior, merge);
    }

    /// <summary>
    /// Adds <see cref="ReplaceStatBaseAttribute"/>
    /// </summary>
    ///
    /// <remarks>
    ///
    /// <list type="bullet">
    /// <listheader>Used by</listheader>
    /// <item><term>BackgroundAcolyte</term><description>7cc9014488caa5445a0c8b5e17b95466</description></item>
    /// <item><term>PossessedShamanSharedSkillLoreNature</term><description>b4830b948a0d28d489a6ccd22f4b53be</description></item>
    /// <item><term>StudentOfWarMindOverMetal</term><description>708fe8142ac107345967de54fca15942</description></item>
    /// </list>
    /// </remarks>
    ///
    /// <param name="merge">
    /// If mergeBehavior is ComponentMerge.Merge and the component already exists, this expression is called to merge the components.
    /// </param>
    /// <param name="mergeBehavior">
    /// Handling if the component already exists since the component is unique. Defaults to ComponentMerge.Fail.
    /// </param>
    public TBuilder AddReplaceStatBaseAttribute(
        StatType? baseAttributeReplacement = null,
        Action<BlueprintComponent, BlueprintComponent>? merge = null,
        ComponentMerge mergeBehavior = ComponentMerge.Merge,
        StatType? targetStat = null)
    {
      var component = new ReplaceStatBaseAttribute();
      component.BaseAttributeReplacement = baseAttributeReplacement ?? component.BaseAttributeReplacement;
      component.TargetStat = targetStat ?? component.TargetStat;
      return AddUniqueComponent(component, mergeBehavior, merge);
    }

    /// <summary>
    /// Adds <see cref="Revolt"/>
    /// </summary>
    ///
    /// <remarks>
    ///
    /// <list type="bullet">
    /// <listheader>Used by</listheader>
    /// <item><term>RevoltAttackBuff</term><description>ad48caada2fd3b14eae09fcb62cf07c5</description></item>
    /// </list>
    /// </remarks>
    public TBuilder AddRevolt()
    {
      return AddComponent(new Revolt());
    }

    /// <summary>
    /// Adds <see cref="ScrollSpecialization"/>
    /// </summary>
    ///
    /// <remarks>
    ///
    /// <list type="bullet">
    /// <listheader>Used by</listheader>
    /// <item><term>ScrollMastery</term><description>f42f41dd022e73d4a95019bc03230014</description></item>
    /// </list>
    /// </remarks>
    ///
    /// <param name="specializedClass">
    /// <para>
    /// Blueprint of type BlueprintCharacterClass. You can pass in the blueprint using:
    /// <list type ="bullet">
    ///   <item><term>A blueprint instance</term></item>
    ///   <item><term>A blueprint reference</term></item>
    ///   <item><term>A blueprint id as a string, Guid, or BlueprintGuid</term></item>
    ///   <item><term>A blueprint name registered with <see cref="BlueprintCore.Utils.BlueprintTool">BlueprintTool</see></term></item>
    /// </list>
    /// See <see cref="BlueprintCore.Utils.Blueprint{{T, TRef}}">Blueprint</see> for more details.
    /// </para>
    /// </param>
    public TBuilder AddScrollSpecialization(
        Blueprint<BlueprintCharacterClass, BlueprintCharacterClassReference>? specializedClass = null)
    {
      var component = new ScrollSpecialization();
      component.m_SpecializedClass = specializedClass?.Reference ?? component.m_SpecializedClass;
      if (component.m_SpecializedClass is null)
      {
        component.m_SpecializedClass = BlueprintTool.GetRef<BlueprintCharacterClassReference>(null);
      }
      return AddComponent(component);
    }

    /// <summary>
    /// Adds <see cref="SetChargeWeapon"/>
    /// </summary>
    ///
    /// <remarks>
    ///
    /// <list type="bullet">
    /// <listheader>Used by</listheader>
    /// <item><term>Kalavakus_Feature_PowerfulChargeFeature</term><description>fcf032be8bf61df4897c1242538acf7e</description></item>
    /// <item><term>Minotaur_PowerfulChargeFeature</term><description>71241b4c372431a4ea1c1e823f0c00ed</description></item>
    /// <item><term>Triceratops_Feature_PowerfulChargeFeature</term><description>5c1c2f9aa37ca7445a31bdb4ab16255b</description></item>
    /// </list>
    /// </remarks>
    ///
    /// <param name="weapon">
    /// <para>
    /// Blueprint of type BlueprintItemWeapon. You can pass in the blueprint using:
    /// <list type ="bullet">
    ///   <item><term>A blueprint instance</term></item>
    ///   <item><term>A blueprint reference</term></item>
    ///   <item><term>A blueprint id as a string, Guid, or BlueprintGuid</term></item>
    ///   <item><term>A blueprint name registered with <see cref="BlueprintCore.Utils.BlueprintTool">BlueprintTool</see></term></item>
    /// </list>
    /// See <see cref="BlueprintCore.Utils.Blueprint{{T, TRef}}">Blueprint</see> for more details.
    /// </para>
    /// </param>
    public TBuilder AddSetChargeWeapon(
        Blueprint<BlueprintItemWeapon, BlueprintItemWeaponReference>? weapon = null)
    {
      var component = new SetChargeWeapon();
      component.m_Weapon = weapon?.Reference ?? component.m_Weapon;
      if (component.m_Weapon is null)
      {
        component.m_Weapon = BlueprintTool.GetRef<BlueprintItemWeaponReference>(null);
      }
      return AddComponent(component);
    }

    /// <summary>
    /// Adds <see cref="SetFleeOrApproachLogic"/>
    /// </summary>
    ///
    /// <remarks>
    ///
    /// <list type="bullet">
    /// <listheader>Used by</listheader>
    /// <item><term>AbsoluteOrderApproachBuff</term><description>0df0e7c6cbe55994fb32c83e7dadc02d</description></item>
    /// <item><term>CommandFleeBuff</term><description>9c8b488120d2b4d4f8243720d754c88e</description></item>
    /// <item><term>CommandGreaterFleeBuff</term><description>2c18c6a5055da9046a81bbaff7018d22</description></item>
    /// </list>
    /// </remarks>
    public TBuilder AddSetFleeOrApproachLogic(
        UnitPartFleeOrApproach.CommandType? commandType = null)
    {
      var component = new SetFleeOrApproachLogic();
      component.CommandType = commandType ?? component.CommandType;
      return AddComponent(component);
    }

    /// <summary>
    /// Adds <see cref="SetRunBackLogic"/>
    /// </summary>
    ///
    /// <remarks>
    ///
    /// <list type="bullet">
    /// <listheader>Used by</listheader>
    /// <item><term>RunBackLogic</term><description>20bb236fe8b79f84cbfd081b7d2ebabd</description></item>
    /// </list>
    /// </remarks>
    public TBuilder AddSetRunBackLogic(
        float? runBackDistance = null,
        float? triggerDistance = null)
    {
      var component = new SetRunBackLogic();
      component.RunBackDistance = runBackDistance ?? component.RunBackDistance;
      component.TriggerDistance = triggerDistance ?? component.TriggerDistance;
      return AddComponent(component);
    }

    /// <summary>
    /// Adds <see cref="SpecificBuffImmunity"/>
    /// </summary>
    ///
    /// <remarks>
    ///
    /// <list type="bullet">
    /// <listheader>Used by</listheader>
    /// <item><term>AeonEyeNPCVisualBuff</term><description>cf2f65c16e02826428f32be045f8523d</description></item>
    /// <item><term>ProtectionFromEvilBuff</term><description>4a6911969911ce9499bf27dde9bfcedc</description></item>
    /// <item><term>WitchHexAuraOfPurityEffectBuff</term><description>c6e331831f3fbc642b4a1232b9f9e66e</description></item>
    /// </list>
    /// </remarks>
    ///
    /// <param name="buff">
    /// <para>
    /// Blueprint of type BlueprintBuff. You can pass in the blueprint using:
    /// <list type ="bullet">
    ///   <item><term>A blueprint instance</term></item>
    ///   <item><term>A blueprint reference</term></item>
    ///   <item><term>A blueprint id as a string, Guid, or BlueprintGuid</term></item>
    ///   <item><term>A blueprint name registered with <see cref="BlueprintCore.Utils.BlueprintTool">BlueprintTool</see></term></item>
    /// </list>
    /// See <see cref="BlueprintCore.Utils.Blueprint{{T, TRef}}">Blueprint</see> for more details.
    /// </para>
    /// </param>
    /// <param name="merge">
    /// If mergeBehavior is ComponentMerge.Merge and the component already exists, this expression is called to merge the components.
    /// </param>
    /// <param name="mergeBehavior">
    /// Handling if the component already exists since the component is unique. Defaults to ComponentMerge.Fail.
    /// </param>
    public TBuilder AddSpecificBuffImmunity(
        Blueprint<BlueprintBuff, BlueprintBuffReference>? buff = null,
        Action<BlueprintComponent, BlueprintComponent>? merge = null,
        ComponentMerge mergeBehavior = ComponentMerge.Merge)
    {
      var component = new SpecificBuffImmunity();
      component.m_Buff = buff?.Reference ?? component.m_Buff;
      if (component.m_Buff is null)
      {
        component.m_Buff = BlueprintTool.GetRef<BlueprintBuffReference>(null);
      }
      return AddUniqueComponent(component, mergeBehavior, merge);
    }

    /// <summary>
    /// Adds <see cref="SpellImmunityToSpellDescriptor"/>
    /// </summary>
    ///
    /// <remarks>
    ///
    /// <list type="bullet">
    /// <listheader>Used by</listheader>
    /// <item><term>Airborne</term><description>70cffb448c132fa409e49156d013b175</description></item>
    /// <item><term>HellknightSigniferDiabolicHarbringer</term><description>c7e77ce541b07c7428e8199f5d854d3e</description></item>
    /// <item><term>WingsMovanicDeva</term><description>775df52784e1d454cba0da8df5f4f59a</description></item>
    /// </list>
    /// </remarks>
    ///
    /// <param name="casterIgnoreImmunityFact">
    /// <para>
    /// Blueprint of type BlueprintUnitFact. You can pass in the blueprint using:
    /// <list type ="bullet">
    ///   <item><term>A blueprint instance</term></item>
    ///   <item><term>A blueprint reference</term></item>
    ///   <item><term>A blueprint id as a string, Guid, or BlueprintGuid</term></item>
    ///   <item><term>A blueprint name registered with <see cref="BlueprintCore.Utils.BlueprintTool">BlueprintTool</see></term></item>
    /// </list>
    /// See <see cref="BlueprintCore.Utils.Blueprint{{T, TRef}}">Blueprint</see> for more details.
    /// </para>
    /// </param>
    /// <param name="merge">
    /// If mergeBehavior is ComponentMerge.Merge and the component already exists, this expression is called to merge the components.
    /// </param>
    /// <param name="mergeBehavior">
    /// Handling if the component already exists since the component is unique. Defaults to ComponentMerge.Fail.
    /// </param>
    public TBuilder AddSpellImmunityToSpellDescriptor(
        Blueprint<BlueprintUnitFact, BlueprintUnitFactReference>? casterIgnoreImmunityFact = null,
        SpellDescriptorWrapper? descriptor = null,
        Action<BlueprintComponent, BlueprintComponent>? merge = null,
        ComponentMerge mergeBehavior = ComponentMerge.Merge)
    {
      var component = new SpellImmunityToSpellDescriptor();
      component.m_CasterIgnoreImmunityFact = casterIgnoreImmunityFact?.Reference ?? component.m_CasterIgnoreImmunityFact;
      if (component.m_CasterIgnoreImmunityFact is null)
      {
        component.m_CasterIgnoreImmunityFact = BlueprintTool.GetRef<BlueprintUnitFactReference>(null);
      }
      component.Descriptor = descriptor ?? component.Descriptor;
      return AddUniqueComponent(component, mergeBehavior, merge);
    }

    /// <summary>
    /// Adds <see cref="SpellResistanceAgainstAlignment"/>
    /// </summary>
    ///
    /// <remarks>
    ///
    /// <list type="bullet">
    /// <listheader>Used by</listheader>
    /// <item><term>AngelHaloArchonsAuraHolyAuraBuff</term><description>64b2791ee5b11194e82eb6f474244d19</description></item>
    /// <item><term>HolyAuraBuff</term><description>a33bf327207a5904d9e38d6a80eb09e2</description></item>
    /// <item><term>UnholyAuraBuff</term><description>9eda82a1f78558747a03c17e0e9a1a68</description></item>
    /// </list>
    /// </remarks>
    public TBuilder AddSpellResistanceAgainstAlignment(
        AlignmentComponent? alignment = null,
        ContextValue? value = null)
    {
      var component = new SpellResistanceAgainstAlignment();
      component.Alignment = alignment ?? component.Alignment;
      component.Value = value ?? component.Value;
      if (component.Value is null)
      {
        component.Value = ContextValues.Constant(0);
      }
      return AddComponent(component);
    }

    /// <summary>
    /// Adds <see cref="SpellResistanceAgainstSpellDescriptor"/>
    /// </summary>
    ///
    /// <remarks>
    ///
    /// <list type="bullet">
    /// <listheader>Used by</listheader>
    /// <item><term>CelestialTotemGreaterBuff</term><description>e31276241f875254cb102329c0b55ba7</description></item>
    /// <item><term>CursedWoundBuff</term><description>b68e3691b817d454584ef46caa3ee4fa</description></item>
    /// <item><term>FesterBuff</term><description>b896100431869174092b06411aba5b30</description></item>
    /// </list>
    /// </remarks>
    public TBuilder AddSpellResistanceAgainstSpellDescriptor(
        SpellDescriptorWrapper? spellDescriptor = null,
        ContextValue? value = null)
    {
      var component = new SpellResistanceAgainstSpellDescriptor();
      component.SpellDescriptor = spellDescriptor ?? component.SpellDescriptor;
      component.Value = value ?? component.Value;
      if (component.Value is null)
      {
        component.Value = ContextValues.Constant(0);
      }
      return AddComponent(component);
    }

    /// <summary>
    /// Adds <see cref="SpontaneousSpellConversion"/>
    /// </summary>
    ///
    /// <remarks>
    ///
    /// <para>
    /// ComponentName: Spontaneous Spell Conversion
    /// </para>
    ///
    /// <list type="bullet">
    /// <listheader>Used by</listheader>
    /// <item><term>ArcanistConsumeSpellsFeature</term><description>69cfb4ab0d9812249b924b8f23d6d19f</description></item>
    /// <item><term>ShamanHexFriendToAnimalsSpontaneousSummon</term><description>92a5f387d4d0ea64c8ea119bec7a77a5</description></item>
    /// <item><term>WitchDoctorCounterCurseFeature</term><description>74ce117848b4ea641acf266d84ee1602</description></item>
    /// </list>
    /// </remarks>
    ///
    /// <param name="characterClass">
    /// <para>
    /// Blueprint of type BlueprintCharacterClass. You can pass in the blueprint using:
    /// <list type ="bullet">
    ///   <item><term>A blueprint instance</term></item>
    ///   <item><term>A blueprint reference</term></item>
    ///   <item><term>A blueprint id as a string, Guid, or BlueprintGuid</term></item>
    ///   <item><term>A blueprint name registered with <see cref="BlueprintCore.Utils.BlueprintTool">BlueprintTool</see></term></item>
    /// </list>
    /// See <see cref="BlueprintCore.Utils.Blueprint{{T, TRef}}">Blueprint</see> for more details.
    /// </para>
    /// </param>
    /// <param name="merge">
    /// If mergeBehavior is ComponentMerge.Merge and the component already exists, this expression is called to merge the components.
    /// </param>
    /// <param name="mergeBehavior">
    /// Handling if the component already exists since the component is unique. Defaults to ComponentMerge.Fail.
    /// </param>
    /// <param name="spellsByLevel">
    /// <para>
    /// Blueprint of type BlueprintAbility. You can pass in the blueprint using:
    /// <list type ="bullet">
    ///   <item><term>A blueprint instance</term></item>
    ///   <item><term>A blueprint reference</term></item>
    ///   <item><term>A blueprint id as a string, Guid, or BlueprintGuid</term></item>
    ///   <item><term>A blueprint name registered with <see cref="BlueprintCore.Utils.BlueprintTool">BlueprintTool</see></term></item>
    /// </list>
    /// See <see cref="BlueprintCore.Utils.Blueprint{{T, TRef}}">Blueprint</see> for more details.
    /// </para>
    /// </param>
    public TBuilder AddSpontaneousSpellConversion(
        Blueprint<BlueprintCharacterClass, BlueprintCharacterClassReference>? characterClass = null,
        Action<BlueprintComponent, BlueprintComponent>? merge = null,
        ComponentMerge mergeBehavior = ComponentMerge.Merge,
        List<Blueprint<BlueprintAbility, BlueprintAbilityReference>>? spellsByLevel = null)
    {
      var component = new SpontaneousSpellConversion();
      component.m_CharacterClass = characterClass?.Reference ?? component.m_CharacterClass;
      if (component.m_CharacterClass is null)
      {
        component.m_CharacterClass = BlueprintTool.GetRef<BlueprintCharacterClassReference>(null);
      }
      component.m_SpellsByLevel = spellsByLevel?.Select(bp => bp.Reference)?.ToArray() ?? component.m_SpellsByLevel;
      if (component.m_SpellsByLevel is null)
      {
        component.m_SpellsByLevel = new BlueprintAbilityReference[0];
      }
      return AddUniqueComponent(component, mergeBehavior, merge);
    }

    /// <summary>
    /// Adds <see cref="SufferFromHealing"/>
    /// </summary>
    ///
    /// <remarks>
    ///
    /// <list type="bullet">
    /// <listheader>Used by</listheader>
    /// <item><term>DecayingDaggerBuff</term><description>c02cf40a76e60c34aae11492aae6d9a2</description></item>
    /// <item><term>JokeOfFateBuff</term><description>e131adfe445f6ed4e8cca37b1cb17573</description></item>
    /// <item><term>RingOfTheDeadTargetBuff</term><description>307ae773b61581c44add346567fd8263</description></item>
    /// </list>
    /// </remarks>
    ///
    /// <param name="damageDescription">
    /// <para>
    /// InfoBox: Prevents any healing and deals equal damage instead
    /// </para>
    /// </param>
    public TBuilder AddSufferFromHealing(
        DamageTypeDescription? damageDescription = null)
    {
      var component = new SufferFromHealing();
      Validate(damageDescription);
      component.DamageDescription = damageDescription ?? component.DamageDescription;
      return AddComponent(component);
    }

    /// <summary>
    /// Adds <see cref="SuppressBuffs"/>
    /// </summary>
    ///
    /// <remarks>
    ///
    /// <list type="bullet">
    /// <listheader>Used by</listheader>
    /// <item><term>1_FirstStage_AcidBuff</term><description>6afe27c9a2d64eb890673ff3649dacb3</description></item>
    /// <item><term>MadnessBlessingMajorAbilityAttackNearestCreatureBuff</term><description>4eeb95b311fc42bfbabbd9369f18e5e9</description></item>
    /// <item><term>WitchHexMajorAmelioratingPoisonSuppressBuff</term><description>2cf1962ef4cd4b5468c09bf4959d1bf7</description></item>
    /// </list>
    /// </remarks>
    ///
    /// <param name="buffs">
    /// <para>
    /// Blueprint of type BlueprintBuff. You can pass in the blueprint using:
    /// <list type ="bullet">
    ///   <item><term>A blueprint instance</term></item>
    ///   <item><term>A blueprint reference</term></item>
    ///   <item><term>A blueprint id as a string, Guid, or BlueprintGuid</term></item>
    ///   <item><term>A blueprint name registered with <see cref="BlueprintCore.Utils.BlueprintTool">BlueprintTool</see></term></item>
    /// </list>
    /// See <see cref="BlueprintCore.Utils.Blueprint{{T, TRef}}">Blueprint</see> for more details.
    /// </para>
    /// </param>
    public TBuilder AddSuppressBuffs(
        List<Blueprint<BlueprintBuff, BlueprintBuffReference>>? buffs = null,
        SpellDescriptorWrapper? descriptor = null,
        SpellSchool[]? schools = null)
    {
      var component = new SuppressBuffs();
      component.m_Buffs = buffs?.Select(bp => bp.Reference)?.ToArray() ?? component.m_Buffs;
      if (component.m_Buffs is null)
      {
        component.m_Buffs = new BlueprintBuffReference[0];
      }
      component.Descriptor = descriptor ?? component.Descriptor;
      component.Schools = schools ?? component.Schools;
      if (component.Schools is null)
      {
        component.Schools = new SpellSchool[0];
      }
      return AddComponent(component);
    }

    /// <summary>
    /// Adds <see cref="SuppressDismember"/>
    /// </summary>
    ///
    /// <remarks>
    ///
    /// <list type="bullet">
    /// <listheader>Used by</listheader>
    /// <item><term>ArmyGallu</term><description>24baa2abbdc2457b99570feeb304df99</description></item>
    /// <item><term>SwarmProtectCorpseEnemyBuff</term><description>1b80a47345fc4ca9906894e9ae6c53f3</description></item>
    /// </list>
    /// </remarks>
    public TBuilder AddSuppressDismember()
    {
      return AddComponent(new SuppressDismember());
    }

    /// <summary>
    /// Adds <see cref="SwarmAoeVulnerability"/>
    /// </summary>
    ///
    /// <remarks>
    ///
    /// <list type="bullet">
    /// <listheader>Used by</listheader>
    /// <item><term>SwarmDiminutiveFeature</term><description>2e3e840ab458ce04c92064489f87ecc2</description></item>
    /// <item><term>SwarmFeastExtraBuff</term><description>77558f3e79847bb448aa980a1aee326e</description></item>
    /// <item><term>SwarmTinyFeature</term><description>5a04735fd0e952142bfc8ecf995e2361</description></item>
    /// </list>
    /// </remarks>
    public TBuilder AddSwarmAoeVulnerability()
    {
      return AddComponent(new SwarmAoeVulnerability());
    }

    /// <summary>
    /// Adds <see cref="SwarmDamageResistance"/>
    /// </summary>
    ///
    /// <remarks>
    ///
    /// <list type="bullet">
    /// <listheader>Used by</listheader>
    /// <item><term>AeonInThePast_DemonLordDeskar</term><description>f896dd504b3509b4abd42f01e26140da</description></item>
    /// <item><term>EyeOfTheSwarmFeature</term><description>73c9302686b957d4dae298061eb9ffe1</description></item>
    /// <item><term>SwarmTinyFeature</term><description>5a04735fd0e952142bfc8ecf995e2361</description></item>
    /// </list>
    /// </remarks>
    public TBuilder AddSwarmDamageResistance(
        bool? diminutiveOrLower = null)
    {
      var component = new SwarmDamageResistance();
      component.DiminutiveOrLower = diminutiveOrLower ?? component.DiminutiveOrLower;
      return AddComponent(component);
    }

    /// <summary>
    /// Adds <see cref="TricksterParry"/>
    /// </summary>
    ///
    /// <remarks>
    ///
    /// <list type="bullet">
    /// <listheader>Used by</listheader>
    /// <item><term>TricksterMobilityTier3Feature</term><description>6db3651d9af54f28b5a3a5570f49f349</description></item>
    /// </list>
    /// </remarks>
    public TBuilder AddTricksterParry()
    {
      return AddComponent(new TricksterParry());
    }

    /// <summary>
    /// Adds <see cref="UnearthlyGrace"/>
    /// </summary>
    ///
    /// <remarks>
    ///
    /// <para>
    /// ComponentName: Unearthly Grace
    /// </para>
    ///
    /// <list type="bullet">
    /// <listheader>Used by</listheader>
    /// <item><term>Ssilameshnik_Feature_GraceOfTheVoid</term><description>5b732dd5991d42c19b8b5d7105ce148e</description></item>
    /// <item><term>UnearthlyGrace</term><description>3147fbdf665190d40bc2694b31827c03</description></item>
    /// </list>
    /// </remarks>
    ///
    /// <param name="merge">
    /// If mergeBehavior is ComponentMerge.Merge and the component already exists, this expression is called to merge the components.
    /// </param>
    /// <param name="mergeBehavior">
    /// Handling if the component already exists since the component is unique. Defaults to ComponentMerge.Fail.
    /// </param>
    public TBuilder AddUnearthlyGrace(
        Action<BlueprintComponent, BlueprintComponent>? merge = null,
        ComponentMerge mergeBehavior = ComponentMerge.Merge)
    {
      var component = new UnearthlyGrace();
      return AddUniqueComponent(component, mergeBehavior, merge);
    }

    /// <summary>
    /// Adds <see cref="UnfailingBeacon"/>
    /// </summary>
    ///
    /// <remarks>
    ///
    /// <list type="bullet">
    /// <listheader>Used by</listheader>
    /// <item><term>UnfailingBeaconBuff</term><description>05de8faa859c32d41838326ab1674272</description></item>
    /// </list>
    /// </remarks>
    public TBuilder AddUnfailingBeacon()
    {
      return AddComponent(new UnfailingBeacon());
    }

    /// <summary>
    /// Adds <see cref="UnholyGrace"/>
    /// </summary>
    ///
    /// <remarks>
    ///
    /// <para>
    /// ComponentName: Unholy Grace
    /// </para>
    ///
    /// <list type="bullet">
    /// <listheader>Used by</listheader>
    /// <item><term>SosielQ2_ShadowGreater_Feature</term><description>cb1ddd699a8e63942a54e70ccfa634de</description></item>
    /// <item><term>UnholyGrace</term><description>2334cca051360914d970839e81b1f7d9</description></item>
    /// </list>
    /// </remarks>
    ///
    /// <param name="merge">
    /// If mergeBehavior is ComponentMerge.Merge and the component already exists, this expression is called to merge the components.
    /// </param>
    /// <param name="mergeBehavior">
    /// Handling if the component already exists since the component is unique. Defaults to ComponentMerge.Fail.
    /// </param>
    public TBuilder AddUnholyGrace(
        Action<BlueprintComponent, BlueprintComponent>? merge = null,
        ComponentMerge mergeBehavior = ComponentMerge.Merge)
    {
      var component = new UnholyGrace();
      return AddUniqueComponent(component, mergeBehavior, merge);
    }

    /// <summary>
    /// Adds <see cref="UnitHealthGuard"/>
    /// </summary>
    ///
    /// <remarks>
    ///
    /// <list type="bullet">
    /// <listheader>Used by</listheader>
    /// <item><term>DenyDeathBuff</term><description>632cad6b7c66b8449a300c6476fd5e1b</description></item>
    /// <item><term>NPC_HealthGuard50</term><description>0908c83fa243917459a8d40357b588c2</description></item>
    /// <item><term>PuzzleEvent_HealthGuard3</term><description>08e61dbd53fb61b4786e86399c99a78a</description></item>
    /// </list>
    /// </remarks>
    ///
    /// <param name="healthPercent">
    /// <para>
    /// Tooltip: 0 means 1 HP
    /// </para>
    /// </param>
    /// <param name="merge">
    /// If mergeBehavior is ComponentMerge.Merge and the component already exists, this expression is called to merge the components.
    /// </param>
    /// <param name="mergeBehavior">
    /// Handling if the component already exists since the component is unique. Defaults to ComponentMerge.Fail.
    /// </param>
    public TBuilder AddUnitHealthGuard(
        int? healthPercent = null,
        Action<BlueprintComponent, BlueprintComponent>? merge = null,
        ComponentMerge mergeBehavior = ComponentMerge.Merge)
    {
      var component = new UnitHealthGuard();
      component.HealthPercent = healthPercent ?? component.HealthPercent;
      return AddUniqueComponent(component, mergeBehavior, merge);
    }

    /// <summary>
    /// Adds <see cref="Untargetable"/>
    /// </summary>
    ///
    /// <remarks>
    ///
    /// <list type="bullet">
    /// <listheader>Used by</listheader>
    /// <item><term>AeonRewindBuffInvulnerability</term><description>60d3a35795d479743afce3a38aea62ec</description></item>
    /// <item><term>NightcrawlerBurrowedBuff</term><description>c568b045991644c89c58667c6a17180d</description></item>
    /// <item><term>Valmallos_Buff_ProtectiveDome</term><description>ac10126afb1e4769b291c8f122d54881</description></item>
    /// </list>
    /// </remarks>
    public TBuilder AddUntargetable()
    {
      return AddComponent(new Untargetable());
    }

    /// <summary>
    /// Adds <see cref="WeaponTraining"/>
    /// </summary>
    ///
    /// <remarks>
    ///
    /// <list type="bullet">
    /// <listheader>Used by</listheader>
    /// <item><term>TwoHandedFighterWeaponTraining</term><description>88da2a5dfc505054f933bb81014e864f</description></item>
    /// <item><term>WeaponTrainingHeavyBlades</term><description>2a0ce0186af38ed419f47fce16f93c2a</description></item>
    /// <item><term>WeaponTrainingThrown</term><description>0bbf10151dd1d8d4c8653d245e425453</description></item>
    /// </list>
    /// </remarks>
    public TBuilder AddWeaponTraining()
    {
      return AddComponent(new WeaponTraining());
    }

    /// <summary>
    /// Adds <see cref="WeaponTrainingAttackStatReplacement"/>
    /// </summary>
    ///
    /// <remarks>
    ///
    /// <para>
    /// ComponentName: Replace attack stat for weapon training
    /// </para>
    ///
    /// <list type="bullet">
    /// <listheader>Used by</listheader>
    /// <item><term>FightersFinesse</term><description>2f1619e253ea6a04087def71c7925715</description></item>
    /// </list>
    /// </remarks>
    public TBuilder AddWeaponTrainingAttackStatReplacement(
        StatType? replacementStat = null)
    {
      var component = new WeaponTrainingAttackStatReplacement();
      component.ReplacementStat = replacementStat ?? component.ReplacementStat;
      return AddComponent(component);
    }

    /// <summary>
    /// Adds <see cref="AddKineticistAcceptBurnTrigger"/>
    /// </summary>
    ///
    /// <remarks>
    ///
    /// <list type="bullet">
    /// <listheader>Used by</listheader>
    /// <item><term>GatherPowerBuffI</term><description>e6b8b31e1f8c524458dc62e8a763cfb1</description></item>
    /// <item><term>GatherPowerBuffIII</term><description>82eb0c274eddd8849bb89a8e6dbc65f8</description></item>
    /// <item><term>MentalOverflowEffectFeature</term><description>5441bfcff6f1c4846ae103ca1e500619</description></item>
    /// </list>
    /// </remarks>
    public TBuilder AddKineticistAcceptBurnTrigger(
        ActionsBuilder? action = null)
    {
      var component = new AddKineticistAcceptBurnTrigger();
      component.Action = action?.Build() ?? component.Action;
      if (component.Action is null)
      {
        component.Action = Utils.Constants.Empty.Actions;
      }
      return AddComponent(component);
    }

    /// <summary>
    /// Adds <see cref="AddKineticistBurnModifier"/>
    /// </summary>
    ///
    /// <remarks>
    ///
    /// <list type="bullet">
    /// <listheader>Used by</listheader>
    /// <item><term>BleedingInfusionBuff</term><description>492a8156ecede6345a8e82475eed85ac</description></item>
    /// <item><term>MetakinesisEmpowerBuff</term><description>f5f3aa17dd579ff49879923fb7bc2adb</description></item>
    /// <item><term>VampiricInfusionEffectBuff</term><description>c27e70fddac337745943f8151cec0709</description></item>
    /// </list>
    /// </remarks>
    ///
    /// <param name="appliableTo">
    /// <para>
    /// Blueprint of type BlueprintAbility. You can pass in the blueprint using:
    /// <list type ="bullet">
    ///   <item><term>A blueprint instance</term></item>
    ///   <item><term>A blueprint reference</term></item>
    ///   <item><term>A blueprint id as a string, Guid, or BlueprintGuid</term></item>
    ///   <item><term>A blueprint name registered with <see cref="BlueprintCore.Utils.BlueprintTool">BlueprintTool</see></term></item>
    /// </list>
    /// See <see cref="BlueprintCore.Utils.Blueprint{{T, TRef}}">Blueprint</see> for more details.
    /// </para>
    /// </param>
    public TBuilder AddKineticistBurnModifier(
        List<Blueprint<BlueprintAbility, BlueprintAbilityReference>>? appliableTo = null,
        KineticistBurnType? burnType = null,
        ContextValue? burnValue = null,
        bool? removeBuffOnAcceptBurn = null,
        bool? useContextValue = null,
        int? value = null)
    {
      var component = new AddKineticistBurnModifier();
      component.m_AppliableTo = appliableTo?.Select(bp => bp.Reference)?.ToArray() ?? component.m_AppliableTo;
      if (component.m_AppliableTo is null)
      {
        component.m_AppliableTo = new BlueprintAbilityReference[0];
      }
      component.BurnType = burnType ?? component.BurnType;
      component.BurnValue = burnValue ?? component.BurnValue;
      if (component.BurnValue is null)
      {
        component.BurnValue = ContextValues.Constant(0);
      }
      component.RemoveBuffOnAcceptBurn = removeBuffOnAcceptBurn ?? component.RemoveBuffOnAcceptBurn;
      component.UseContextValue = useContextValue ?? component.UseContextValue;
      component.Value = value ?? component.Value;
      return AddComponent(component);
    }

    /// <summary>
    /// Adds <see cref="AddKineticistBurnValueChangedTrigger"/>
    /// </summary>
    ///
    /// <remarks>
    ///
    /// <list type="bullet">
    /// <listheader>Used by</listheader>
    /// <item><term>AerialAdaptationFeature</term><description>c8719b3c5c0d4694cb13abcc3b7e893b</description></item>
    /// <item><term>ElementalEngineBurnoutTriggerFeature</term><description>090d39a5813d4537ba24b55fff7fe6be</description></item>
    /// <item><term>PsychokineticistBurnFeature</term><description>2fa48527ba627254ba9bf4556330a4d4</description></item>
    /// </list>
    /// </remarks>
    public TBuilder AddKineticistBurnValueChangedTrigger(
        ActionsBuilder? action = null)
    {
      var component = new AddKineticistBurnValueChangedTrigger();
      component.Action = action?.Build() ?? component.Action;
      if (component.Action is null)
      {
        component.Action = Utils.Constants.Empty.Actions;
      }
      return AddComponent(component);
    }

    /// <summary>
    /// Adds <see cref="AddKineticistElementalOverflow"/>
    /// </summary>
    ///
    /// <remarks>
    ///
    /// <list type="bullet">
    /// <listheader>Used by</listheader>
    /// <item><term>DarkElementalistOverflowBonusBuff</term><description>55cd730930d78c946955e85aabd73412</description></item>
    /// <item><term>ElementalEngineBurnoutFeature</term><description>f7c534123e334f3a99c7683962936075</description></item>
    /// <item><term>ElementalOverflowBonusFeature</term><description>2496916d8465dbb4b9ddeafdf28c67d8</description></item>
    /// </list>
    /// </remarks>
    ///
    /// <param name="firesFury">
    /// <para>
    /// Blueprint of type BlueprintUnitFact. You can pass in the blueprint using:
    /// <list type ="bullet">
    ///   <item><term>A blueprint instance</term></item>
    ///   <item><term>A blueprint reference</term></item>
    ///   <item><term>A blueprint id as a string, Guid, or BlueprintGuid</term></item>
    ///   <item><term>A blueprint name registered with <see cref="BlueprintCore.Utils.BlueprintTool">BlueprintTool</see></term></item>
    /// </list>
    /// See <see cref="BlueprintCore.Utils.Blueprint{{T, TRef}}">Blueprint</see> for more details.
    /// </para>
    /// </param>
    public TBuilder AddKineticistElementalOverflow(
        ContextValue? bonus = null,
        bool? elementalEngine = null,
        Blueprint<BlueprintUnitFact, BlueprintUnitFactReference>? firesFury = null,
        bool? ignoreBurn = null)
    {
      var component = new AddKineticistElementalOverflow();
      component.Bonus = bonus ?? component.Bonus;
      if (component.Bonus is null)
      {
        component.Bonus = ContextValues.Constant(0);
      }
      component.ElementalEngine = elementalEngine ?? component.ElementalEngine;
      component.m_FiresFury = firesFury?.Reference ?? component.m_FiresFury;
      if (component.m_FiresFury is null)
      {
        component.m_FiresFury = BlueprintTool.GetRef<BlueprintUnitFactReference>(null);
      }
      component.IgnoreBurn = ignoreBurn ?? component.IgnoreBurn;
      return AddComponent(component);
    }

    /// <summary>
    /// Adds <see cref="AddKineticistPart"/>
    /// </summary>
    ///
    /// <remarks>
    ///
    /// <list type="bullet">
    /// <listheader>Used by</listheader>
    /// <item><term>BurnFeature</term><description>57e3577a0eb53294e9d7cc649d5239a3</description></item>
    /// <item><term>OverwhelmingSoulBurnFeature</term><description>a3051f965d971ed44b9c6c63bf240b79</description></item>
    /// <item><term>PsychokineticistBurnFeature</term><description>2fa48527ba627254ba9bf4556330a4d4</description></item>
    /// </list>
    /// </remarks>
    ///
    /// <param name="bladeActivatedBuff">
    /// <para>
    /// Blueprint of type BlueprintBuff. You can pass in the blueprint using:
    /// <list type ="bullet">
    ///   <item><term>A blueprint instance</term></item>
    ///   <item><term>A blueprint reference</term></item>
    ///   <item><term>A blueprint id as a string, Guid, or BlueprintGuid</term></item>
    ///   <item><term>A blueprint name registered with <see cref="BlueprintCore.Utils.BlueprintTool">BlueprintTool</see></term></item>
    /// </list>
    /// See <see cref="BlueprintCore.Utils.Blueprint{{T, TRef}}">Blueprint</see> for more details.
    /// </para>
    /// </param>
    /// <param name="blasts">
    /// <para>
    /// Blueprint of type BlueprintAbility. You can pass in the blueprint using:
    /// <list type ="bullet">
    ///   <item><term>A blueprint instance</term></item>
    ///   <item><term>A blueprint reference</term></item>
    ///   <item><term>A blueprint id as a string, Guid, or BlueprintGuid</term></item>
    ///   <item><term>A blueprint name registered with <see cref="BlueprintCore.Utils.BlueprintTool">BlueprintTool</see></term></item>
    /// </list>
    /// See <see cref="BlueprintCore.Utils.Blueprint{{T, TRef}}">Blueprint</see> for more details.
    /// </para>
    /// </param>
    /// <param name="canGatherPowerWithShieldBuff">
    /// <para>
    /// Blueprint of type BlueprintBuff. You can pass in the blueprint using:
    /// <list type ="bullet">
    ///   <item><term>A blueprint instance</term></item>
    ///   <item><term>A blueprint reference</term></item>
    ///   <item><term>A blueprint id as a string, Guid, or BlueprintGuid</term></item>
    ///   <item><term>A blueprint name registered with <see cref="BlueprintCore.Utils.BlueprintTool">BlueprintTool</see></term></item>
    /// </list>
    /// See <see cref="BlueprintCore.Utils.Blueprint{{T, TRef}}">Blueprint</see> for more details.
    /// </para>
    /// </param>
    /// <param name="clazz">
    /// <para>
    /// Blueprint of type BlueprintCharacterClass. You can pass in the blueprint using:
    /// <list type ="bullet">
    ///   <item><term>A blueprint instance</term></item>
    ///   <item><term>A blueprint reference</term></item>
    ///   <item><term>A blueprint id as a string, Guid, or BlueprintGuid</term></item>
    ///   <item><term>A blueprint name registered with <see cref="BlueprintCore.Utils.BlueprintTool">BlueprintTool</see></term></item>
    /// </list>
    /// See <see cref="BlueprintCore.Utils.Blueprint{{T, TRef}}">Blueprint</see> for more details.
    /// </para>
    /// </param>
    /// <param name="gatherPowerAbility">
    /// <para>
    /// Blueprint of type BlueprintAbility. You can pass in the blueprint using:
    /// <list type ="bullet">
    ///   <item><term>A blueprint instance</term></item>
    ///   <item><term>A blueprint reference</term></item>
    ///   <item><term>A blueprint id as a string, Guid, or BlueprintGuid</term></item>
    ///   <item><term>A blueprint name registered with <see cref="BlueprintCore.Utils.BlueprintTool">BlueprintTool</see></term></item>
    /// </list>
    /// See <see cref="BlueprintCore.Utils.Blueprint{{T, TRef}}">Blueprint</see> for more details.
    /// </para>
    /// </param>
    /// <param name="gatherPowerBuff1">
    /// <para>
    /// Blueprint of type BlueprintBuff. You can pass in the blueprint using:
    /// <list type ="bullet">
    ///   <item><term>A blueprint instance</term></item>
    ///   <item><term>A blueprint reference</term></item>
    ///   <item><term>A blueprint id as a string, Guid, or BlueprintGuid</term></item>
    ///   <item><term>A blueprint name registered with <see cref="BlueprintCore.Utils.BlueprintTool">BlueprintTool</see></term></item>
    /// </list>
    /// See <see cref="BlueprintCore.Utils.Blueprint{{T, TRef}}">Blueprint</see> for more details.
    /// </para>
    /// </param>
    /// <param name="gatherPowerBuff2">
    /// <para>
    /// Blueprint of type BlueprintBuff. You can pass in the blueprint using:
    /// <list type ="bullet">
    ///   <item><term>A blueprint instance</term></item>
    ///   <item><term>A blueprint reference</term></item>
    ///   <item><term>A blueprint id as a string, Guid, or BlueprintGuid</term></item>
    ///   <item><term>A blueprint name registered with <see cref="BlueprintCore.Utils.BlueprintTool">BlueprintTool</see></term></item>
    /// </list>
    /// See <see cref="BlueprintCore.Utils.Blueprint{{T, TRef}}">Blueprint</see> for more details.
    /// </para>
    /// </param>
    /// <param name="gatherPowerBuff3">
    /// <para>
    /// Blueprint of type BlueprintBuff. You can pass in the blueprint using:
    /// <list type ="bullet">
    ///   <item><term>A blueprint instance</term></item>
    ///   <item><term>A blueprint reference</term></item>
    ///   <item><term>A blueprint id as a string, Guid, or BlueprintGuid</term></item>
    ///   <item><term>A blueprint name registered with <see cref="BlueprintCore.Utils.BlueprintTool">BlueprintTool</see></term></item>
    /// </list>
    /// See <see cref="BlueprintCore.Utils.Blueprint{{T, TRef}}">Blueprint</see> for more details.
    /// </para>
    /// </param>
    /// <param name="gatherPowerIncreaseFeature">
    /// <para>
    /// Tooltip: Gather Power base = 0 + 1 for each rank of this feature
    /// </para>
    /// <para>
    /// Blueprint of type BlueprintFeature. You can pass in the blueprint using:
    /// <list type ="bullet">
    ///   <item><term>A blueprint instance</term></item>
    ///   <item><term>A blueprint reference</term></item>
    ///   <item><term>A blueprint id as a string, Guid, or BlueprintGuid</term></item>
    ///   <item><term>A blueprint name registered with <see cref="BlueprintCore.Utils.BlueprintTool">BlueprintTool</see></term></item>
    /// </list>
    /// See <see cref="BlueprintCore.Utils.Blueprint{{T, TRef}}">Blueprint</see> for more details.
    /// </para>
    /// </param>
    /// <param name="maxBurn">
    /// <para>
    /// Blueprint of type BlueprintAbilityResource. You can pass in the blueprint using:
    /// <list type ="bullet">
    ///   <item><term>A blueprint instance</term></item>
    ///   <item><term>A blueprint reference</term></item>
    ///   <item><term>A blueprint id as a string, Guid, or BlueprintGuid</term></item>
    ///   <item><term>A blueprint name registered with <see cref="BlueprintCore.Utils.BlueprintTool">BlueprintTool</see></term></item>
    /// </list>
    /// See <see cref="BlueprintCore.Utils.Blueprint{{T, TRef}}">Blueprint</see> for more details.
    /// </para>
    /// </param>
    /// <param name="maxBurnPerRound">
    /// <para>
    /// Blueprint of type BlueprintAbilityResource. You can pass in the blueprint using:
    /// <list type ="bullet">
    ///   <item><term>A blueprint instance</term></item>
    ///   <item><term>A blueprint reference</term></item>
    ///   <item><term>A blueprint id as a string, Guid, or BlueprintGuid</term></item>
    ///   <item><term>A blueprint name registered with <see cref="BlueprintCore.Utils.BlueprintTool">BlueprintTool</see></term></item>
    /// </list>
    /// See <see cref="BlueprintCore.Utils.Blueprint{{T, TRef}}">Blueprint</see> for more details.
    /// </para>
    /// </param>
    public TBuilder AddKineticistPart(
        Blueprint<BlueprintBuff, BlueprintBuffReference>? bladeActivatedBuff = null,
        List<Blueprint<BlueprintAbility, BlueprintAbilityReference>>? blasts = null,
        Blueprint<BlueprintBuff, BlueprintBuffReference>? canGatherPowerWithShieldBuff = null,
        Blueprint<BlueprintCharacterClass, BlueprintCharacterClassReference>? clazz = null,
        Blueprint<BlueprintAbility, BlueprintAbilityReference>? gatherPowerAbility = null,
        Blueprint<BlueprintBuff, BlueprintBuffReference>? gatherPowerBuff1 = null,
        Blueprint<BlueprintBuff, BlueprintBuffReference>? gatherPowerBuff2 = null,
        Blueprint<BlueprintBuff, BlueprintBuffReference>? gatherPowerBuff3 = null,
        Blueprint<BlueprintFeature, BlueprintFeatureReference>? gatherPowerIncreaseFeature = null,
        StatType? mainStat = null,
        Blueprint<BlueprintAbilityResource, BlueprintAbilityResourceReference>? maxBurn = null,
        Blueprint<BlueprintAbilityResource, BlueprintAbilityResourceReference>? maxBurnPerRound = null)
    {
      var component = new AddKineticistPart();
      component.m_BladeActivatedBuff = bladeActivatedBuff?.Reference ?? component.m_BladeActivatedBuff;
      if (component.m_BladeActivatedBuff is null)
      {
        component.m_BladeActivatedBuff = BlueprintTool.GetRef<BlueprintBuffReference>(null);
      }
      component.m_Blasts = blasts?.Select(bp => bp.Reference)?.ToArray() ?? component.m_Blasts;
      if (component.m_Blasts is null)
      {
        component.m_Blasts = new BlueprintAbilityReference[0];
      }
      component.m_CanGatherPowerWithShieldBuff = canGatherPowerWithShieldBuff?.Reference ?? component.m_CanGatherPowerWithShieldBuff;
      if (component.m_CanGatherPowerWithShieldBuff is null)
      {
        component.m_CanGatherPowerWithShieldBuff = BlueprintTool.GetRef<BlueprintBuffReference>(null);
      }
      component.m_Class = clazz?.Reference ?? component.m_Class;
      if (component.m_Class is null)
      {
        component.m_Class = BlueprintTool.GetRef<BlueprintCharacterClassReference>(null);
      }
      component.m_GatherPowerAbility = gatherPowerAbility?.Reference ?? component.m_GatherPowerAbility;
      if (component.m_GatherPowerAbility is null)
      {
        component.m_GatherPowerAbility = BlueprintTool.GetRef<BlueprintAbilityReference>(null);
      }
      component.m_GatherPowerBuff1 = gatherPowerBuff1?.Reference ?? component.m_GatherPowerBuff1;
      if (component.m_GatherPowerBuff1 is null)
      {
        component.m_GatherPowerBuff1 = BlueprintTool.GetRef<BlueprintBuffReference>(null);
      }
      component.m_GatherPowerBuff2 = gatherPowerBuff2?.Reference ?? component.m_GatherPowerBuff2;
      if (component.m_GatherPowerBuff2 is null)
      {
        component.m_GatherPowerBuff2 = BlueprintTool.GetRef<BlueprintBuffReference>(null);
      }
      component.m_GatherPowerBuff3 = gatherPowerBuff3?.Reference ?? component.m_GatherPowerBuff3;
      if (component.m_GatherPowerBuff3 is null)
      {
        component.m_GatherPowerBuff3 = BlueprintTool.GetRef<BlueprintBuffReference>(null);
      }
      component.m_GatherPowerIncreaseFeature = gatherPowerIncreaseFeature?.Reference ?? component.m_GatherPowerIncreaseFeature;
      if (component.m_GatherPowerIncreaseFeature is null)
      {
        component.m_GatherPowerIncreaseFeature = BlueprintTool.GetRef<BlueprintFeatureReference>(null);
      }
      component.MainStat = mainStat ?? component.MainStat;
      component.m_MaxBurn = maxBurn?.Reference ?? component.m_MaxBurn;
      if (component.m_MaxBurn is null)
      {
        component.m_MaxBurn = BlueprintTool.GetRef<BlueprintAbilityResourceReference>(null);
      }
      component.m_MaxBurnPerRound = maxBurnPerRound?.Reference ?? component.m_MaxBurnPerRound;
      if (component.m_MaxBurnPerRound is null)
      {
        component.m_MaxBurnPerRound = BlueprintTool.GetRef<BlueprintAbilityResourceReference>(null);
      }
      return AddComponent(component);
    }

    /// <summary>
    /// Adds <see cref="SetKineticistGatherPowerMode"/>
    /// </summary>
    ///
    /// <remarks>
    ///
    /// <list type="bullet">
    /// <listheader>Used by</listheader>
    /// <item><term>GatherPowerModeHighBuff</term><description>6ee9b24babece5540a053ed1a8a888a9</description></item>
    /// <item><term>GatherPowerModeLowBuff</term><description>67f0041083fb121498221ca327d9c03f</description></item>
    /// <item><term>GatherPowerModeMediumBuff</term><description>bbb7d01201f3b9c4a838eddf2285941a</description></item>
    /// </list>
    /// </remarks>
    public TBuilder AddSetKineticistGatherPowerMode(
        KineticistGatherPowerMode? mode = null)
    {
      var component = new SetKineticistGatherPowerMode();
      component.Mode = mode ?? component.Mode;
      return AddComponent(component);
    }

    /// <summary>
    /// Adds <see cref="ChangeHitDie"/>
    /// </summary>
    ///
    /// <remarks>
    ///
    /// <list type="bullet">
    /// <listheader>Used by</listheader>
    /// <item><term>DragonLevel1Immunities</term><description>040bb87b39e4a7f4a8ddc011c5a50523</description></item>
    /// </list>
    /// </remarks>
    public TBuilder AddChangeHitDie(
        DiceType? hitDie = null)
    {
      var component = new ChangeHitDie();
      component.m_HitDie = hitDie ?? component.m_HitDie;
      return AddComponent(component);
    }

    /// <summary>
    /// Adds <see cref="AddEnergyDamageTrigger"/>
    /// </summary>
    ///
    /// <remarks>
    ///
    /// <list type="bullet">
    /// <listheader>Used by</listheader>
    /// <item><term>ArcanistExploitIcyTombBuff</term><description>fb64c249d44317443bb1f2271ed963af</description></item>
    /// <item><term>ShamanHexBeckoningChillBuff</term><description>8c8d267be61412444a0728678bed82ab</description></item>
    /// <item><term>TrollBrandedProtection</term><description>8aad45a750a76b84ea5163fed362f215</description></item>
    /// </list>
    /// </remarks>
    ///
    /// <param name="damageType">
    /// <para>
    /// InfoBox: Triggers on Incoming damage
    /// </para>
    /// </param>
    /// <param name="merge">
    /// If mergeBehavior is ComponentMerge.Merge and the component already exists, this expression is called to merge the components.
    /// </param>
    /// <param name="mergeBehavior">
    /// Handling if the component already exists since the component is unique. Defaults to ComponentMerge.Fail.
    /// </param>
    public TBuilder AddEnergyDamageTrigger(
        ActionsBuilder? actions = null,
        DamageEnergyType? damageType = null,
        Action<BlueprintComponent, BlueprintComponent>? merge = null,
        ComponentMerge mergeBehavior = ComponentMerge.Merge,
        bool? spellsOnly = null)
    {
      var component = new AddEnergyDamageTrigger();
      component.Actions = actions?.Build() ?? component.Actions;
      if (component.Actions is null)
      {
        component.Actions = Utils.Constants.Empty.Actions;
      }
      component.DamageType = damageType ?? component.DamageType;
      component.SpellsOnly = spellsOnly ?? component.SpellsOnly;
      return AddUniqueComponent(component, mergeBehavior, merge);
    }

    /// <summary>
    /// Adds <see cref="AddIncomingDamageTrigger"/>
    /// </summary>
    ///
    /// <remarks>
    ///
    /// <list type="bullet">
    /// <listheader>Used by</listheader>
    /// <item><term>AngelPhoenixGiftBuff</term><description>9988e25ec217c0249a28213e7dc0017c</description></item>
    /// <item><term>FascinateEffectBuff</term><description>2d4bd347dec7d8648afd502ee40ae661</description></item>
    /// <item><term>WitchHexSlumberBuff</term><description>d36e15046cc86c0418c69b8e13f29602</description></item>
    /// </list>
    /// </remarks>
    ///
    /// <param name="merge">
    /// If mergeBehavior is ComponentMerge.Merge and the component already exists, this expression is called to merge the components.
    /// </param>
    /// <param name="mergeBehavior">
    /// Handling if the component already exists since the component is unique. Defaults to ComponentMerge.Fail.
    /// </param>
    public TBuilder AddIncomingDamageTrigger(
        ActionsBuilder? actions = null,
        AttackTypeFlag? attackType = null,
        bool? checkDamageDealt = null,
        bool? checkDamagePhysicalTypeNot = null,
        bool? checkEnergyDamageType = null,
        bool? checkWeaponAttackType = null,
        CompareOperation.Type? compareType = null,
        PhysicalDamageForm? damagePhysicalTypeNot = null,
        DamageEnergyType? energyType = null,
        bool? ignoreDamageFromThisFact = null,
        Action<BlueprintComponent, BlueprintComponent>? merge = null,
        ComponentMerge mergeBehavior = ComponentMerge.Merge,
        bool? reduceBelowZero = null,
        ContextValue? targetValue = null,
        bool? triggerOnStatDamageOrEnergyDrain = null)
    {
      var component = new AddIncomingDamageTrigger();
      component.Actions = actions?.Build() ?? component.Actions;
      if (component.Actions is null)
      {
        component.Actions = Utils.Constants.Empty.Actions;
      }
      component.AttackType = attackType ?? component.AttackType;
      component.CheckDamageDealt = checkDamageDealt ?? component.CheckDamageDealt;
      component.CheckDamagePhysicalTypeNot = checkDamagePhysicalTypeNot ?? component.CheckDamagePhysicalTypeNot;
      component.CheckEnergyDamageType = checkEnergyDamageType ?? component.CheckEnergyDamageType;
      component.CheckWeaponAttackType = checkWeaponAttackType ?? component.CheckWeaponAttackType;
      component.CompareType = compareType ?? component.CompareType;
      component.DamagePhysicalTypeNot = damagePhysicalTypeNot ?? component.DamagePhysicalTypeNot;
      component.EnergyType = energyType ?? component.EnergyType;
      component.IgnoreDamageFromThisFact = ignoreDamageFromThisFact ?? component.IgnoreDamageFromThisFact;
      component.ReduceBelowZero = reduceBelowZero ?? component.ReduceBelowZero;
      component.TargetValue = targetValue ?? component.TargetValue;
      if (component.TargetValue is null)
      {
        component.TargetValue = ContextValues.Constant(0);
      }
      component.TriggerOnStatDamageOrEnergyDrain = triggerOnStatDamageOrEnergyDrain ?? component.TriggerOnStatDamageOrEnergyDrain;
      return AddUniqueComponent(component, mergeBehavior, merge);
    }

    /// <summary>
    /// Adds <see cref="AddInitiatorPartySkillRollTrigger"/>
    /// </summary>
    ///
    /// <remarks>
    ///
    /// <list type="bullet">
    /// <listheader>Used by</listheader>
    /// <item><term>GuidanceBuff</term><description>ec931b882e806ce42906597e5585c13f</description></item>
    /// </list>
    /// </remarks>
    public TBuilder AddInitiatorPartySkillRollTrigger(
        ActionsBuilder? action = null,
        bool? onlySuccess = null,
        StatType? skill = null)
    {
      var component = new AddInitiatorPartySkillRollTrigger();
      component.Action = action?.Build() ?? component.Action;
      if (component.Action is null)
      {
        component.Action = Utils.Constants.Empty.Actions;
      }
      component.OnlySuccess = onlySuccess ?? component.OnlySuccess;
      component.Skill = skill ?? component.Skill;
      return AddComponent(component);
    }

    /// <summary>
    /// Adds <see cref="AddInitiatorSavingThrowTrigger"/>
    /// </summary>
    ///
    /// <remarks>
    ///
    /// <list type="bullet">
    /// <listheader>Used by</listheader>
    /// <item><term>AmuletOfUnforgivingElementsAcidBuff</term><description>e6e363e8bd8074047bef3b286f159fe8</description></item>
    /// <item><term>AmuletOfUnforgivingElementsFireBuff</term><description>d689969421f4dfd45b332aba08cdfa60</description></item>
    /// <item><term>SongOfHeroicResolveEffectBuff</term><description>4eafdc4608d89f84b82089953bc54e59</description></item>
    /// </list>
    /// </remarks>
    ///
    /// <param name="chooseSave">
    /// <para>
    /// InfoBox: Don't use Unknown - will not work on any throw
    /// </para>
    /// </param>
    public TBuilder AddInitiatorSavingThrowTrigger(
        ActionsBuilder? action = null,
        SavingThrowType? chooseSave = null,
        bool? onlyFail = null,
        bool? onlyPass = null,
        bool? specificSave = null)
    {
      var component = new AddInitiatorSavingThrowTrigger();
      component.Action = action?.Build() ?? component.Action;
      if (component.Action is null)
      {
        component.Action = Utils.Constants.Empty.Actions;
      }
      component.ChooseSave = chooseSave ?? component.ChooseSave;
      component.OnlyFail = onlyFail ?? component.OnlyFail;
      component.OnlyPass = onlyPass ?? component.OnlyPass;
      component.SpecificSave = specificSave ?? component.SpecificSave;
      return AddComponent(component);
    }

    /// <summary>
    /// Adds <see cref="AddKineticistInfusionDamageTrigger"/>
    /// </summary>
    ///
    /// <remarks>
    ///
    /// <list type="bullet">
    /// <listheader>Used by</listheader>
    /// <item><term>BleedingInfusionBuff</term><description>492a8156ecede6345a8e82475eed85ac</description></item>
    /// <item><term>GrapplingInfusionBuff</term><description>f69a66c0feaa4374b8ca2732ee91a373</description></item>
    /// <item><term>VampiricInfusionBuff</term><description>e50e653cff511cd49a55b979346699f1</description></item>
    /// </list>
    /// </remarks>
    ///
    /// <param name="abilityList">
    /// <para>
    /// Blueprint of type BlueprintAbility. You can pass in the blueprint using:
    /// <list type ="bullet">
    ///   <item><term>A blueprint instance</term></item>
    ///   <item><term>A blueprint reference</term></item>
    ///   <item><term>A blueprint id as a string, Guid, or BlueprintGuid</term></item>
    ///   <item><term>A blueprint name registered with <see cref="BlueprintCore.Utils.BlueprintTool">BlueprintTool</see></term></item>
    /// </list>
    /// See <see cref="BlueprintCore.Utils.Blueprint{{T, TRef}}">Blueprint</see> for more details.
    /// </para>
    /// </param>
    /// <param name="weaponType">
    /// <para>
    /// Blueprint of type BlueprintWeaponType. You can pass in the blueprint using:
    /// <list type ="bullet">
    ///   <item><term>A blueprint instance</term></item>
    ///   <item><term>A blueprint reference</term></item>
    ///   <item><term>A blueprint id as a string, Guid, or BlueprintGuid</term></item>
    ///   <item><term>A blueprint name registered with <see cref="BlueprintCore.Utils.BlueprintTool">BlueprintTool</see></term></item>
    /// </list>
    /// See <see cref="BlueprintCore.Utils.Blueprint{{T, TRef}}">Blueprint</see> for more details.
    /// </para>
    /// </param>
    public TBuilder AddKineticistInfusionDamageTrigger(
        List<Blueprint<BlueprintAbility, BlueprintAbilityReference>>? abilityList = null,
        ActionsBuilder? actions = null,
        bool? checkSpellDescriptor = null,
        bool? checkSpellParent = null,
        bool? checkWeaponType = null,
        TimeSpan? lastFrameTime = null,
        SpellDescriptorWrapper? spellDescriptorsList = null,
        bool? triggerOnDirectDamage = null,
        bool? triggerOnStatDamageOrEnergyDrain = null,
        Blueprint<BlueprintWeaponType, BlueprintWeaponTypeReference>? weaponType = null)
    {
      var component = new AddKineticistInfusionDamageTrigger();
      component.m_AbilityList = abilityList?.Select(bp => bp.Reference)?.ToArray() ?? component.m_AbilityList;
      if (component.m_AbilityList is null)
      {
        component.m_AbilityList = new BlueprintAbilityReference[0];
      }
      component.Actions = actions?.Build() ?? component.Actions;
      if (component.Actions is null)
      {
        component.Actions = Utils.Constants.Empty.Actions;
      }
      component.CheckSpellDescriptor = checkSpellDescriptor ?? component.CheckSpellDescriptor;
      component.CheckSpellParent = checkSpellParent ?? component.CheckSpellParent;
      component.CheckWeaponType = checkWeaponType ?? component.CheckWeaponType;
      component.m_LastFrameTime = lastFrameTime ?? component.m_LastFrameTime;
      component.SpellDescriptorsList = spellDescriptorsList ?? component.SpellDescriptorsList;
      component.TriggerOnDirectDamage = triggerOnDirectDamage ?? component.TriggerOnDirectDamage;
      component.TriggerOnStatDamageOrEnergyDrain = triggerOnStatDamageOrEnergyDrain ?? component.TriggerOnStatDamageOrEnergyDrain;
      component.m_WeaponType = weaponType?.Reference ?? component.m_WeaponType;
      if (component.m_WeaponType is null)
      {
        component.m_WeaponType = BlueprintTool.GetRef<BlueprintWeaponTypeReference>(null);
      }
      return AddComponent(component);
    }

    /// <summary>
    /// Adds <see cref="AddOutgoingDamageTrigger"/>
    /// </summary>
    ///
    /// <remarks>
    ///
    /// <list type="bullet">
    /// <listheader>Used by</listheader>
    /// <item><term>AmuletOfUnforgivingElementsFeature</term><description>2cc9b7e8d7117a9458285333822bf95d</description></item>
    /// <item><term>ElementalBarrage</term><description>da56a1b21032a374783fdf46e1a92adb</description></item>
    /// <item><term>XantirOnlySwarm_MidnightFaneInThePastFeature</term><description>5131c4b93f314bd4589edf612b4eb600</description></item>
    /// </list>
    /// </remarks>
    ///
    /// <param name="abilityList">
    /// <para>
    /// Blueprint of type BlueprintAbility. You can pass in the blueprint using:
    /// <list type ="bullet">
    ///   <item><term>A blueprint instance</term></item>
    ///   <item><term>A blueprint reference</term></item>
    ///   <item><term>A blueprint id as a string, Guid, or BlueprintGuid</term></item>
    ///   <item><term>A blueprint name registered with <see cref="BlueprintCore.Utils.BlueprintTool">BlueprintTool</see></term></item>
    /// </list>
    /// See <see cref="BlueprintCore.Utils.Blueprint{{T, TRef}}">Blueprint</see> for more details.
    /// </para>
    /// </param>
    /// <param name="merge">
    /// If mergeBehavior is ComponentMerge.Merge and the component already exists, this expression is called to merge the components.
    /// </param>
    /// <param name="mergeBehavior">
    /// Handling if the component already exists since the component is unique. Defaults to ComponentMerge.Fail.
    /// </param>
    /// <param name="weaponType">
    /// <para>
    /// Blueprint of type BlueprintWeaponType. You can pass in the blueprint using:
    /// <list type ="bullet">
    ///   <item><term>A blueprint instance</term></item>
    ///   <item><term>A blueprint reference</term></item>
    ///   <item><term>A blueprint id as a string, Guid, or BlueprintGuid</term></item>
    ///   <item><term>A blueprint name registered with <see cref="BlueprintCore.Utils.BlueprintTool">BlueprintTool</see></term></item>
    /// </list>
    /// See <see cref="BlueprintCore.Utils.Blueprint{{T, TRef}}">Blueprint</see> for more details.
    /// </para>
    /// </param>
    public TBuilder AddOutgoingDamageTrigger(
        List<Blueprint<BlueprintAbility, BlueprintAbilityReference>>? abilityList = null,
        AbilityType? abilityType = null,
        ActionsBuilder? actions = null,
        bool? applyToAreaEffectDamage = null,
        bool? checkAbilityType = null,
        bool? checkDamageDealt = null,
        bool? checkEnergyDamageType = null,
        bool? checkSpellDescriptor = null,
        bool? checkSpellParent = null,
        bool? checkWeaponType = null,
        CompareOperation.Type? compareType = null,
        DamageEnergyType? energyType = null,
        bool? ignoreDamageFromThisFact = null,
        Action<BlueprintComponent, BlueprintComponent>? merge = null,
        ComponentMerge mergeBehavior = ComponentMerge.Merge,
        bool? notZeroDamage = null,
        SpellDescriptorWrapper? spellDescriptorsList = null,
        bool? targetKilledByThisDamage = null,
        ContextValue? targetValue = null,
        bool? triggerOnStatDamageOrEnergyDrain = null,
        Blueprint<BlueprintWeaponType, BlueprintWeaponTypeReference>? weaponType = null)
    {
      var component = new AddOutgoingDamageTrigger();
      component.m_AbilityList = abilityList?.Select(bp => bp.Reference)?.ToArray() ?? component.m_AbilityList;
      if (component.m_AbilityList is null)
      {
        component.m_AbilityList = new BlueprintAbilityReference[0];
      }
      component.m_AbilityType = abilityType ?? component.m_AbilityType;
      component.Actions = actions?.Build() ?? component.Actions;
      if (component.Actions is null)
      {
        component.Actions = Utils.Constants.Empty.Actions;
      }
      component.ApplyToAreaEffectDamage = applyToAreaEffectDamage ?? component.ApplyToAreaEffectDamage;
      component.CheckAbilityType = checkAbilityType ?? component.CheckAbilityType;
      component.CheckDamageDealt = checkDamageDealt ?? component.CheckDamageDealt;
      component.CheckEnergyDamageType = checkEnergyDamageType ?? component.CheckEnergyDamageType;
      component.CheckSpellDescriptor = checkSpellDescriptor ?? component.CheckSpellDescriptor;
      component.CheckSpellParent = checkSpellParent ?? component.CheckSpellParent;
      component.CheckWeaponType = checkWeaponType ?? component.CheckWeaponType;
      component.CompareType = compareType ?? component.CompareType;
      component.EnergyType = energyType ?? component.EnergyType;
      component.IgnoreDamageFromThisFact = ignoreDamageFromThisFact ?? component.IgnoreDamageFromThisFact;
      component.NotZeroDamage = notZeroDamage ?? component.NotZeroDamage;
      component.SpellDescriptorsList = spellDescriptorsList ?? component.SpellDescriptorsList;
      component.TargetKilledByThisDamage = targetKilledByThisDamage ?? component.TargetKilledByThisDamage;
      component.TargetValue = targetValue ?? component.TargetValue;
      if (component.TargetValue is null)
      {
        component.TargetValue = ContextValues.Constant(0);
      }
      component.TriggerOnStatDamageOrEnergyDrain = triggerOnStatDamageOrEnergyDrain ?? component.TriggerOnStatDamageOrEnergyDrain;
      component.m_WeaponType = weaponType?.Reference ?? component.m_WeaponType;
      if (component.m_WeaponType is null)
      {
        component.m_WeaponType = BlueprintTool.GetRef<BlueprintWeaponTypeReference>(null);
      }
      return AddUniqueComponent(component, mergeBehavior, merge);
    }

    /// <summary>
    /// Adds <see cref="AddSpellDiceBonusTrigger"/>
    /// </summary>
    ///
    /// <remarks>
    ///
    /// <list type="bullet">
    /// <listheader>Used by</listheader>
    /// <item><term>GoldenDragonSpellDamageFeature</term><description>a83dd922ad1441fd8224bd01a5948331</description></item>
    /// <item><term>UniversalRemedyFeature</term><description>e16e01f215ee4e4b80aa35e471a8c915</description></item>
    /// </list>
    /// </remarks>
    ///
    /// <param name="merge">
    /// If mergeBehavior is ComponentMerge.Merge and the component already exists, this expression is called to merge the components.
    /// </param>
    /// <param name="mergeBehavior">
    /// Handling if the component already exists since the component is unique. Defaults to ComponentMerge.Fail.
    /// </param>
    public TBuilder AddSpellDiceBonusTrigger(
        bool? checkSpellDescriptor = null,
        int[]? diceBonuses = null,
        ContextDiceValue[]? diceValues = null,
        Action<BlueprintComponent, BlueprintComponent>? merge = null,
        ComponentMerge mergeBehavior = ComponentMerge.Merge,
        SpellDescriptorWrapper? spellDescriptorsList = null)
    {
      var component = new AddSpellDiceBonusTrigger();
      component.CheckSpellDescriptor = checkSpellDescriptor ?? component.CheckSpellDescriptor;
      component.DiceBonuses = diceBonuses ?? component.DiceBonuses;
      if (component.DiceBonuses is null)
      {
        component.DiceBonuses = new int[0];
      }
      foreach (var item in diceValues) { Validate(item); }
      component.DiceValues = diceValues ?? component.DiceValues;
      if (component.DiceValues is null)
      {
        component.DiceValues = new ContextDiceValue[0];
      }
      component.SpellDescriptorsList = spellDescriptorsList ?? component.SpellDescriptorsList;
      return AddUniqueComponent(component, mergeBehavior, merge);
    }

    /// <summary>
    /// Adds <see cref="AddTargetAttackWithWeaponTrigger"/>
    /// </summary>
    ///
    /// <remarks>
    ///
    /// <list type="bullet">
    /// <listheader>Used by</listheader>
    /// <item><term>AngelShieldFromDemonkindBuff</term><description>121e7332029207e409a76044780cea0d</description></item>
    /// <item><term>KnightsEmblemEmeraldShortswordBuff</term><description>8d7f33098ed5fbd42b4bd76a60c481b6</description></item>
    /// <item><term>Ygefeles_WeakCopyBuff</term><description>c78769bac92ee2744b7b869d9805baf0</description></item>
    /// </list>
    /// </remarks>
    ///
    /// <param name="merge">
    /// If mergeBehavior is ComponentMerge.Merge and the component already exists, this expression is called to merge the components.
    /// </param>
    /// <param name="mergeBehavior">
    /// Handling if the component already exists since the component is unique. Defaults to ComponentMerge.Fail.
    /// </param>
    public TBuilder AddTargetAttackWithWeaponTrigger(
        ActionsBuilder? actionOnSelf = null,
        ActionsBuilder? actionsOnAttacker = null,
        WeaponCategory[]? categories = null,
        bool? checkCategory = null,
        bool? criticalHit = null,
        bool? doNotPassAttackRoll = null,
        Action<BlueprintComponent, BlueprintComponent>? merge = null,
        ComponentMerge mergeBehavior = ComponentMerge.Merge,
        bool? not = null,
        bool? notReach = null,
        bool? notSneakAttack = null,
        bool? onAttackOfOpportunity = null,
        bool? onlyHit = null,
        bool? onlyMelee = null,
        bool? onlyOnFirstAttack = null,
        bool? onlyRanged = null,
        bool? onlySneakAttack = null,
        bool? waitForAttackResolve = null)
    {
      var component = new AddTargetAttackWithWeaponTrigger();
      component.ActionOnSelf = actionOnSelf?.Build() ?? component.ActionOnSelf;
      if (component.ActionOnSelf is null)
      {
        component.ActionOnSelf = Utils.Constants.Empty.Actions;
      }
      component.ActionsOnAttacker = actionsOnAttacker?.Build() ?? component.ActionsOnAttacker;
      if (component.ActionsOnAttacker is null)
      {
        component.ActionsOnAttacker = Utils.Constants.Empty.Actions;
      }
      component.Categories = categories ?? component.Categories;
      if (component.Categories is null)
      {
        component.Categories = new WeaponCategory[0];
      }
      component.CheckCategory = checkCategory ?? component.CheckCategory;
      component.CriticalHit = criticalHit ?? component.CriticalHit;
      component.DoNotPassAttackRoll = doNotPassAttackRoll ?? component.DoNotPassAttackRoll;
      component.Not = not ?? component.Not;
      component.NotReach = notReach ?? component.NotReach;
      component.NotSneakAttack = notSneakAttack ?? component.NotSneakAttack;
      component.OnAttackOfOpportunity = onAttackOfOpportunity ?? component.OnAttackOfOpportunity;
      component.OnlyHit = onlyHit ?? component.OnlyHit;
      component.OnlyMelee = onlyMelee ?? component.OnlyMelee;
      component.OnlyOnFirstAttack = onlyOnFirstAttack ?? component.OnlyOnFirstAttack;
      component.OnlyRanged = onlyRanged ?? component.OnlyRanged;
      component.OnlySneakAttack = onlySneakAttack ?? component.OnlySneakAttack;
      component.WaitForAttackResolve = waitForAttackResolve ?? component.WaitForAttackResolve;
      return AddUniqueComponent(component, mergeBehavior, merge);
    }

    /// <summary>
    /// Adds <see cref="AddTargetSavingThrowTrigger"/>
    /// </summary>
    ///
    /// <remarks>
    ///
    /// <list type="bullet">
    /// <listheader>Used by</listheader>
    /// <item><term>ShamanHexWardBuff</term><description>ef56fe689d3c67249aea80bc174f1eab</description></item>
    /// <item><term>WardMastersAmuletPermanentBuff</term><description>26fc95271945cd341aaaac9a14ed0b64</description></item>
    /// <item><term>WitchHexWardBuff</term><description>da49e3ca7424a4741953ecc4f2fe11bb</description></item>
    /// </list>
    /// </remarks>
    public TBuilder AddTargetSavingThrowTrigger(
        ActionsBuilder? action = null,
        bool? onlyFail = null,
        bool? onlyPass = null)
    {
      var component = new AddTargetSavingThrowTrigger();
      component.Action = action?.Build() ?? component.Action;
      if (component.Action is null)
      {
        component.Action = Utils.Constants.Empty.Actions;
      }
      component.OnlyFail = onlyFail ?? component.OnlyFail;
      component.OnlyPass = onlyPass ?? component.OnlyPass;
      return AddComponent(component);
    }

    /// <summary>
    /// Adds <see cref="AddTargetSpellResistanceCheckTrigger"/>
    /// </summary>
    ///
    /// <remarks>
    ///
    /// <list type="bullet">
    /// <listheader>Used by</listheader>
    /// <item><term>MagicDevourerFeature</term><description>5e89a8a186bed88488356e8c58dfed50</description></item>
    /// </list>
    /// </remarks>
    public TBuilder AddTargetSpellResistanceCheckTrigger(
        ActionsBuilder? action = null,
        bool? onlyFail = null,
        bool? onlyPass = null)
    {
      var component = new AddTargetSpellResistanceCheckTrigger();
      component.Action = action?.Build() ?? component.Action;
      if (component.Action is null)
      {
        component.Action = Utils.Constants.Empty.Actions;
      }
      component.OnlyFail = onlyFail ?? component.OnlyFail;
      component.OnlyPass = onlyPass ?? component.OnlyPass;
      return AddComponent(component);
    }

    /// <summary>
    /// Adds <see cref="BlinkAoEDamageResistance"/>
    /// </summary>
    ///
    /// <remarks>
    ///
    /// <list type="bullet">
    /// <listheader>Used by</listheader>
    /// <item><term>BlinkBuff</term><description>c168c6a0e471e924b8c69b31c6352587</description></item>
    /// </list>
    /// </remarks>
    public TBuilder AddBlinkAoEDamageResistance()
    {
      return AddComponent(new BlinkAoEDamageResistance());
    }

    /// <summary>
    /// Adds <see cref="ChangeSpellElementalDamage"/>
    /// </summary>
    ///
    /// <remarks>
    ///
    /// <list type="bullet">
    /// <listheader>Used by</listheader>
    /// <item><term>AmberLustRodBuff</term><description>f5e06077bc5cdbf4c9e7fb55ab62b5ed</description></item>
    /// <item><term>ElementalistColdBuff</term><description>9d87c83a4c5b46af83b9a2c20265d9de</description></item>
    /// <item><term>StormlordsResolveBuff</term><description>7ae310b8153c44e438ba52920896f68e</description></item>
    /// </list>
    /// </remarks>
    public TBuilder AddChangeSpellElementalDamage(
        DamageEnergyType? element = null)
    {
      var component = new ChangeSpellElementalDamage();
      component.Element = element ?? component.Element;
      return AddComponent(component);
    }

    /// <summary>
    /// Adds <see cref="ChangeSpellElementalDamageHalfUntyped"/>
    /// </summary>
    ///
    /// <remarks>
    ///
    /// <list type="bullet">
    /// <listheader>Used by</listheader>
    /// <item><term>ElementalistAcidHalfUntypedFeature</term><description>9e54914720ec41c7b9b2c8fbaaee0c65</description></item>
    /// <item><term>ElementalistElectricityHalfUntypedFeature</term><description>0058e57f84da439880aeaae83bbf7fce</description></item>
    /// <item><term>WinterWitchUnearthlyCold</term><description>d50282428eb0a9b489bff9f687dd208c</description></item>
    /// </list>
    /// </remarks>
    public TBuilder AddChangeSpellElementalDamageHalfUntyped(
        DamageEnergyType? element = null)
    {
      var component = new ChangeSpellElementalDamageHalfUntyped();
      component.Element = element ?? component.Element;
      return AddComponent(component);
    }

    /// <summary>
    /// Adds <see cref="DeathActions"/>
    /// </summary>
    ///
    /// <remarks>
    ///
    /// <list type="bullet">
    /// <listheader>Used by</listheader>
    /// <item><term>1_FirstStage_AcidBuff</term><description>6afe27c9a2d64eb890673ff3649dacb3</description></item>
    /// <item><term>DLC2_Abrikandilu_AfterDeathBuff</term><description>6dd852f8278e4fc19863a3c5f88997ea</description></item>
    /// <item><term>Ygefeles_VisualBuff</term><description>116b1033539367548921d49fec2f622d</description></item>
    /// </list>
    /// </remarks>
    ///
    /// <param name="merge">
    /// If mergeBehavior is ComponentMerge.Merge and the component already exists, this expression is called to merge the components.
    /// </param>
    /// <param name="mergeBehavior">
    /// Handling if the component already exists since the component is unique. Defaults to ComponentMerge.Fail.
    /// </param>
    /// <param name="resource">
    /// <para>
    /// Blueprint of type BlueprintAbilityResource. You can pass in the blueprint using:
    /// <list type ="bullet">
    ///   <item><term>A blueprint instance</term></item>
    ///   <item><term>A blueprint reference</term></item>
    ///   <item><term>A blueprint id as a string, Guid, or BlueprintGuid</term></item>
    ///   <item><term>A blueprint name registered with <see cref="BlueprintCore.Utils.BlueprintTool">BlueprintTool</see></term></item>
    /// </list>
    /// See <see cref="BlueprintCore.Utils.Blueprint{{T, TRef}}">Blueprint</see> for more details.
    /// </para>
    /// </param>
    public TBuilder AddDeathActions(
        ActionsBuilder? actions = null,
        bool? checkResource = null,
        Action<BlueprintComponent, BlueprintComponent>? merge = null,
        ComponentMerge mergeBehavior = ComponentMerge.Merge,
        bool? onlyOnParty = null,
        Blueprint<BlueprintAbilityResource, BlueprintAbilityResourceReference>? resource = null)
    {
      var component = new DeathActions();
      component.Actions = actions?.Build() ?? component.Actions;
      if (component.Actions is null)
      {
        component.Actions = Utils.Constants.Empty.Actions;
      }
      component.CheckResource = checkResource ?? component.CheckResource;
      component.OnlyOnParty = onlyOnParty ?? component.OnlyOnParty;
      component.m_Resource = resource?.Reference ?? component.m_Resource;
      if (component.m_Resource is null)
      {
        component.m_Resource = BlueprintTool.GetRef<BlueprintAbilityResourceReference>(null);
      }
      return AddUniqueComponent(component, mergeBehavior, merge);
    }

    /// <summary>
    /// Adds <see cref="DeskariAspect"/>
    /// </summary>
    ///
    /// <remarks>
    ///
    /// <list type="bullet">
    /// <listheader>Used by</listheader>
    /// <item><term>DeskariAspectBuff</term><description>1c8b0722a3694854db5b2fa8800575c4</description></item>
    /// </list>
    /// </remarks>
    public TBuilder AddDeskariAspect()
    {
      return AddComponent(new DeskariAspect());
    }

    /// <summary>
    /// Adds <see cref="FlamewardenBurningRenewal"/>
    /// </summary>
    ///
    /// <remarks>
    ///
    /// <list type="bullet">
    /// <listheader>Used by</listheader>
    /// <item><term>FlamewardenBurningRenewalFeature</term><description>7cf2a6bf35c422e4ea219fcc2eb564f5</description></item>
    /// </list>
    /// </remarks>
    ///
    /// <param name="merge">
    /// If mergeBehavior is ComponentMerge.Merge and the component already exists, this expression is called to merge the components.
    /// </param>
    /// <param name="mergeBehavior">
    /// Handling if the component already exists since the component is unique. Defaults to ComponentMerge.Fail.
    /// </param>
    /// <param name="resource">
    /// <para>
    /// Blueprint of type BlueprintAbilityResource. You can pass in the blueprint using:
    /// <list type ="bullet">
    ///   <item><term>A blueprint instance</term></item>
    ///   <item><term>A blueprint reference</term></item>
    ///   <item><term>A blueprint id as a string, Guid, or BlueprintGuid</term></item>
    ///   <item><term>A blueprint name registered with <see cref="BlueprintCore.Utils.BlueprintTool">BlueprintTool</see></term></item>
    /// </list>
    /// See <see cref="BlueprintCore.Utils.Blueprint{{T, TRef}}">Blueprint</see> for more details.
    /// </para>
    /// </param>
    public TBuilder AddFlamewardenBurningRenewal(
        ActionsBuilder? actions = null,
        Action<BlueprintComponent, BlueprintComponent>? merge = null,
        ComponentMerge mergeBehavior = ComponentMerge.Merge,
        Blueprint<BlueprintAbilityResource, BlueprintAbilityResourceReference>? resource = null)
    {
      var component = new FlamewardenBurningRenewal();
      component.Actions = actions?.Build() ?? component.Actions;
      if (component.Actions is null)
      {
        component.Actions = Utils.Constants.Empty.Actions;
      }
      component.m_Resource = resource?.Reference ?? component.m_Resource;
      if (component.m_Resource is null)
      {
        component.m_Resource = BlueprintTool.GetRef<BlueprintAbilityResourceReference>(null);
      }
      return AddUniqueComponent(component, mergeBehavior, merge);
    }

    /// <summary>
    /// Adds <see cref="ModifyAttackerMissChance"/>
    /// </summary>
    ///
    /// <remarks>
    ///
    /// <list type="bullet">
    /// <listheader>Used by</listheader>
    /// <item><term>AeonRelativityOfSpaceGazeEnemyBuff</term><description>4d10804f2caa4dcda984dcb07ef8638e</description></item>
    /// </list>
    /// </remarks>
    ///
    /// <param name="merge">
    /// If mergeBehavior is ComponentMerge.Merge and the component already exists, this expression is called to merge the components.
    /// </param>
    /// <param name="mergeBehavior">
    /// Handling if the component already exists since the component is unique. Defaults to ComponentMerge.Fail.
    /// </param>
    public TBuilder AddModifyAttackerMissChance(
        Action<BlueprintComponent, BlueprintComponent>? merge = null,
        ComponentMerge mergeBehavior = ComponentMerge.Merge,
        ContextValue? value = null)
    {
      var component = new ModifyAttackerMissChance();
      component.Value = value ?? component.Value;
      if (component.Value is null)
      {
        component.Value = ContextValues.Constant(0);
      }
      return AddUniqueComponent(component, mergeBehavior, merge);
    }

    /// <summary>
    /// Adds <see cref="OutcomingDamageAndHealingModifier"/>
    /// </summary>
    ///
    /// <remarks>
    ///
    /// <list type="bullet">
    /// <listheader>Used by</listheader>
    /// <item><term>ArmyBuildingTrainingGrounds</term><description>b1ab3085e85243e8a13f6acf78023920</description></item>
    /// <item><term>ArmyRangedAttackPenaltyFeature</term><description>191843e7bf95cca4d9f58f8f97da1979</description></item>
    /// <item><term>SpiritedChargeBuff</term><description>5a191fc6731bd4845bbbcc8ff3ff4c1d</description></item>
    /// </list>
    /// </remarks>
    ///
    /// <param name="modifierPercents">
    /// <para>
    /// InfoBox: ResultDamage = Damage * (1 + ModifierPercents / 100)
    /// </para>
    /// </param>
    /// <param name="overrideOtherModifierPercents">
    /// <para>
    /// InfoBox: Should this modifier override all others
    /// </para>
    /// </param>
    public TBuilder AddOutcomingDamageAndHealingModifier(
        OutcomingDamageAndHealingModifier.WeaponType? damageWeaponType = null,
        ContextValue? modifierPercents = null,
        bool? overrideOtherModifierPercents = null,
        OutcomingDamageAndHealingModifier.ModifyingType? type = null)
    {
      var component = new OutcomingDamageAndHealingModifier();
      component.m_DamageWeaponType = damageWeaponType ?? component.m_DamageWeaponType;
      component.ModifierPercents = modifierPercents ?? component.ModifierPercents;
      if (component.ModifierPercents is null)
      {
        component.ModifierPercents = ContextValues.Constant(0);
      }
      component.m_OverrideOtherModifierPercents = overrideOtherModifierPercents ?? component.m_OverrideOtherModifierPercents;
      component.Type = type ?? component.Type;
      return AddComponent(component);
    }

    /// <summary>
    /// Adds <see cref="SacredWeaponDamageOverride"/>
    /// </summary>
    ///
    /// <remarks>
    ///
    /// <list type="bullet">
    /// <listheader>Used by</listheader>
    /// <item><term>WarpriestSacredWeaponBuff1d10</term><description>e62b125c9f49b084b95a487a6bfb1b7c</description></item>
    /// <item><term>WarpriestSacredWeaponBuff1d8</term><description>06ad6a85cfd5b694c88bdc0eabf8ba16</description></item>
    /// <item><term>WarpriestSacredWeaponBuff2d8</term><description>a3a655c948afb674882577674644e816</description></item>
    /// </list>
    /// </remarks>
    ///
    /// <param name="feature">
    /// <para>
    /// Blueprint of type BlueprintParametrizedFeature. You can pass in the blueprint using:
    /// <list type ="bullet">
    ///   <item><term>A blueprint instance</term></item>
    ///   <item><term>A blueprint reference</term></item>
    ///   <item><term>A blueprint id as a string, Guid, or BlueprintGuid</term></item>
    ///   <item><term>A blueprint name registered with <see cref="BlueprintCore.Utils.BlueprintTool">BlueprintTool</see></term></item>
    /// </list>
    /// See <see cref="BlueprintCore.Utils.Blueprint{{T, TRef}}">Blueprint</see> for more details.
    /// </para>
    /// </param>
    public TBuilder AddSacredWeaponDamageOverride(
        Blueprint<BlueprintParametrizedFeature, BlueprintParametrizedFeatureReference>? feature = null,
        DiceFormula? formula = null)
    {
      var component = new SacredWeaponDamageOverride();
      component.m_Feature = feature?.Reference ?? component.m_Feature;
      if (component.m_Feature is null)
      {
        component.m_Feature = BlueprintTool.GetRef<BlueprintParametrizedFeatureReference>(null);
      }
      component.Formula = formula ?? component.Formula;
      return AddComponent(component);
    }

    /// <summary>
    /// Adds <see cref="SacredWeaponFavoriteDamageOverride"/>
    /// </summary>
    ///
    /// <remarks>
    ///
    /// <list type="bullet">
    /// <listheader>Used by</listheader>
    /// <item><term>AbadarSacredWeaponFeature</term><description>91d0bd9701afe994bab517d6529acf8a</description></item>
    /// <item><term>IroriSacredWeaponFeature</term><description>79d23ee0026e83f4e9a1efe1d33831ff</description></item>
    /// <item><term>ZonKuthonSacredWeaponFeature</term><description>5c73ec301e1e3094ebb031bda43e6481</description></item>
    /// </list>
    /// </remarks>
    ///
    /// <param name="buff1d10">
    /// <para>
    /// Blueprint of type BlueprintBuff. You can pass in the blueprint using:
    /// <list type ="bullet">
    ///   <item><term>A blueprint instance</term></item>
    ///   <item><term>A blueprint reference</term></item>
    ///   <item><term>A blueprint id as a string, Guid, or BlueprintGuid</term></item>
    ///   <item><term>A blueprint name registered with <see cref="BlueprintCore.Utils.BlueprintTool">BlueprintTool</see></term></item>
    /// </list>
    /// See <see cref="BlueprintCore.Utils.Blueprint{{T, TRef}}">Blueprint</see> for more details.
    /// </para>
    /// </param>
    /// <param name="buff1d6">
    /// <para>
    /// Blueprint of type BlueprintBuff. You can pass in the blueprint using:
    /// <list type ="bullet">
    ///   <item><term>A blueprint instance</term></item>
    ///   <item><term>A blueprint reference</term></item>
    ///   <item><term>A blueprint id as a string, Guid, or BlueprintGuid</term></item>
    ///   <item><term>A blueprint name registered with <see cref="BlueprintCore.Utils.BlueprintTool">BlueprintTool</see></term></item>
    /// </list>
    /// See <see cref="BlueprintCore.Utils.Blueprint{{T, TRef}}">Blueprint</see> for more details.
    /// </para>
    /// </param>
    /// <param name="buff1d8">
    /// <para>
    /// Blueprint of type BlueprintBuff. You can pass in the blueprint using:
    /// <list type ="bullet">
    ///   <item><term>A blueprint instance</term></item>
    ///   <item><term>A blueprint reference</term></item>
    ///   <item><term>A blueprint id as a string, Guid, or BlueprintGuid</term></item>
    ///   <item><term>A blueprint name registered with <see cref="BlueprintCore.Utils.BlueprintTool">BlueprintTool</see></term></item>
    /// </list>
    /// See <see cref="BlueprintCore.Utils.Blueprint{{T, TRef}}">Blueprint</see> for more details.
    /// </para>
    /// </param>
    /// <param name="buff2d6">
    /// <para>
    /// Blueprint of type BlueprintBuff. You can pass in the blueprint using:
    /// <list type ="bullet">
    ///   <item><term>A blueprint instance</term></item>
    ///   <item><term>A blueprint reference</term></item>
    ///   <item><term>A blueprint id as a string, Guid, or BlueprintGuid</term></item>
    ///   <item><term>A blueprint name registered with <see cref="BlueprintCore.Utils.BlueprintTool">BlueprintTool</see></term></item>
    /// </list>
    /// See <see cref="BlueprintCore.Utils.Blueprint{{T, TRef}}">Blueprint</see> for more details.
    /// </para>
    /// </param>
    /// <param name="buff2d8">
    /// <para>
    /// Blueprint of type BlueprintBuff. You can pass in the blueprint using:
    /// <list type ="bullet">
    ///   <item><term>A blueprint instance</term></item>
    ///   <item><term>A blueprint reference</term></item>
    ///   <item><term>A blueprint id as a string, Guid, or BlueprintGuid</term></item>
    ///   <item><term>A blueprint name registered with <see cref="BlueprintCore.Utils.BlueprintTool">BlueprintTool</see></term></item>
    /// </list>
    /// See <see cref="BlueprintCore.Utils.Blueprint{{T, TRef}}">Blueprint</see> for more details.
    /// </para>
    /// </param>
    /// <param name="deaitySacredWeaponFeature">
    /// <para>
    /// Blueprint of type BlueprintFeature. You can pass in the blueprint using:
    /// <list type ="bullet">
    ///   <item><term>A blueprint instance</term></item>
    ///   <item><term>A blueprint reference</term></item>
    ///   <item><term>A blueprint id as a string, Guid, or BlueprintGuid</term></item>
    ///   <item><term>A blueprint name registered with <see cref="BlueprintCore.Utils.BlueprintTool">BlueprintTool</see></term></item>
    /// </list>
    /// See <see cref="BlueprintCore.Utils.Blueprint{{T, TRef}}">Blueprint</see> for more details.
    /// </para>
    /// </param>
    /// <param name="merge">
    /// If mergeBehavior is ComponentMerge.Merge and the component already exists, this expression is called to merge the components.
    /// </param>
    /// <param name="mergeBehavior">
    /// Handling if the component already exists since the component is unique. Defaults to ComponentMerge.Fail.
    /// </param>
    public TBuilder AddSacredWeaponFavoriteDamageOverride(
        Blueprint<BlueprintBuff, BlueprintBuffReference>? buff1d10 = null,
        Blueprint<BlueprintBuff, BlueprintBuffReference>? buff1d6 = null,
        Blueprint<BlueprintBuff, BlueprintBuffReference>? buff1d8 = null,
        Blueprint<BlueprintBuff, BlueprintBuffReference>? buff2d6 = null,
        Blueprint<BlueprintBuff, BlueprintBuffReference>? buff2d8 = null,
        WeaponCategory? category = null,
        Blueprint<BlueprintFeature, BlueprintFeatureReference>? deaitySacredWeaponFeature = null,
        Action<BlueprintComponent, BlueprintComponent>? merge = null,
        ComponentMerge mergeBehavior = ComponentMerge.Merge)
    {
      var component = new SacredWeaponFavoriteDamageOverride();
      component.m_Buff1d10 = buff1d10?.Reference ?? component.m_Buff1d10;
      if (component.m_Buff1d10 is null)
      {
        component.m_Buff1d10 = BlueprintTool.GetRef<BlueprintBuffReference>(null);
      }
      component.m_Buff1d6 = buff1d6?.Reference ?? component.m_Buff1d6;
      if (component.m_Buff1d6 is null)
      {
        component.m_Buff1d6 = BlueprintTool.GetRef<BlueprintBuffReference>(null);
      }
      component.m_Buff1d8 = buff1d8?.Reference ?? component.m_Buff1d8;
      if (component.m_Buff1d8 is null)
      {
        component.m_Buff1d8 = BlueprintTool.GetRef<BlueprintBuffReference>(null);
      }
      component.m_Buff2d6 = buff2d6?.Reference ?? component.m_Buff2d6;
      if (component.m_Buff2d6 is null)
      {
        component.m_Buff2d6 = BlueprintTool.GetRef<BlueprintBuffReference>(null);
      }
      component.m_Buff2d8 = buff2d8?.Reference ?? component.m_Buff2d8;
      if (component.m_Buff2d8 is null)
      {
        component.m_Buff2d8 = BlueprintTool.GetRef<BlueprintBuffReference>(null);
      }
      component.Category = category ?? component.Category;
      component.m_DeaitySacredWeaponFeature = deaitySacredWeaponFeature?.Reference ?? component.m_DeaitySacredWeaponFeature;
      if (component.m_DeaitySacredWeaponFeature is null)
      {
        component.m_DeaitySacredWeaponFeature = BlueprintTool.GetRef<BlueprintFeatureReference>(null);
      }
      return AddUniqueComponent(component, mergeBehavior, merge);
    }

    /// <summary>
    /// Adds <see cref="SetAttackerMissChance"/>
    /// </summary>
    ///
    /// <remarks>
    ///
    /// <list type="bullet">
    /// <listheader>Used by</listheader>
    /// <item><term>AeonRelativityOfSpaceGazeAllyBuff</term><description>ed4de4a82cbd4c519337022c46f24894</description></item>
    /// <item><term>OracleRevelationSpiritShieldMissBuff</term><description>cef9569005de6234bb8b69e45f9509d8</description></item>
    /// <item><term>WeatherBlessingMajorBuff</term><description>28da782b9601987438e286ab302461d4</description></item>
    /// </list>
    /// </remarks>
    ///
    /// <param name="merge">
    /// If mergeBehavior is ComponentMerge.Merge and the component already exists, this expression is called to merge the components.
    /// </param>
    /// <param name="mergeBehavior">
    /// Handling if the component already exists since the component is unique. Defaults to ComponentMerge.Fail.
    /// </param>
    public TBuilder AddSetAttackerMissChance(
        ConditionsBuilder? conditions = null,
        Action<BlueprintComponent, BlueprintComponent>? merge = null,
        ComponentMerge mergeBehavior = ComponentMerge.Merge,
        SetAttackerMissChance.Type? type = null,
        ContextValue? value = null)
    {
      var component = new SetAttackerMissChance();
      component.Conditions = conditions?.Build() ?? component.Conditions;
      if (component.Conditions is null)
      {
        component.Conditions = Utils.Constants.Empty.Conditions;
      }
      component.m_Type = type ?? component.m_Type;
      component.Value = value ?? component.Value;
      if (component.Value is null)
      {
        component.Value = ContextValues.Constant(0);
      }
      return AddUniqueComponent(component, mergeBehavior, merge);
    }

    /// <summary>
    /// Adds <see cref="SetFactOwnerMissChance"/>
    /// </summary>
    ///
    /// <remarks>
    ///
    /// <list type="bullet">
    /// <listheader>Used by</listheader>
    /// <item><term>ArcanistExploitLightningLanceBuff</term><description>d3a37094a6e676448b7674aa4aa7b805</description></item>
    /// <item><term>LichSoldYouth</term><description>90d559e535e84064b00a8c5e0c774ab2</description></item>
    /// <item><term>SwarmFeastEnemyBuff</term><description>edd6db0bfe1e0de4598f34909a4d7253</description></item>
    /// </list>
    /// </remarks>
    ///
    /// <param name="merge">
    /// If mergeBehavior is ComponentMerge.Merge and the component already exists, this expression is called to merge the components.
    /// </param>
    /// <param name="mergeBehavior">
    /// Handling if the component already exists since the component is unique. Defaults to ComponentMerge.Fail.
    /// </param>
    public TBuilder AddSetFactOwnerMissChance(
        ConditionsBuilder? conditions = null,
        Action<BlueprintComponent, BlueprintComponent>? merge = null,
        ComponentMerge mergeBehavior = ComponentMerge.Merge,
        SetFactOwnerMissChance.Type? type = null,
        ContextValue? value = null)
    {
      var component = new SetFactOwnerMissChance();
      component.Conditions = conditions?.Build() ?? component.Conditions;
      if (component.Conditions is null)
      {
        component.Conditions = Utils.Constants.Empty.Conditions;
      }
      component.m_Type = type ?? component.m_Type;
      component.Value = value ?? component.Value;
      if (component.Value is null)
      {
        component.Value = ContextValues.Constant(0);
      }
      return AddUniqueComponent(component, mergeBehavior, merge);
    }

    /// <summary>
    /// Adds <see cref="WeaponDamageOverride"/>
    /// </summary>
    ///
    /// <remarks>
    ///
    /// <list type="bullet">
    /// <listheader>Used by</listheader>
    /// <item><term>Ygefeles_WeakCopyBuff</term><description>c78769bac92ee2744b7b869d9805baf0</description></item>
    /// <item><term>ZenArcherKiArrowsFeatureLevel20</term><description>d8a8d5cf1f915384f9d669c34252fd5c</description></item>
    /// <item><term>ZenArcherKiArrowsFeatureLevel8</term><description>fe8f6067014cc7c4db0606c348aed049</description></item>
    /// </list>
    /// </remarks>
    ///
    /// <param name="overrideBonusStat">
    /// <para>
    /// InfoBox: Tick to override weapon bonus stat
    /// </para>
    /// </param>
    /// <param name="overrideBonusStatMultiplier">
    /// <para>
    /// InfoBox: Tick to override weapon bonus stat multiplier
    /// </para>
    /// </param>
    /// <param name="overrideDice">
    /// <para>
    /// InfoBox: Tick to override Dice
    /// </para>
    /// </param>
    /// <param name="weaponTypes">
    /// <para>
    /// InfoBox: If Weapon Types empty - will work on all weapons
    /// </para>
    /// <para>
    /// Blueprint of type BlueprintWeaponType. You can pass in the blueprint using:
    /// <list type ="bullet">
    ///   <item><term>A blueprint instance</term></item>
    ///   <item><term>A blueprint reference</term></item>
    ///   <item><term>A blueprint id as a string, Guid, or BlueprintGuid</term></item>
    ///   <item><term>A blueprint name registered with <see cref="BlueprintCore.Utils.BlueprintTool">BlueprintTool</see></term></item>
    /// </list>
    /// See <see cref="BlueprintCore.Utils.Blueprint{{T, TRef}}">Blueprint</see> for more details.
    /// </para>
    /// </param>
    public TBuilder AddWeaponDamageOverride(
        DiceFormula? formula = null,
        bool? overrideBonusStat = null,
        bool? overrideBonusStatMultiplier = null,
        bool? overrideDice = null,
        StatType? stat = null,
        int? statMultiplier = null,
        List<Blueprint<BlueprintWeaponType, BlueprintWeaponTypeReference>>? weaponTypes = null)
    {
      var component = new WeaponDamageOverride();
      component.Formula = formula ?? component.Formula;
      component.OverrideBonusStat = overrideBonusStat ?? component.OverrideBonusStat;
      component.OverrideBonusStatMultiplier = overrideBonusStatMultiplier ?? component.OverrideBonusStatMultiplier;
      component.OverrideDice = overrideDice ?? component.OverrideDice;
      component.Stat = stat ?? component.Stat;
      component.StatMultiplier = statMultiplier ?? component.StatMultiplier;
      component.m_WeaponTypes = weaponTypes?.Select(bp => bp.Reference)?.ToArray() ?? component.m_WeaponTypes;
      if (component.m_WeaponTypes is null)
      {
        component.m_WeaponTypes = new BlueprintWeaponTypeReference[0];
      }
      return AddComponent(component);
    }

    /// <summary>
    /// Adds <see cref="DublicateSpellComponent"/>
    /// </summary>
    ///
    /// <remarks>
    ///
    /// <list type="bullet">
    /// <listheader>Used by</listheader>
    /// <item><term>ZippyMagicFeature</term><description>30b4200f897ba25419ba3a292aed4053</description></item>
    /// </list>
    /// </remarks>
    public TBuilder AddDublicateSpellComponent(
        DublicateSpellComponent.AOEType? aOECheck = null,
        int? feetsRaiuds = null)
    {
      var component = new DublicateSpellComponent();
      component.m_AOECheck = aOECheck ?? component.m_AOECheck;
      component.m_FeetsRaiuds = feetsRaiuds ?? component.m_FeetsRaiuds;
      return AddComponent(component);
    }

    /// <summary>
    /// Adds <see cref="AbilityResourceOverride"/>
    /// </summary>
    ///
    /// <remarks>
    ///
    /// <list type="bullet">
    /// <listheader>Used by</listheader>
    /// <item><term>ArcanistMagicalSupremacy</term><description>261270d064148224fb982590b7a65414</description></item>
    /// </list>
    /// </remarks>
    ///
    /// <param name="abilityResource">
    /// <para>
    /// Blueprint of type BlueprintAbilityResource. You can pass in the blueprint using:
    /// <list type ="bullet">
    ///   <item><term>A blueprint instance</term></item>
    ///   <item><term>A blueprint reference</term></item>
    ///   <item><term>A blueprint id as a string, Guid, or BlueprintGuid</term></item>
    ///   <item><term>A blueprint name registered with <see cref="BlueprintCore.Utils.BlueprintTool">BlueprintTool</see></term></item>
    /// </list>
    /// See <see cref="BlueprintCore.Utils.Blueprint{{T, TRef}}">Blueprint</see> for more details.
    /// </para>
    /// </param>
    /// <param name="additionalCost">
    /// <para>
    /// InfoBox: Cost = spellLevel * LevelMultiplier + AdditionalCost
    /// </para>
    /// </param>
    /// <param name="saveSpellSlot">
    /// <para>
    /// InfoBox: If true spell slot will not spent
    /// </para>
    /// </param>
    public TBuilder AddAbilityResourceOverride(
        Blueprint<BlueprintAbilityResource, BlueprintAbilityResourceReference>? abilityResource = null,
        ContextValue? additionalCost = null,
        ContextValue? levelMultiplier = null,
        bool? saveSpellSlot = null)
    {
      var component = new AbilityResourceOverride();
      component.m_AbilityResource = abilityResource?.Reference ?? component.m_AbilityResource;
      if (component.m_AbilityResource is null)
      {
        component.m_AbilityResource = BlueprintTool.GetRef<BlueprintAbilityResourceReference>(null);
      }
      component.m_AdditionalCost = additionalCost ?? component.m_AdditionalCost;
      if (component.m_AdditionalCost is null)
      {
        component.m_AdditionalCost = ContextValues.Constant(0);
      }
      component.m_LevelMultiplier = levelMultiplier ?? component.m_LevelMultiplier;
      if (component.m_LevelMultiplier is null)
      {
        component.m_LevelMultiplier = ContextValues.Constant(0);
      }
      component.m_SaveSpellSlot = saveSpellSlot ?? component.m_SaveSpellSlot;
      return AddComponent(component);
    }

    /// <summary>
    /// Adds <see cref="IgnoreAttacksOfOpportunityForSpellList"/>
    /// </summary>
    ///
    /// <remarks>
    ///
    /// <list type="bullet">
    /// <listheader>Used by</listheader>
    /// <item><term>AreeluArcaneScientistsFeature</term><description>380b9e7f1c3f4dbeb776f4b9a51961b9</description></item>
    /// <item><term>ClearPurposeFeature</term><description>2fee198fe87807d49950dd1ef73cb026</description></item>
    /// <item><term>OracleRevelationSafeCuring</term><description>3fa75c1a809882a4697db75daf8803e3</description></item>
    /// </list>
    /// </remarks>
    ///
    /// <param name="abilities">
    /// <para>
    /// Blueprint of type BlueprintAbility. You can pass in the blueprint using:
    /// <list type ="bullet">
    ///   <item><term>A blueprint instance</term></item>
    ///   <item><term>A blueprint reference</term></item>
    ///   <item><term>A blueprint id as a string, Guid, or BlueprintGuid</term></item>
    ///   <item><term>A blueprint name registered with <see cref="BlueprintCore.Utils.BlueprintTool">BlueprintTool</see></term></item>
    /// </list>
    /// See <see cref="BlueprintCore.Utils.Blueprint{{T, TRef}}">Blueprint</see> for more details.
    /// </para>
    /// </param>
    public TBuilder AddIgnoreAttacksOfOpportunityForSpellList(
        List<Blueprint<BlueprintAbility, BlueprintAbilityReference>>? abilities = null,
        bool? checkAbilityType = null,
        bool? checkDescriptor = null,
        bool? checkSchool = null,
        SpellSchool? school = null,
        SpellDescriptorWrapper? spellDescriptor = null,
        AbilityType? type = null)
    {
      var component = new IgnoreAttacksOfOpportunityForSpellList();
      component.m_Abilities = abilities?.Select(bp => bp.Reference)?.ToList() ?? component.m_Abilities;
      if (component.m_Abilities is null)
      {
        component.m_Abilities = new();
      }
      component.CheckAbilityType = checkAbilityType ?? component.CheckAbilityType;
      component.CheckDescriptor = checkDescriptor ?? component.CheckDescriptor;
      component.CheckSchool = checkSchool ?? component.CheckSchool;
      component.School = school ?? component.School;
      component.SpellDescriptor = spellDescriptor ?? component.SpellDescriptor;
      component.Type = type ?? component.Type;
      return AddComponent(component);
    }

    /// <summary>
    /// Adds <see cref="ArmyAlternativeMovement"/>
    /// </summary>
    ///
    /// <remarks>
    ///
    /// <list type="bullet">
    /// <listheader>Used by</listheader>
    /// <item><term>ArmyAssassinTeleportFeature</term><description>b591778498944c9fa058bb2ac4abc650</description></item>
    /// <item><term>ArmyFlying</term><description>62972c22d74bfcb49b7cd2ba20378e74</description></item>
    /// <item><term>ArmyTeleportWarwarpriestFeature</term><description>8b6f6bd7073948168bce5eba6ec73a85</description></item>
    /// </list>
    /// </remarks>
    ///
    /// <param name="deliverAbility">
    /// <para>
    /// InfoBox: If empty - unit will move cell by cell (keep empty for flight)
    /// </para>
    /// <para>
    /// Blueprint of type BlueprintAbility. You can pass in the blueprint using:
    /// <list type ="bullet">
    ///   <item><term>A blueprint instance</term></item>
    ///   <item><term>A blueprint reference</term></item>
    ///   <item><term>A blueprint id as a string, Guid, or BlueprintGuid</term></item>
    ///   <item><term>A blueprint name registered with <see cref="BlueprintCore.Utils.BlueprintTool">BlueprintTool</see></term></item>
    /// </list>
    /// See <see cref="BlueprintCore.Utils.Blueprint{{T, TRef}}">Blueprint</see> for more details.
    /// </para>
    /// </param>
    /// <param name="ignoreObstacles">
    /// <para>
    /// InfoBox: If true, can pass through units and obstacles
    /// </para>
    /// </param>
    public TBuilder AddArmyAlternativeMovement(
        Blueprint<BlueprintAbility, BlueprintAbilityReference>? deliverAbility = null,
        bool? ignoreObstacles = null)
    {
      var component = new ArmyAlternativeMovement();
      component.m_DeliverAbility = deliverAbility?.Reference ?? component.m_DeliverAbility;
      if (component.m_DeliverAbility is null)
      {
        component.m_DeliverAbility = BlueprintTool.GetRef<BlueprintAbilityReference>(null);
      }
      component.m_IgnoreObstacles = ignoreObstacles ?? component.m_IgnoreObstacles;
      return AddComponent(component);
    }

    /// <summary>
    /// Adds <see cref="ArmyChangeInitiative"/>
    /// </summary>
    ///
    /// <remarks>
    ///
    /// <para>
    /// ComponentName: Change initiative and turn order for squad
    /// </para>
    ///
    /// <list type="bullet">
    /// <listheader>Used by</listheader>
    /// <item><term>ArmyChaosHammerBuff</term><description>28a6448f1a3f4fdab7595820ea3cb79f</description></item>
    /// <item><term>ArmyMarkOfHeavenBuff</term><description>364feecb8f314982bc3088093d9ce169</description></item>
    /// <item><term>RitualGoodHopeBuff</term><description>7ca8e974c92d4bef8187362843a995d3</description></item>
    /// </list>
    /// </remarks>
    ///
    /// <param name="merge">
    /// If mergeBehavior is ComponentMerge.Merge and the component already exists, this expression is called to merge the components.
    /// </param>
    /// <param name="mergeBehavior">
    /// Handling if the component already exists since the component is unique. Defaults to ComponentMerge.Fail.
    /// </param>
    public TBuilder AddArmyChangeInitiative(
        ModifierDescriptor? descriptor = null,
        Action<BlueprintComponent, BlueprintComponent>? merge = null,
        ComponentMerge mergeBehavior = ComponentMerge.Merge,
        ContextValue? value = null)
    {
      var component = new ArmyChangeInitiative();
      component.m_Descriptor = descriptor ?? component.m_Descriptor;
      component.m_Value = value ?? component.m_Value;
      if (component.m_Value is null)
      {
        component.m_Value = ContextValues.Constant(0);
      }
      return AddUniqueComponent(component, mergeBehavior, merge);
    }

    /// <summary>
    /// Adds <see cref="ArmyFullAttackEndTrigger"/>
    /// </summary>
    ///
    /// <remarks>
    ///
    /// <list type="bullet">
    /// <listheader>Used by</listheader>
    /// <item><term>ArmyAeon3Spikes</term><description>249ad28266fc4d579e21c626bc198ea2</description></item>
    /// <item><term>ArmyIsgerTrainingsFeature</term><description>226aebc49e50488bbc0c7de6a0e538cc</description></item>
    /// <item><term>Logistics6MoraleForHitFeature</term><description>a335cf7c66b44aedaad858016725a123</description></item>
    /// </list>
    /// </remarks>
    ///
    /// <param name="checkAllAttacks">
    /// <para>
    /// InfoBox: If false will trigger if any attack in batch meets all conditions
    /// </para>
    /// </param>
    /// <param name="merge">
    /// If mergeBehavior is ComponentMerge.Merge and the component already exists, this expression is called to merge the components.
    /// </param>
    /// <param name="mergeBehavior">
    /// Handling if the component already exists since the component is unique. Defaults to ComponentMerge.Fail.
    /// </param>
    /// <param name="shouldBeInitiator">
    /// <para>
    /// InfoBox: If true triggers on outcoming damage, if false - on incoming
    /// </para>
    /// </param>
    public TBuilder AddArmyFullAttackEndTrigger(
        ActionsBuilder? actionOnTarget = null,
        ActionsBuilder? actionsOnInitiator = null,
        WeaponCategory[]? categories = null,
        bool? checkAllAttacks = null,
        bool? checkCategory = null,
        bool? criticalHit = null,
        Action<BlueprintComponent, BlueprintComponent>? merge = null,
        ComponentMerge mergeBehavior = ComponentMerge.Merge,
        bool? not = null,
        bool? notReach = null,
        bool? notSneakAttack = null,
        bool? onlyHit = null,
        bool? onlyMelee = null,
        bool? onlyRanged = null,
        bool? onlySneakAttack = null,
        bool? shouldBeInitiator = null)
    {
      var component = new ArmyFullAttackEndTrigger();
      component.ActionOnTarget = actionOnTarget?.Build() ?? component.ActionOnTarget;
      if (component.ActionOnTarget is null)
      {
        component.ActionOnTarget = Utils.Constants.Empty.Actions;
      }
      component.ActionsOnInitiator = actionsOnInitiator?.Build() ?? component.ActionsOnInitiator;
      if (component.ActionsOnInitiator is null)
      {
        component.ActionsOnInitiator = Utils.Constants.Empty.Actions;
      }
      component.Categories = categories ?? component.Categories;
      if (component.Categories is null)
      {
        component.Categories = new WeaponCategory[0];
      }
      component.CheckAllAttacks = checkAllAttacks ?? component.CheckAllAttacks;
      component.CheckCategory = checkCategory ?? component.CheckCategory;
      component.CriticalHit = criticalHit ?? component.CriticalHit;
      component.Not = not ?? component.Not;
      component.NotReach = notReach ?? component.NotReach;
      component.NotSneakAttack = notSneakAttack ?? component.NotSneakAttack;
      component.OnlyHit = onlyHit ?? component.OnlyHit;
      component.OnlyMelee = onlyMelee ?? component.OnlyMelee;
      component.OnlyRanged = onlyRanged ?? component.OnlyRanged;
      component.OnlySneakAttack = onlySneakAttack ?? component.OnlySneakAttack;
      component.ShouldBeInitiator = shouldBeInitiator ?? component.ShouldBeInitiator;
      return AddUniqueComponent(component, mergeBehavior, merge);
    }

    /// <summary>
    /// Adds <see cref="ArmyLeaderAddResourcesOnBattleEnd"/>
    /// </summary>
    ///
    /// <remarks>
    ///
    /// <list type="bullet">
    /// <listheader>Used by</listheader>
    /// <item><term>Pillage</term><description>d4e55c26520a4aa399b63e9e78481cc3</description></item>
    /// </list>
    /// </remarks>
    ///
    /// <param name="onlyOnVictory">
    /// <para>
    /// InfoBox: Triggers on lose too if false
    /// </para>
    /// </param>
    public TBuilder AddArmyLeaderAddResourcesOnBattleEnd(
        bool? onlyOnVictory = null,
        KingdomResourcesAmount? resourcesAmount = null)
    {
      var component = new ArmyLeaderAddResourcesOnBattleEnd();
      component.OnlyOnVictory = onlyOnVictory ?? component.OnlyOnVictory;
      component.m_ResourcesAmount = resourcesAmount ?? component.m_ResourcesAmount;
      return AddComponent(component);
    }

    /// <summary>
    /// Adds <see cref="ChangeLeaderSkillPowerOnAbilityUse"/>
    /// </summary>
    ///
    /// <remarks>
    ///
    /// <list type="bullet">
    /// <listheader>Used by</listheader>
    /// <item><term>ArcaneMagicFact</term><description>1391fa8dc7944e38b8e4ec97d74505c1</description></item>
    /// <item><term>SiegeMasteryRank2Fact</term><description>c483a399f210454ba35ac9a059e31e23</description></item>
    /// <item><term>TrapMasteryRank2Fact</term><description>1521cc5ecaaf4fca8e2e44b87cda6cfe</description></item>
    /// </list>
    /// </remarks>
    ///
    /// <param name="merge">
    /// If mergeBehavior is ComponentMerge.Merge and the component already exists, this expression is called to merge the components.
    /// </param>
    /// <param name="mergeBehavior">
    /// Handling if the component already exists since the component is unique. Defaults to ComponentMerge.Fail.
    /// </param>
    public TBuilder AddChangeLeaderSkillPowerOnAbilityUse(
        bool? checkDescriptor = null,
        Action<BlueprintComponent, BlueprintComponent>? merge = null,
        ComponentMerge mergeBehavior = ComponentMerge.Merge,
        int? modifier = null,
        SpellDescriptorWrapper? spellDescriptor = null)
    {
      var component = new ChangeLeaderSkillPowerOnAbilityUse();
      component.m_CheckDescriptor = checkDescriptor ?? component.m_CheckDescriptor;
      component.m_Modifier = modifier ?? component.m_Modifier;
      component.m_SpellDescriptor = spellDescriptor ?? component.m_SpellDescriptor;
      return AddUniqueComponent(component, mergeBehavior, merge);
    }

    /// <summary>
    /// Adds <see cref="RandomLeaderSpellReplacement"/>
    /// </summary>
    ///
    /// <remarks>
    ///
    /// <list type="bullet">
    /// <listheader>Used by</listheader>
    /// <item><term>Trickster3ManaFeature</term><description>126141f375334e9c87a075e013b976ed</description></item>
    /// </list>
    /// </remarks>
    public TBuilder AddRandomLeaderSpellReplacement(
        float? chanceToReplace = null)
    {
      var component = new RandomLeaderSpellReplacement();
      component.m_ChanceToReplace = chanceToReplace ?? component.m_ChanceToReplace;
      return AddComponent(component);
    }

    /// <summary>
    /// Adds <see cref="RunActionOnTurnStart"/>
    /// </summary>
    ///
    /// <remarks>
    ///
    /// <list type="bullet">
    /// <listheader>Used by</listheader>
    /// <item><term>ArmyBuildingBrewery</term><description>f0c921b4f53a4267a40f06733dd130ae</description></item>
    /// </list>
    /// </remarks>
    ///
    /// <param name="chanceCoefficient">
    /// <para>
    /// InfoBox: Probability for actions to be started
    /// </para>
    /// </param>
    public TBuilder AddRunActionOnTurnStart(
        ActionsBuilder? actions = null,
        float? chanceCoefficient = null)
    {
      var component = new RunActionOnTurnStart();
      component.m_Actions = actions?.Build() ?? component.m_Actions;
      if (component.m_Actions is null)
      {
        component.m_Actions = Utils.Constants.Empty.Actions;
      }
      component.m_ChanceCoefficient = chanceCoefficient ?? component.m_ChanceCoefficient;
      return AddComponent(component);
    }

    /// <summary>
    /// Adds <see cref="TacticalBattleEndTrigger"/>
    /// </summary>
    ///
    /// <remarks>
    ///
    /// <list type="bullet">
    /// <listheader>Used by</listheader>
    /// <item><term>PillageFact</term><description>8d01674744b34641828b77e53e0cfb9a</description></item>
    /// </list>
    /// </remarks>
    ///
    /// <param name="onlyOnVictory">
    /// <para>
    /// InfoBox: Triggers on lose too if false
    /// </para>
    /// </param>
    public TBuilder AddTacticalBattleEndTrigger(
        ActionsBuilder? onBattleEnd = null,
        bool? onlyOnVictory = null)
    {
      var component = new TacticalBattleEndTrigger();
      component.m_OnBattleEnd = onBattleEnd?.Build() ?? component.m_OnBattleEnd;
      if (component.m_OnBattleEnd is null)
      {
        component.m_OnBattleEnd = Utils.Constants.Empty.Actions;
      }
      component.OnlyOnVictory = onlyOnVictory ?? component.OnlyOnVictory;
      return AddComponent(component);
    }

    /// <summary>
    /// Adds <see cref="TacticalCellReachTrigger"/>
    /// </summary>
    ///
    /// <remarks>
    ///
    /// <list type="bullet">
    /// <listheader>Used by</listheader>
    /// <item><term>Trickster3CheckersKingFeature</term><description>016e906619394cbf9eaba1b7ff4f9387</description></item>
    /// </list>
    /// </remarks>
    public TBuilder AddTacticalCellReachTrigger(
        bool? anyX = null,
        bool? anyY = null,
        ActionsBuilder? onReach = null,
        int? x = null,
        int? y = null)
    {
      var component = new TacticalCellReachTrigger();
      component.m_AnyX = anyX ?? component.m_AnyX;
      component.m_AnyY = anyY ?? component.m_AnyY;
      component.m_OnReach = onReach?.Build() ?? component.m_OnReach;
      if (component.m_OnReach is null)
      {
        component.m_OnReach = Utils.Constants.Empty.Actions;
      }
      component.m_X = x ?? component.m_X;
      component.m_Y = y ?? component.m_Y;
      return AddComponent(component);
    }

    /// <summary>
    /// Adds <see cref="TacticalCombatPercentDamageBonus"/>
    /// </summary>
    ///
    /// <remarks>
    ///
    /// <list type="bullet">
    /// <listheader>Used by</listheader>
    /// <item><term>ArmyAttack1Ac1Damage10-Zacharius</term><description>4d75db735fd941c9999a53f67991d5ac</description></item>
    /// <item><term>ArmyDragon4Corrupt</term><description>2323d72295f24f29843dd95c63130295</description></item>
    /// <item><term>ArmyUnitsDeadlyAmmunition</term><description>10eac2c9481d45ea833ff525fb397643</description></item>
    /// </list>
    /// </remarks>
    ///
    /// <param name="merge">
    /// If mergeBehavior is ComponentMerge.Merge and the component already exists, this expression is called to merge the components.
    /// </param>
    /// <param name="mergeBehavior">
    /// Handling if the component already exists since the component is unique. Defaults to ComponentMerge.Fail.
    /// </param>
    public TBuilder AddTacticalCombatPercentDamageBonus(
        int? bonusPercent = null,
        Action<BlueprintComponent, BlueprintComponent>? merge = null,
        ComponentMerge mergeBehavior = ComponentMerge.Merge)
    {
      var component = new TacticalCombatPercentDamageBonus();
      component.BonusPercent = bonusPercent ?? component.BonusPercent;
      return AddUniqueComponent(component, mergeBehavior, merge);
    }

    /// <summary>
    /// Adds <see cref="TacticalCombatProvocation"/>
    /// </summary>
    ///
    /// <remarks>
    ///
    /// <list type="bullet">
    /// <listheader>Used by</listheader>
    /// <item><term>ArmyCavalryProvokeBuffEnemy</term><description>b3f334adf4d54cf2ac8297fa805eadac</description></item>
    /// <item><term>ArmyJuicyTargetBuffEnemy</term><description>75924a0df5b84025bde412f340e2dbcd</description></item>
    /// <item><term>RangerMaddeningPoisonBuff</term><description>45daa758da0a4151be527d921f0b32f0</description></item>
    /// </list>
    /// </remarks>
    ///
    /// <param name="aiAction">
    /// <para>
    /// InfoBox: Can have ManualTargetConsidiration
    /// </para>
    /// <para>
    /// Blueprint of type BlueprintTacticalCombatAiAction. You can pass in the blueprint using:
    /// <list type ="bullet">
    ///   <item><term>A blueprint instance</term></item>
    ///   <item><term>A blueprint reference</term></item>
    ///   <item><term>A blueprint id as a string, Guid, or BlueprintGuid</term></item>
    ///   <item><term>A blueprint name registered with <see cref="BlueprintCore.Utils.BlueprintTool">BlueprintTool</see></term></item>
    /// </list>
    /// See <see cref="BlueprintCore.Utils.Blueprint{{T, TRef}}">Blueprint</see> for more details.
    /// </para>
    /// </param>
    public TBuilder AddTacticalCombatProvocation(
        Blueprint<BlueprintTacticalCombatAiAction, BlueprintTacticalCombatAiActionReference>? aiAction = null)
    {
      var component = new TacticalCombatProvocation();
      component.m_AiAction = aiAction?.Reference ?? component.m_AiAction;
      if (component.m_AiAction is null)
      {
        component.m_AiAction = BlueprintTool.GetRef<BlueprintTacticalCombatAiActionReference>(null);
      }
      return AddComponent(component);
    }

    /// <summary>
    /// Adds <see cref="TacticalCombatResurrection"/>
    /// </summary>
    ///
    /// <remarks>
    ///
    /// <list type="bullet">
    /// <listheader>Used by</listheader>
    /// <item><term>ArmyChannelNegativeEnergyHealAbility</term><description>fe3524be49f748aa80f809778999bf59</description></item>
    /// <item><term>ArmyVampiricTouchOnHitNinjaPirates</term><description>540f87a0ae7d4caaa17596307b3586a6</description></item>
    /// <item><term>RitualJudgementDayAbility</term><description>814a31b50da1434aa9f8622b87157fda</description></item>
    /// </list>
    /// </remarks>
    public TBuilder AddTacticalCombatResurrection()
    {
      return AddComponent(new TacticalCombatResurrection());
    }

    /// <summary>
    /// Adds <see cref="TacticalCombatRider"/>
    /// </summary>
    ///
    /// <remarks>
    ///
    /// <list type="bullet">
    /// <listheader>Used by</listheader>
    /// <item><term>ArmyBarbarianOnMammoth</term><description>ad2171d3551141838cedf7df00b4efda</description></item>
    /// <item><term>ArmyInfernalCavalry</term><description>e5c7a178877148db9ee23ec81b5f1e8e</description></item>
    /// <item><term>KTC_ArmyInfernalCavalry</term><description>9e1d3efaa9704f0ebc69f05aa1ae320e</description></item>
    /// </list>
    /// </remarks>
    ///
    /// <param name="mount">
    /// <para>
    /// InfoBox: Should have prefab suitable for ridding
    /// </para>
    /// <para>
    /// Blueprint of type BlueprintUnit. You can pass in the blueprint using:
    /// <list type ="bullet">
    ///   <item><term>A blueprint instance</term></item>
    ///   <item><term>A blueprint reference</term></item>
    ///   <item><term>A blueprint id as a string, Guid, or BlueprintGuid</term></item>
    ///   <item><term>A blueprint name registered with <see cref="BlueprintCore.Utils.BlueprintTool">BlueprintTool</see></term></item>
    /// </list>
    /// See <see cref="BlueprintCore.Utils.Blueprint{{T, TRef}}">Blueprint</see> for more details.
    /// </para>
    /// </param>
    public TBuilder AddTacticalCombatRider(
        bool? applyRiderScaleToHorse = null,
        Blueprint<BlueprintUnit, BlueprintUnitReference>? mount = null)
    {
      var component = new TacticalCombatRider();
      component.m_ApplyRiderScaleToHorse = applyRiderScaleToHorse ?? component.m_ApplyRiderScaleToHorse;
      component.m_Mount = mount?.Reference ?? component.m_Mount;
      if (component.m_Mount is null)
      {
        component.m_Mount = BlueprintTool.GetRef<BlueprintUnitReference>(null);
      }
      return AddComponent(component);
    }

    /// <summary>
    /// Adds <see cref="TacticalCombatRoundTrigger"/>
    /// </summary>
    ///
    /// <remarks>
    ///
    /// <list type="bullet">
    /// <listheader>Used by</listheader>
    /// <item><term>Aeon5BaneOfDemonsBuff</term><description>7f3a76f5ebee4ff593528ff3e3175a02</description></item>
    /// <item><term>ArmyReachingStrikeStopBuff</term><description>e09ac031dde74ead9ecc9872a80e117b</description></item>
    /// <item><term>TwincastSecondBuff</term><description>03155c66e1ad48d398a5aaed0cfb67ed</description></item>
    /// </list>
    /// </remarks>
    public TBuilder AddTacticalCombatRoundTrigger(
        ActionsBuilder? newRoundActions = null)
    {
      var component = new TacticalCombatRoundTrigger();
      component.NewRoundActions = newRoundActions?.Build() ?? component.NewRoundActions;
      if (component.NewRoundActions is null)
      {
        component.NewRoundActions = Utils.Constants.Empty.Actions;
      }
      return AddComponent(component);
    }

    /// <summary>
    /// Adds <see cref="TacticalCombatVisibleFeature"/>
    /// </summary>
    ///
    /// <remarks>
    ///
    /// <list type="bullet">
    /// <listheader>Used by</listheader>
    /// <item><term>ArmyACAgainstRangeAuraFeature</term><description>e44e483c864349cf8eda2ac753ef0171</description></item>
    /// <item><term>ArmyGhoulParalysisFeature</term><description>0ff98740c64f4d948e783f6e0dcd4bd7</description></item>
    /// <item><term>SubtypeExtraplanar</term><description>136fa0343d5b4b348bdaa05d83408db3</description></item>
    /// </list>
    /// </remarks>
    public TBuilder AddTacticalCombatVisibleFeature()
    {
      return AddComponent(new TacticalCombatVisibleFeature());
    }

    /// <summary>
    /// Adds <see cref="TacticalSquadDeathTrigger"/>
    /// </summary>
    ///
    /// <remarks>
    ///
    /// <list type="bullet">
    /// <listheader>Used by</listheader>
    /// <item><term>Trickster3KillOrderFeature</term><description>6d5896233b7a4787ad4ff7dad57e241f</description></item>
    /// </list>
    /// </remarks>
    ///
    /// <param name="armyFactOnOthersDeath">
    /// <para>
    /// Blueprint of type BlueprintUnitFact. You can pass in the blueprint using:
    /// <list type ="bullet">
    ///   <item><term>A blueprint instance</term></item>
    ///   <item><term>A blueprint reference</term></item>
    ///   <item><term>A blueprint id as a string, Guid, or BlueprintGuid</term></item>
    ///   <item><term>A blueprint name registered with <see cref="BlueprintCore.Utils.BlueprintTool">BlueprintTool</see></term></item>
    /// </list>
    /// See <see cref="BlueprintCore.Utils.Blueprint{{T, TRef}}">Blueprint</see> for more details.
    /// </para>
    /// </param>
    /// <param name="armyFactOnOwnerDeath">
    /// <para>
    /// Blueprint of type BlueprintUnitFact. You can pass in the blueprint using:
    /// <list type ="bullet">
    ///   <item><term>A blueprint instance</term></item>
    ///   <item><term>A blueprint reference</term></item>
    ///   <item><term>A blueprint id as a string, Guid, or BlueprintGuid</term></item>
    ///   <item><term>A blueprint name registered with <see cref="BlueprintCore.Utils.BlueprintTool">BlueprintTool</see></term></item>
    /// </list>
    /// See <see cref="BlueprintCore.Utils.Blueprint{{T, TRef}}">Blueprint</see> for more details.
    /// </para>
    /// </param>
    public TBuilder AddTacticalSquadDeathTrigger(
        Blueprint<BlueprintUnitFact, BlueprintUnitFactReference>? armyFactOnOthersDeath = null,
        Blueprint<BlueprintUnitFact, BlueprintUnitFactReference>? armyFactOnOwnerDeath = null,
        ArmyFaction? factDestinationFaction = null,
        bool? removeFactOnAnyDeath = null)
    {
      var component = new TacticalSquadDeathTrigger();
      component.m_ArmyFactOnOthersDeath = armyFactOnOthersDeath?.Reference ?? component.m_ArmyFactOnOthersDeath;
      if (component.m_ArmyFactOnOthersDeath is null)
      {
        component.m_ArmyFactOnOthersDeath = BlueprintTool.GetRef<BlueprintUnitFactReference>(null);
      }
      component.m_ArmyFactOnOwnerDeath = armyFactOnOwnerDeath?.Reference ?? component.m_ArmyFactOnOwnerDeath;
      if (component.m_ArmyFactOnOwnerDeath is null)
      {
        component.m_ArmyFactOnOwnerDeath = BlueprintTool.GetRef<BlueprintUnitFactReference>(null);
      }
      component.m_FactDestinationFaction = factDestinationFaction ?? component.m_FactDestinationFaction;
      component.m_RemoveFactOnAnyDeath = removeFactOnAnyDeath ?? component.m_RemoveFactOnAnyDeath;
      return AddComponent(component);
    }

    /// <summary>
    /// Adds <see cref="ArmyDamageAfterMovementBonus"/>
    /// </summary>
    ///
    /// <remarks>
    ///
    /// <list type="bullet">
    /// <listheader>Used by</listheader>
    /// <item><term>ArmyAttackBonusAfterMovement</term><description>33c3012d02e7ece46897ea502385340b</description></item>
    /// <item><term>ArmyAttackBonusAfterMovementBardriud</term><description>988a9b694653464c8f95da50080d4d8e</description></item>
    /// <item><term>Azata1InspiredAdvanceBuff</term><description>fe34bc284b16440296db96916eae8dcc</description></item>
    /// </list>
    /// </remarks>
    ///
    /// <param name="accumulateBonusPerCell">
    /// <para>
    /// InfoBox: If false add Bonus value if unit moved before attack once. If true add Bonus value for each cell passed
    /// </para>
    /// </param>
    /// <param name="merge">
    /// If mergeBehavior is ComponentMerge.Merge and the component already exists, this expression is called to merge the components.
    /// </param>
    /// <param name="mergeBehavior">
    /// Handling if the component already exists since the component is unique. Defaults to ComponentMerge.Fail.
    /// </param>
    /// <param name="onDamageDeal">
    /// <para>
    /// InfoBox: Actions that will run on damage dealing after movement
    /// </para>
    /// </param>
    public TBuilder AddArmyDamageAfterMovementBonus(
        bool? accumulateBonusPerCell = null,
        float? bonus = null,
        Action<BlueprintComponent, BlueprintComponent>? merge = null,
        ComponentMerge mergeBehavior = ComponentMerge.Merge,
        ActionsBuilder? onDamageDeal = null)
    {
      var component = new ArmyDamageAfterMovementBonus();
      component.m_AccumulateBonusPerCell = accumulateBonusPerCell ?? component.m_AccumulateBonusPerCell;
      component.m_Bonus = bonus ?? component.m_Bonus;
      component.OnDamageDeal = onDamageDeal?.Build() ?? component.OnDamageDeal;
      if (component.OnDamageDeal is null)
      {
        component.OnDamageDeal = Utils.Constants.Empty.Actions;
      }
      return AddUniqueComponent(component, mergeBehavior, merge);
    }

    /// <summary>
    /// Adds <see cref="ArmyStandingDamageBonus"/>
    /// </summary>
    ///
    /// <remarks>
    ///
    /// <list type="bullet">
    /// <listheader>Used by</listheader>
    /// <item><term>ArmyAttackBonusNoMovement</term><description>e91999c00fef81b4b97c15742eaf93e3</description></item>
    /// </list>
    /// </remarks>
    ///
    /// <param name="bonus">
    /// <para>
    /// InfoBox: Add Bonus value if unit didn't move before attack
    /// </para>
    /// </param>
    /// <param name="merge">
    /// If mergeBehavior is ComponentMerge.Merge and the component already exists, this expression is called to merge the components.
    /// </param>
    /// <param name="mergeBehavior">
    /// Handling if the component already exists since the component is unique. Defaults to ComponentMerge.Fail.
    /// </param>
    /// <param name="onDamageDeal">
    /// <para>
    /// InfoBox: Actions that will run on damage dealing without movement
    /// </para>
    /// </param>
    public TBuilder AddArmyStandingDamageBonus(
        int? bonus = null,
        Action<BlueprintComponent, BlueprintComponent>? merge = null,
        ComponentMerge mergeBehavior = ComponentMerge.Merge,
        ActionsBuilder? onDamageDeal = null)
    {
      var component = new ArmyStandingDamageBonus();
      component.m_Bonus = bonus ?? component.m_Bonus;
      component.OnDamageDeal = onDamageDeal?.Build() ?? component.OnDamageDeal;
      if (component.OnDamageDeal is null)
      {
        component.OnDamageDeal = Utils.Constants.Empty.Actions;
      }
      return AddUniqueComponent(component, mergeBehavior, merge);
    }

    /// <summary>
    /// Adds <see cref="ACBonusAgainstAttackOfOpportunity"/>
    /// </summary>
    ///
    /// <remarks>
    ///
    /// <list type="bullet">
    /// <listheader>Used by</listheader>
    /// <item><term>BackgroundRiverKingdomsDaredevil</term><description>c9cb4176176b4164ca3c0a65feda0226</description></item>
    /// <item><term>HermitRevelationReclusesStride5Buff</term><description>96a8866e7cd3c1148bd5a0ca47c5b95c</description></item>
    /// <item><term>SpellDanceMainBuff</term><description>63034b7e3bbe43c45a3f2f798dfe5215</description></item>
    /// </list>
    /// </remarks>
    public TBuilder AddACBonusAgainstAttackOfOpportunity(
        ContextValue? bonus = null,
        bool? notAttackOfOpportunity = null)
    {
      var component = new ACBonusAgainstAttackOfOpportunity();
      component.Bonus = bonus ?? component.Bonus;
      if (component.Bonus is null)
      {
        component.Bonus = ContextValues.Constant(0);
      }
      component.NotAttackOfOpportunity = notAttackOfOpportunity ?? component.NotAttackOfOpportunity;
      return AddComponent(component);
    }

    /// <summary>
    /// Adds <see cref="ACBonusAgainstAttacks"/>
    /// </summary>
    ///
    /// <remarks>
    ///
    /// <para>
    /// ComponentName: AC bonus against Attacks
    /// </para>
    ///
    /// <list type="bullet">
    /// <listheader>Used by</listheader>
    /// <item><term>AcidFogBuff</term><description>af76754540cacca45bfb1f0074bf3013</description></item>
    /// <item><term>BuffWingsMutagen</term><description>e4979934bdb39d842b28bee614606823</description></item>
    /// <item><term>WingsMovanicDeva</term><description>775df52784e1d454cba0da8df5f4f59a</description></item>
    /// </list>
    /// </remarks>
    ///
    /// <param name="merge">
    /// If mergeBehavior is ComponentMerge.Merge and the component already exists, this expression is called to merge the components.
    /// </param>
    /// <param name="mergeBehavior">
    /// Handling if the component already exists since the component is unique. Defaults to ComponentMerge.Fail.
    /// </param>
    public TBuilder AddACBonusAgainstAttacks(
        bool? againstMeleeOnly = null,
        bool? againstRangedOnly = null,
        int? armorClassBonus = null,
        bool? checkArmorCategory = null,
        ModifierDescriptor? descriptor = null,
        bool? isTouch = null,
        Action<BlueprintComponent, BlueprintComponent>? merge = null,
        ComponentMerge mergeBehavior = ComponentMerge.Merge,
        bool? noShield = null,
        ArmorProficiencyGroup[]? notArmorCategory = null,
        bool? notTouch = null,
        bool? onlyAttacksOfOpportunity = null,
        bool? onlySneakAttack = null,
        ContextValue? value = null)
    {
      var component = new ACBonusAgainstAttacks();
      component.AgainstMeleeOnly = againstMeleeOnly ?? component.AgainstMeleeOnly;
      component.AgainstRangedOnly = againstRangedOnly ?? component.AgainstRangedOnly;
      component.ArmorClassBonus = armorClassBonus ?? component.ArmorClassBonus;
      component.CheckArmorCategory = checkArmorCategory ?? component.CheckArmorCategory;
      component.Descriptor = descriptor ?? component.Descriptor;
      component.IsTouch = isTouch ?? component.IsTouch;
      component.NoShield = noShield ?? component.NoShield;
      component.NotArmorCategory = notArmorCategory ?? component.NotArmorCategory;
      if (component.NotArmorCategory is null)
      {
        component.NotArmorCategory = new ArmorProficiencyGroup[0];
      }
      component.NotTouch = notTouch ?? component.NotTouch;
      component.OnlyAttacksOfOpportunity = onlyAttacksOfOpportunity ?? component.OnlyAttacksOfOpportunity;
      component.OnlySneakAttack = onlySneakAttack ?? component.OnlySneakAttack;
      component.Value = value ?? component.Value;
      if (component.Value is null)
      {
        component.Value = ContextValues.Constant(0);
      }
      return AddUniqueComponent(component, mergeBehavior, merge);
    }

    /// <summary>
    /// Adds <see cref="ACBonusAgainstBuffOwner"/>
    /// </summary>
    ///
    /// <remarks>
    ///
    /// <para>
    /// ComponentName: Armor check penalty increase
    /// </para>
    ///
    /// <list type="bullet">
    /// <listheader>Used by</listheader>
    /// <item><term>DefensiveSpinBuff</term><description>3e0146b786c064441834fc025d09a67c</description></item>
    /// <item><term>GrimArmorFeature</term><description>445abb814f5cbb44b8fe082646635147</description></item>
    /// </list>
    /// </remarks>
    ///
    /// <param name="checkedBuff">
    /// <para>
    /// Blueprint of type BlueprintBuff. You can pass in the blueprint using:
    /// <list type ="bullet">
    ///   <item><term>A blueprint instance</term></item>
    ///   <item><term>A blueprint reference</term></item>
    ///   <item><term>A blueprint id as a string, Guid, or BlueprintGuid</term></item>
    ///   <item><term>A blueprint name registered with <see cref="BlueprintCore.Utils.BlueprintTool">BlueprintTool</see></term></item>
    /// </list>
    /// See <see cref="BlueprintCore.Utils.Blueprint{{T, TRef}}">Blueprint</see> for more details.
    /// </para>
    /// </param>
    public TBuilder AddACBonusAgainstBuffOwner(
        AlignmentComponent? alignment = null,
        int? bonus = null,
        bool? checkAlignment = null,
        Blueprint<BlueprintBuff, BlueprintBuffReference>? checkedBuff = null,
        ModifierDescriptor? descriptor = null)
    {
      var component = new ACBonusAgainstBuffOwner();
      component.Alignment = alignment ?? component.Alignment;
      component.Bonus = bonus ?? component.Bonus;
      component.CheckAlignment = checkAlignment ?? component.CheckAlignment;
      component.m_CheckedBuff = checkedBuff?.Reference ?? component.m_CheckedBuff;
      if (component.m_CheckedBuff is null)
      {
        component.m_CheckedBuff = BlueprintTool.GetRef<BlueprintBuffReference>(null);
      }
      component.Descriptor = descriptor ?? component.Descriptor;
      return AddComponent(component);
    }

    /// <summary>
    /// Adds <see cref="ACBonusAgainstFactOwner"/>
    /// </summary>
    ///
    /// <remarks>
    ///
    /// <para>
    /// ComponentName: Armor check penalty increase
    /// </para>
    ///
    /// <list type="bullet">
    /// <listheader>Used by</listheader>
    /// <item><term>3ACAgainstGiantPlus2Feature</term><description>ff5521b401d5a8f4d9f89f2927d0d96d</description></item>
    /// <item><term>GraveyardKeepersHelmetFeature</term><description>8fdd93bd60f1a2e49af041e849e1ce7c</description></item>
    /// <item><term>WyrmwallShieldFeature</term><description>e39c32ce1d7b174419fc190f7ebc3a26</description></item>
    /// </list>
    /// </remarks>
    ///
    /// <param name="checkedFact">
    /// <para>
    /// Blueprint of type BlueprintUnitFact. You can pass in the blueprint using:
    /// <list type ="bullet">
    ///   <item><term>A blueprint instance</term></item>
    ///   <item><term>A blueprint reference</term></item>
    ///   <item><term>A blueprint id as a string, Guid, or BlueprintGuid</term></item>
    ///   <item><term>A blueprint name registered with <see cref="BlueprintCore.Utils.BlueprintTool">BlueprintTool</see></term></item>
    /// </list>
    /// See <see cref="BlueprintCore.Utils.Blueprint{{T, TRef}}">Blueprint</see> for more details.
    /// </para>
    /// </param>
    /// <param name="merge">
    /// If mergeBehavior is ComponentMerge.Merge and the component already exists, this expression is called to merge the components.
    /// </param>
    /// <param name="mergeBehavior">
    /// Handling if the component already exists since the component is unique. Defaults to ComponentMerge.Fail.
    /// </param>
    public TBuilder AddACBonusAgainstFactOwner(
        AlignmentComponent? alignment = null,
        int? bonus = null,
        Blueprint<BlueprintUnitFact, BlueprintUnitFactReference>? checkedFact = null,
        ModifierDescriptor? descriptor = null,
        Action<BlueprintComponent, BlueprintComponent>? merge = null,
        ComponentMerge mergeBehavior = ComponentMerge.Merge,
        bool? noFact = null)
    {
      var component = new ACBonusAgainstFactOwner();
      component.Alignment = alignment ?? component.Alignment;
      component.Bonus = bonus ?? component.Bonus;
      component.m_CheckedFact = checkedFact?.Reference ?? component.m_CheckedFact;
      if (component.m_CheckedFact is null)
      {
        component.m_CheckedFact = BlueprintTool.GetRef<BlueprintUnitFactReference>(null);
      }
      component.Descriptor = descriptor ?? component.Descriptor;
      component.NoFact = noFact ?? component.NoFact;
      return AddUniqueComponent(component, mergeBehavior, merge);
    }

    /// <summary>
    /// Adds <see cref="ACBonusAgainstFactOwnerMultiple"/>
    /// </summary>
    ///
    /// <remarks>
    ///
    /// <para>
    /// ComponentName: Armor check penalty increase
    /// </para>
    ///
    /// <list type="bullet">
    /// <listheader>Used by</listheader>
    /// <item><term>VeilOfHeavenBuff</term><description>f5d3311a675a7174dad7ffa99a81ad56</description></item>
    /// </list>
    /// </remarks>
    ///
    /// <param name="facts">
    /// <para>
    /// Blueprint of type BlueprintUnitFact. You can pass in the blueprint using:
    /// <list type ="bullet">
    ///   <item><term>A blueprint instance</term></item>
    ///   <item><term>A blueprint reference</term></item>
    ///   <item><term>A blueprint id as a string, Guid, or BlueprintGuid</term></item>
    ///   <item><term>A blueprint name registered with <see cref="BlueprintCore.Utils.BlueprintTool">BlueprintTool</see></term></item>
    /// </list>
    /// See <see cref="BlueprintCore.Utils.Blueprint{{T, TRef}}">Blueprint</see> for more details.
    /// </para>
    /// </param>
    public TBuilder AddACBonusAgainstFactOwnerMultiple(
        AlignmentComponent? alignment = null,
        int? bonus = null,
        ModifierDescriptor? descriptor = null,
        List<Blueprint<BlueprintUnitFact, BlueprintUnitFactReference>>? facts = null)
    {
      var component = new ACBonusAgainstFactOwnerMultiple();
      component.Alignment = alignment ?? component.Alignment;
      component.Bonus = bonus ?? component.Bonus;
      component.Descriptor = descriptor ?? component.Descriptor;
      component.m_Facts = facts?.Select(bp => bp.Reference)?.ToArray() ?? component.m_Facts;
      if (component.m_Facts is null)
      {
        component.m_Facts = new BlueprintUnitFactReference[0];
      }
      return AddComponent(component);
    }

    /// <summary>
    /// Adds <see cref="ACBonusAgainstSize"/>
    /// </summary>
    ///
    /// <remarks>
    ///
    /// <list type="bullet">
    /// <listheader>Used by</listheader>
    /// <item><term>AmuletOfDeepRootsFeature</term><description>27d0e6894ba6484a939efc0afe2b13fe</description></item>
    /// <item><term>BardingOfElderBeastsFeature</term><description>b94875a04bf8df44494f810b7b240940</description></item>
    /// <item><term>WrathOfTheCreatorItemFeature</term><description>5600fc815bc0404e98b6f0bc4ce9665d</description></item>
    /// </list>
    /// </remarks>
    ///
    /// <param name="merge">
    /// If mergeBehavior is ComponentMerge.Merge and the component already exists, this expression is called to merge the components.
    /// </param>
    /// <param name="mergeBehavior">
    /// Handling if the component already exists since the component is unique. Defaults to ComponentMerge.Fail.
    /// </param>
    public TBuilder AddACBonusAgainstSize(
        ModifierDescriptor? descriptor = null,
        Action<BlueprintComponent, BlueprintComponent>? merge = null,
        ComponentMerge mergeBehavior = ComponentMerge.Merge,
        Size? size = null,
        ContextValue? value = null)
    {
      var component = new ACBonusAgainstSize();
      component.Descriptor = descriptor ?? component.Descriptor;
      component.Size = size ?? component.Size;
      component.Value = value ?? component.Value;
      if (component.Value is null)
      {
        component.Value = ContextValues.Constant(0);
      }
      return AddUniqueComponent(component, mergeBehavior, merge);
    }

    /// <summary>
    /// Adds <see cref="ACBonusAgainstSpellsWithDescriptor"/>
    /// </summary>
    ///
    /// <remarks>
    ///
    /// <para>
    /// ComponentName: AC bonus against Attacks
    /// </para>
    ///
    /// <list type="bullet">
    /// <listheader>Used by</listheader>
    /// <item><term>CrystallEyeFeature</term><description>1fe9cd3fb689e2f49b8eafd78864bb9d</description></item>
    /// <item><term>MagneticInfusionEffectBuff</term><description>07afee46a4533e74bbb2e962768864ad</description></item>
    /// </list>
    /// </remarks>
    ///
    /// <param name="merge">
    /// If mergeBehavior is ComponentMerge.Merge and the component already exists, this expression is called to merge the components.
    /// </param>
    /// <param name="mergeBehavior">
    /// Handling if the component already exists since the component is unique. Defaults to ComponentMerge.Fail.
    /// </param>
    public TBuilder AddACBonusAgainstSpellsWithDescriptor(
        int? armorClassBonus = null,
        ModifierDescriptor? descriptor = null,
        Action<BlueprintComponent, BlueprintComponent>? merge = null,
        ComponentMerge mergeBehavior = ComponentMerge.Merge,
        SpellDescriptorWrapper? spellDescriptor = null)
    {
      var component = new ACBonusAgainstSpellsWithDescriptor();
      component.ArmorClassBonus = armorClassBonus ?? component.ArmorClassBonus;
      component.Descriptor = descriptor ?? component.Descriptor;
      component.SpellDescriptor = spellDescriptor ?? component.SpellDescriptor;
      return AddUniqueComponent(component, mergeBehavior, merge);
    }

    /// <summary>
    /// Adds <see cref="ACBonusAgainstWeaponCategory"/>
    /// </summary>
    ///
    /// <remarks>
    ///
    /// <para>
    /// ComponentName: AC bonus against Attacks
    /// </para>
    ///
    /// <list type="bullet">
    /// <listheader>Used by</listheader>
    /// <item><term>AncientWoodFeature</term><description>dfc2ebb7f1fc41b8bd89aacb928dae3b</description></item>
    /// <item><term>BucklerOfRayNegationShieldFeature</term><description>7ff345fc456349d4fa4529c0baa8ed84</description></item>
    /// <item><term>CookieDemonSculptureBuff</term><description>ba35ae51f72275d46aeda333fab68d39</description></item>
    /// </list>
    /// </remarks>
    ///
    /// <param name="merge">
    /// If mergeBehavior is ComponentMerge.Merge and the component already exists, this expression is called to merge the components.
    /// </param>
    /// <param name="mergeBehavior">
    /// Handling if the component already exists since the component is unique. Defaults to ComponentMerge.Fail.
    /// </param>
    public TBuilder AddACBonusAgainstWeaponCategory(
        int? armorClassBonus = null,
        WeaponCategory? category = null,
        ModifierDescriptor? descriptor = null,
        Action<BlueprintComponent, BlueprintComponent>? merge = null,
        ComponentMerge mergeBehavior = ComponentMerge.Merge)
    {
      var component = new ACBonusAgainstWeaponCategory();
      component.ArmorClassBonus = armorClassBonus ?? component.ArmorClassBonus;
      component.Category = category ?? component.Category;
      component.Descriptor = descriptor ?? component.Descriptor;
      return AddUniqueComponent(component, mergeBehavior, merge);
    }

    /// <summary>
    /// Adds <see cref="ACBonusAgainstWeaponGroup"/>
    /// </summary>
    ///
    /// <remarks>
    ///
    /// <para>
    /// ComponentName: AC bonus against Attacks
    /// </para>
    ///
    /// <list type="bullet">
    /// <listheader>Used by</listheader>
    /// <item><term>KnifeMasterBladeSense</term><description>112bf4c6943097942b24eadfa750215f</description></item>
    /// </list>
    /// </remarks>
    ///
    /// <param name="merge">
    /// If mergeBehavior is ComponentMerge.Merge and the component already exists, this expression is called to merge the components.
    /// </param>
    /// <param name="mergeBehavior">
    /// Handling if the component already exists since the component is unique. Defaults to ComponentMerge.Fail.
    /// </param>
    public TBuilder AddACBonusAgainstWeaponGroup(
        int? armorClassBonus = null,
        ModifierDescriptor? descriptor = null,
        WeaponFighterGroup? fighterGroup = null,
        Action<BlueprintComponent, BlueprintComponent>? merge = null,
        ComponentMerge mergeBehavior = ComponentMerge.Merge)
    {
      var component = new ACBonusAgainstWeaponGroup();
      component.ArmorClassBonus = armorClassBonus ?? component.ArmorClassBonus;
      component.Descriptor = descriptor ?? component.Descriptor;
      component.FighterGroup = fighterGroup ?? component.FighterGroup;
      return AddUniqueComponent(component, mergeBehavior, merge);
    }

    /// <summary>
    /// Adds <see cref="ACBonusAgainstWeaponSubcategory"/>
    /// </summary>
    ///
    /// <remarks>
    ///
    /// <para>
    /// ComponentName: AC bonus against Attacks
    /// </para>
    ///
    /// <list type="bullet">
    /// <listheader>Used by</listheader>
    /// <item><term>EludingTargetFeature</term><description>45a1552f6ccfb0346888f8f9629b80fe</description></item>
    /// <item><term>MagneticInfusionEffectBuff</term><description>07afee46a4533e74bbb2e962768864ad</description></item>
    /// <item><term>RockOfNatureFeature</term><description>f365092f34361104a84332f31e7bd784</description></item>
    /// </list>
    /// </remarks>
    ///
    /// <param name="merge">
    /// If mergeBehavior is ComponentMerge.Merge and the component already exists, this expression is called to merge the components.
    /// </param>
    /// <param name="mergeBehavior">
    /// Handling if the component already exists since the component is unique. Defaults to ComponentMerge.Fail.
    /// </param>
    public TBuilder AddACBonusAgainstWeaponSubcategory(
        int? armorClassBonus = null,
        ModifierDescriptor? descriptor = null,
        Action<BlueprintComponent, BlueprintComponent>? merge = null,
        ComponentMerge mergeBehavior = ComponentMerge.Merge,
        WeaponSubCategory? subCategory = null)
    {
      var component = new ACBonusAgainstWeaponSubcategory();
      component.ArmorClassBonus = armorClassBonus ?? component.ArmorClassBonus;
      component.Descriptor = descriptor ?? component.Descriptor;
      component.SubCategory = subCategory ?? component.SubCategory;
      return AddUniqueComponent(component, mergeBehavior, merge);
    }

    /// <summary>
    /// Adds <see cref="ACBonusAgainstWeaponType"/>
    /// </summary>
    ///
    /// <remarks>
    ///
    /// <list type="bullet">
    /// <listheader>Used by</listheader>
    /// <item><term>IncorporealACFeature1</term><description>52bb405096f0e604997f58dfa0549303</description></item>
    /// <item><term>IncorporealACFeature6</term><description>cfc5348738262074083a7358085dfacd</description></item>
    /// <item><term>VoidMirrorFeature</term><description>2e64ae3397f041f4cbccc4184d8f0084</description></item>
    /// </list>
    /// </remarks>
    ///
    /// <param name="merge">
    /// If mergeBehavior is ComponentMerge.Merge and the component already exists, this expression is called to merge the components.
    /// </param>
    /// <param name="mergeBehavior">
    /// Handling if the component already exists since the component is unique. Defaults to ComponentMerge.Fail.
    /// </param>
    /// <param name="type">
    /// <para>
    /// Blueprint of type BlueprintWeaponType. You can pass in the blueprint using:
    /// <list type ="bullet">
    ///   <item><term>A blueprint instance</term></item>
    ///   <item><term>A blueprint reference</term></item>
    ///   <item><term>A blueprint id as a string, Guid, or BlueprintGuid</term></item>
    ///   <item><term>A blueprint name registered with <see cref="BlueprintCore.Utils.BlueprintTool">BlueprintTool</see></term></item>
    /// </list>
    /// See <see cref="BlueprintCore.Utils.Blueprint{{T, TRef}}">Blueprint</see> for more details.
    /// </para>
    /// </param>
    public TBuilder AddACBonusAgainstWeaponType(
        int? armorClassBonus = null,
        ModifierDescriptor? descriptor = null,
        Action<BlueprintComponent, BlueprintComponent>? merge = null,
        ComponentMerge mergeBehavior = ComponentMerge.Merge,
        Blueprint<BlueprintWeaponType, BlueprintWeaponTypeReference>? type = null)
    {
      var component = new ACBonusAgainstWeaponType();
      component.ArmorClassBonus = armorClassBonus ?? component.ArmorClassBonus;
      component.Descriptor = descriptor ?? component.Descriptor;
      component.m_Type = type?.Reference ?? component.m_Type;
      if (component.m_Type is null)
      {
        component.m_Type = BlueprintTool.GetRef<BlueprintWeaponTypeReference>(null);
      }
      return AddUniqueComponent(component, mergeBehavior, merge);
    }

    /// <summary>
    /// Adds <see cref="ACBonusUnlessFactMultiple"/>
    /// </summary>
    ///
    /// <remarks>
    ///
    /// <para>
    /// ComponentName: Armor check penalty increase
    /// </para>
    ///
    /// <list type="bullet">
    /// <listheader>Used by</listheader>
    /// <item><term>SeamantleBuff</term><description>1c05dd3a1c78b0e4e9f7438a43e7a9fd</description></item>
    /// </list>
    /// </remarks>
    ///
    /// <param name="facts">
    /// <para>
    /// Blueprint of type BlueprintUnitFact. You can pass in the blueprint using:
    /// <list type ="bullet">
    ///   <item><term>A blueprint instance</term></item>
    ///   <item><term>A blueprint reference</term></item>
    ///   <item><term>A blueprint id as a string, Guid, or BlueprintGuid</term></item>
    ///   <item><term>A blueprint name registered with <see cref="BlueprintCore.Utils.BlueprintTool">BlueprintTool</see></term></item>
    /// </list>
    /// See <see cref="BlueprintCore.Utils.Blueprint{{T, TRef}}">Blueprint</see> for more details.
    /// </para>
    /// </param>
    public TBuilder AddACBonusUnlessFactMultiple(
        AlignmentComponent? alignment = null,
        int? bonus = null,
        ModifierDescriptor? descriptor = null,
        List<Blueprint<BlueprintUnitFact, BlueprintUnitFactReference>>? facts = null)
    {
      var component = new ACBonusUnlessFactMultiple();
      component.Alignment = alignment ?? component.Alignment;
      component.Bonus = bonus ?? component.Bonus;
      component.Descriptor = descriptor ?? component.Descriptor;
      component.m_Facts = facts?.Select(bp => bp.Reference)?.ToArray() ?? component.m_Facts;
      if (component.m_Facts is null)
      {
        component.m_Facts = new BlueprintUnitFactReference[0];
      }
      return AddComponent(component);
    }

    /// <summary>
    /// Adds <see cref="ACContextBonusAgainstFactOwner"/>
    /// </summary>
    ///
    /// <remarks>
    ///
    /// <list type="bullet">
    /// <listheader>Used by</listheader>
    /// <item><term>CavalierLionChallenge</term><description>1a42774a957681c42a1161acf654086a</description></item>
    /// <item><term>CavalierSpiritualShield</term><description>d8d96bcc9a5ba3c448b12da464efaeb7</description></item>
    /// <item><term>StudentOfWarKnowYourEnemyDefensiveStanceBuff</term><description>8f195d9b099048f4d89f3dcadbeedc56</description></item>
    /// </list>
    /// </remarks>
    ///
    /// <param name="checkedFact">
    /// <para>
    /// Blueprint of type BlueprintUnitFact. You can pass in the blueprint using:
    /// <list type ="bullet">
    ///   <item><term>A blueprint instance</term></item>
    ///   <item><term>A blueprint reference</term></item>
    ///   <item><term>A blueprint id as a string, Guid, or BlueprintGuid</term></item>
    ///   <item><term>A blueprint name registered with <see cref="BlueprintCore.Utils.BlueprintTool">BlueprintTool</see></term></item>
    /// </list>
    /// See <see cref="BlueprintCore.Utils.Blueprint{{T, TRef}}">Blueprint</see> for more details.
    /// </para>
    /// </param>
    /// <param name="merge">
    /// If mergeBehavior is ComponentMerge.Merge and the component already exists, this expression is called to merge the components.
    /// </param>
    /// <param name="mergeBehavior">
    /// Handling if the component already exists since the component is unique. Defaults to ComponentMerge.Fail.
    /// </param>
    public TBuilder AddACContextBonusAgainstFactOwner(
        AlignmentComponent? alignment = null,
        ContextValue? bonus = null,
        Blueprint<BlueprintUnitFact, BlueprintUnitFactReference>? checkedFact = null,
        ModifierDescriptor? descriptor = null,
        Action<BlueprintComponent, BlueprintComponent>? merge = null,
        ComponentMerge mergeBehavior = ComponentMerge.Merge,
        bool? noFact = null)
    {
      var component = new ACContextBonusAgainstFactOwner();
      component.Alignment = alignment ?? component.Alignment;
      component.Bonus = bonus ?? component.Bonus;
      if (component.Bonus is null)
      {
        component.Bonus = ContextValues.Constant(0);
      }
      component.m_CheckedFact = checkedFact?.Reference ?? component.m_CheckedFact;
      if (component.m_CheckedFact is null)
      {
        component.m_CheckedFact = BlueprintTool.GetRef<BlueprintUnitFactReference>(null);
      }
      component.Descriptor = descriptor ?? component.Descriptor;
      component.NoFact = noFact ?? component.NoFact;
      return AddUniqueComponent(component, mergeBehavior, merge);
    }

    /// <summary>
    /// Adds <see cref="ACContextBonusAgainstWeaponSubcategory"/>
    /// </summary>
    ///
    /// <remarks>
    ///
    /// <para>
    /// ComponentName: AC bonus against Attacks
    /// </para>
    ///
    /// <list type="bullet">
    /// <listheader>Used by</listheader>
    /// <item><term>DistractingShotsBuff</term><description>d24085bcafced954787c200c0ba9d928</description></item>
    /// <item><term>RollingDodgeEffectBuff</term><description>42a5fea471dfdec4b91c97bb8acde5ff</description></item>
    /// <item><term>ShamanHexMetalCurseBuff</term><description>4806a27100d7f4e4f8dc5aa1bcdf61c6</description></item>
    /// </list>
    /// </remarks>
    ///
    /// <param name="merge">
    /// If mergeBehavior is ComponentMerge.Merge and the component already exists, this expression is called to merge the components.
    /// </param>
    /// <param name="mergeBehavior">
    /// Handling if the component already exists since the component is unique. Defaults to ComponentMerge.Fail.
    /// </param>
    public TBuilder AddACContextBonusAgainstWeaponSubcategory(
        ModifierDescriptor? descriptor = null,
        Action<BlueprintComponent, BlueprintComponent>? merge = null,
        ComponentMerge mergeBehavior = ComponentMerge.Merge,
        WeaponSubCategory? subCategory = null,
        ContextValue? value = null)
    {
      var component = new ACContextBonusAgainstWeaponSubcategory();
      component.Descriptor = descriptor ?? component.Descriptor;
      component.SubCategory = subCategory ?? component.SubCategory;
      component.Value = value ?? component.Value;
      if (component.Value is null)
      {
        component.Value = ContextValues.Constant(0);
      }
      return AddUniqueComponent(component, mergeBehavior, merge);
    }

    /// <summary>
    /// Adds <see cref="AbilityMythicParams"/>
    /// </summary>
    ///
    /// <remarks>
    ///
    /// <list type="bullet">
    /// <listheader>Used by</listheader>
    /// <item><term>AeonDemythication</term><description>c62280cbab88eb7458b867ff899cea3e</description></item>
    /// <item><term>LichChannelNegativeFeature</term><description>295dff380fb8ed743bd5c76a30a49a46</description></item>
    /// </list>
    /// </remarks>
    ///
    /// <param name="abilites">
    /// <para>
    /// Blueprint of type BlueprintAbility. You can pass in the blueprint using:
    /// <list type ="bullet">
    ///   <item><term>A blueprint instance</term></item>
    ///   <item><term>A blueprint reference</term></item>
    ///   <item><term>A blueprint id as a string, Guid, or BlueprintGuid</term></item>
    ///   <item><term>A blueprint name registered with <see cref="BlueprintCore.Utils.BlueprintTool">BlueprintTool</see></term></item>
    /// </list>
    /// See <see cref="BlueprintCore.Utils.Blueprint{{T, TRef}}">Blueprint</see> for more details.
    /// </para>
    /// </param>
    public TBuilder AddAbilityMythicParams(
        List<Blueprint<BlueprintAbility, BlueprintAbilityReference>>? abilites = null)
    {
      var component = new AbilityMythicParams();
      component.m_Abilites = abilites?.Select(bp => bp.Reference)?.ToArray() ?? component.m_Abilites;
      if (component.m_Abilites is null)
      {
        component.m_Abilites = new BlueprintAbilityReference[0];
      }
      return AddComponent(component);
    }

    /// <summary>
    /// Adds <see cref="AbilityScoreCheckBonus"/>
    /// </summary>
    ///
    /// <remarks>
    ///
    /// <para>
    /// ComponentName: Skill Dice Reroll
    /// </para>
    ///
    /// <list type="bullet">
    /// <listheader>Used by</listheader>
    /// <item><term>AnimalDomainBaseFeature</term><description>d577aba79b5727a4ab74627c4c6ba23c</description></item>
    /// <item><term>ShiningLightBuff</term><description>5d40bdfc6ae8bf24eab446c797599bd6</description></item>
    /// <item><term>StrengthDomainBaseBuff</term><description>94dfcf5f3a72ce8478c8de5db69e752b</description></item>
    /// </list>
    /// </remarks>
    ///
    /// <param name="merge">
    /// If mergeBehavior is ComponentMerge.Merge and the component already exists, this expression is called to merge the components.
    /// </param>
    /// <param name="mergeBehavior">
    /// Handling if the component already exists since the component is unique. Defaults to ComponentMerge.Fail.
    /// </param>
    public TBuilder AddAbilityScoreCheckBonus(
        ContextValue? bonus = null,
        ModifierDescriptor? descriptor = null,
        Action<BlueprintComponent, BlueprintComponent>? merge = null,
        ComponentMerge mergeBehavior = ComponentMerge.Merge,
        StatType? stat = null)
    {
      var component = new AbilityScoreCheckBonus();
      component.Bonus = bonus ?? component.Bonus;
      if (component.Bonus is null)
      {
        component.Bonus = ContextValues.Constant(0);
      }
      component.Descriptor = descriptor ?? component.Descriptor;
      component.Stat = stat ?? component.Stat;
      return AddUniqueComponent(component, mergeBehavior, merge);
    }

    /// <summary>
    /// Adds <see cref="ActionsOnBuffApply"/>
    /// </summary>
    ///
    /// <remarks>
    ///
    /// <para>
    /// ComponentName: Apply fact of event of applying another fact
    /// </para>
    ///
    /// <list type="bullet">
    /// <listheader>Used by</listheader>
    /// <item><term>ArmyBuildingBreweryClericBuff</term><description>ea9d845a8bb84d03b22afdbfa900082d</description></item>
    /// <item><term>ArmyDragon0MoraleBuff</term><description>ce42cf9bf6864410a353bf5802d17f7c</description></item>
    /// <item><term>ArmyMorale20Buff</term><description>66f7b701c57e4deb95266f16541f729e</description></item>
    /// </list>
    /// </remarks>
    ///
    /// <param name="gainedFact">
    /// <para>
    /// Blueprint of type BlueprintUnitFact. You can pass in the blueprint using:
    /// <list type ="bullet">
    ///   <item><term>A blueprint instance</term></item>
    ///   <item><term>A blueprint reference</term></item>
    ///   <item><term>A blueprint id as a string, Guid, or BlueprintGuid</term></item>
    ///   <item><term>A blueprint name registered with <see cref="BlueprintCore.Utils.BlueprintTool">BlueprintTool</see></term></item>
    /// </list>
    /// See <see cref="BlueprintCore.Utils.Blueprint{{T, TRef}}">Blueprint</see> for more details.
    /// </para>
    /// </param>
    public TBuilder AddActionsOnBuffApply(
        ActionsBuilder? actions = null,
        Blueprint<BlueprintUnitFact, BlueprintUnitFactReference>? gainedFact = null)
    {
      var component = new ActionsOnBuffApply();
      component.Actions = actions?.Build() ?? component.Actions;
      if (component.Actions is null)
      {
        component.Actions = Utils.Constants.Empty.Actions;
      }
      component.m_GainedFact = gainedFact?.Reference ?? component.m_GainedFact;
      if (component.m_GainedFact is null)
      {
        component.m_GainedFact = BlueprintTool.GetRef<BlueprintUnitFactReference>(null);
      }
      return AddComponent(component);
    }

    /// <summary>
    /// Adds <see cref="AddAbilityResources"/>
    /// </summary>
    ///
    /// <remarks>
    ///
    /// <para>
    /// ComponentName: Add ability resources
    /// </para>
    ///
    /// <list type="bullet">
    /// <listheader>Used by</listheader>
    /// <item><term>AasimarHaloFeature</term><description>d3f14f00f675a6341a41d2194186835c</description></item>
    /// <item><term>GoodDomainBaseFeature</term><description>f27684b3b72c2f546abf3ef2fb611a05</description></item>
    /// <item><term>WitchWanderingHex</term><description>fb8490d1721bd5a4883c3b6559310351</description></item>
    /// </list>
    /// </remarks>
    ///
    /// <param name="merge">
    /// If mergeBehavior is ComponentMerge.Merge and the component already exists, this expression is called to merge the components.
    /// </param>
    /// <param name="mergeBehavior">
    /// Handling if the component already exists since the component is unique. Defaults to ComponentMerge.Fail.
    /// </param>
    /// <param name="resource">
    /// <para>
    /// Blueprint of type BlueprintAbilityResource. You can pass in the blueprint using:
    /// <list type ="bullet">
    ///   <item><term>A blueprint instance</term></item>
    ///   <item><term>A blueprint reference</term></item>
    ///   <item><term>A blueprint id as a string, Guid, or BlueprintGuid</term></item>
    ///   <item><term>A blueprint name registered with <see cref="BlueprintCore.Utils.BlueprintTool">BlueprintTool</see></term></item>
    /// </list>
    /// See <see cref="BlueprintCore.Utils.Blueprint{{T, TRef}}">Blueprint</see> for more details.
    /// </para>
    /// </param>
    public TBuilder AddAbilityResources(
        int? amount = null,
        Action<BlueprintComponent, BlueprintComponent>? merge = null,
        ComponentMerge mergeBehavior = ComponentMerge.Merge,
        Blueprint<BlueprintAbilityResource, BlueprintAbilityResourceReference>? resource = null,
        bool? restoreAmount = null,
        bool? restoreOnLevelUp = null,
        bool? useThisAsResource = null)
    {
      var component = new AddAbilityResources();
      component.Amount = amount ?? component.Amount;
      component.m_Resource = resource?.Reference ?? component.m_Resource;
      if (component.m_Resource is null)
      {
        component.m_Resource = BlueprintTool.GetRef<BlueprintAbilityResourceReference>(null);
      }
      component.RestoreAmount = restoreAmount ?? component.RestoreAmount;
      component.RestoreOnLevelUp = restoreOnLevelUp ?? component.RestoreOnLevelUp;
      component.UseThisAsResource = useThisAsResource ?? component.UseThisAsResource;
      return AddUniqueComponent(component, mergeBehavior, merge);
    }

    /// <summary>
    /// Adds <see cref="AddBuffOnCombatStart"/>
    /// </summary>
    ///
    /// <remarks>
    ///
    /// <list type="bullet">
    /// <listheader>Used by</listheader>
    /// <item><term>AnomalyTemplateDefensive_ImagesOfChaosBuff</term><description>29894ea708974f13ba02eb90bebfc90b</description></item>
    /// <item><term>ArmyTrickster6EquipmentFeature4</term><description>7970cc7ee3c047c8a2d9ca8f02c88c95</description></item>
    /// <item><term>ZachariusFearAuraFeature</term><description>4427c26e51a3dff4a9ef2ed7541876ee</description></item>
    /// </list>
    /// </remarks>
    ///
    /// <param name="feature">
    /// <para>
    /// Blueprint of type BlueprintBuff. You can pass in the blueprint using:
    /// <list type ="bullet">
    ///   <item><term>A blueprint instance</term></item>
    ///   <item><term>A blueprint reference</term></item>
    ///   <item><term>A blueprint id as a string, Guid, or BlueprintGuid</term></item>
    ///   <item><term>A blueprint name registered with <see cref="BlueprintCore.Utils.BlueprintTool">BlueprintTool</see></term></item>
    /// </list>
    /// See <see cref="BlueprintCore.Utils.Blueprint{{T, TRef}}">Blueprint</see> for more details.
    /// </para>
    /// </param>
    public TBuilder AddBuffOnCombatStart(
        bool? checkParty = null,
        Blueprint<BlueprintBuff, BlueprintBuffReference>? feature = null)
    {
      var component = new AddBuffOnCombatStart();
      component.CheckParty = checkParty ?? component.CheckParty;
      component.m_Feature = feature?.Reference ?? component.m_Feature;
      if (component.m_Feature is null)
      {
        component.m_Feature = BlueprintTool.GetRef<BlueprintBuffReference>(null);
      }
      return AddComponent(component);
    }

    /// <summary>
    /// Adds <see cref="AddCalculatedWeapon"/>
    /// </summary>
    ///
    /// <remarks>
    ///
    /// <para>
    /// ComponentName: Add weapons for show
    /// </para>
    ///
    /// <list type="bullet">
    /// <listheader>Used by</listheader>
    /// <item><term>AlchemistBombsFeature</term><description>c59b2f256f5a70a4d896568658315b7d</description></item>
    /// <item><term>ArcaneBombsElectricityFeature</term><description>2ccffe3c3d16d20438606fc1e3b7c7ca</description></item>
    /// <item><term>TouchCalculateFeature</term><description>62ef1cdb90f1d654d996556669caf7fa</description></item>
    /// </list>
    /// </remarks>
    public TBuilder AddCalculatedWeapon(
        bool? scaleDamageByRank = null,
        CalculatedWeapon? weapon = null)
    {
      var component = new AddCalculatedWeapon();
      component.ScaleDamageByRank = scaleDamageByRank ?? component.ScaleDamageByRank;
      Validate(weapon);
      component.Weapon = weapon ?? component.Weapon;
      return AddComponent(component);
    }

    /// <summary>
    /// Adds <see cref="AddCasterLevel"/>
    /// </summary>
    ///
    /// <remarks>
    ///
    /// <para>
    /// ComponentName: Add caster level
    /// </para>
    ///
    /// <list type="bullet">
    /// <listheader>Used by</listheader>
    /// <item><term>AeonFirstAscentionBuff</term><description>1fd857c252b342e47bf3d805fad0ffc1</description></item>
    /// <item><term>LairDevastator</term><description>8b9a89943f3c1d144b8ce038587d8d79</description></item>
    /// <item><term>Wildhunt_Monarch_CastingLevel</term><description>8a42b2be56d67e4419c828733f1a5b08</description></item>
    /// </list>
    /// </remarks>
    public TBuilder AddCasterLevel(
        int? bonus = null,
        ModifierDescriptor? descriptor = null)
    {
      var component = new AddCasterLevel();
      component.Bonus = bonus ?? component.Bonus;
      component.Descriptor = descriptor ?? component.Descriptor;
      return AddComponent(component);
    }

    /// <summary>
    /// Adds <see cref="AddCasterLevelForAbility"/>
    /// </summary>
    ///
    /// <remarks>
    ///
    /// <para>
    /// ComponentName: FactMechanics/Add caster level for ability
    /// </para>
    ///
    /// <list type="bullet">
    /// <listheader>Used by</listheader>
    /// <item><term>BlackLinnormStewBuffCompanion</term><description>b5ebb94df76531c4ca4f13bfd91efd4e</description></item>
    /// <item><term>PersonalFavoriteEmber</term><description>ea1da890226a90145a55ef3e6e432c83</description></item>
    /// <item><term>ShepherdsPieBuffCompanion</term><description>dc435359dc1711e438048a066eb69443</description></item>
    /// </list>
    /// </remarks>
    ///
    /// <param name="merge">
    /// If mergeBehavior is ComponentMerge.Merge and the component already exists, this expression is called to merge the components.
    /// </param>
    /// <param name="mergeBehavior">
    /// Handling if the component already exists since the component is unique. Defaults to ComponentMerge.Fail.
    /// </param>
    /// <param name="spell">
    /// <para>
    /// Blueprint of type BlueprintAbility. You can pass in the blueprint using:
    /// <list type ="bullet">
    ///   <item><term>A blueprint instance</term></item>
    ///   <item><term>A blueprint reference</term></item>
    ///   <item><term>A blueprint id as a string, Guid, or BlueprintGuid</term></item>
    ///   <item><term>A blueprint name registered with <see cref="BlueprintCore.Utils.BlueprintTool">BlueprintTool</see></term></item>
    /// </list>
    /// See <see cref="BlueprintCore.Utils.Blueprint{{T, TRef}}">Blueprint</see> for more details.
    /// </para>
    /// </param>
    public TBuilder AddCasterLevelForAbility(
        int? bonus = null,
        ModifierDescriptor? descriptor = null,
        Action<BlueprintComponent, BlueprintComponent>? merge = null,
        ComponentMerge mergeBehavior = ComponentMerge.Merge,
        Blueprint<BlueprintAbility, BlueprintAbilityReference>? spell = null)
    {
      var component = new AddCasterLevelForAbility();
      component.Bonus = bonus ?? component.Bonus;
      component.Descriptor = descriptor ?? component.Descriptor;
      component.m_Spell = spell?.Reference ?? component.m_Spell;
      if (component.m_Spell is null)
      {
        component.m_Spell = BlueprintTool.GetRef<BlueprintAbilityReference>(null);
      }
      return AddUniqueComponent(component, mergeBehavior, merge);
    }

    /// <summary>
    /// Adds <see cref="AddCasterLevelForSpellbook"/>
    /// </summary>
    ///
    /// <remarks>
    ///
    /// <para>
    /// ComponentName: Add caster level
    /// </para>
    ///
    /// <list type="bullet">
    /// <listheader>Used by</listheader>
    /// <item><term>ArcanistArcaneReservoirCLBuff</term><description>33e0c3a2a54c0e7489fa4ec4d79a581b</description></item>
    /// <item><term>CR26_BalorMythicBloodrager_RE</term><description>85eba255013867c41a3990c8ef691ab4</description></item>
    /// <item><term>EldritchFontEldritchSurgeCLBuff</term><description>a27a3c5e45f9416428ce983e0d4bd2d2</description></item>
    /// </list>
    /// </remarks>
    ///
    /// <param name="spellbooks">
    /// <para>
    /// Blueprint of type BlueprintSpellbook. You can pass in the blueprint using:
    /// <list type ="bullet">
    ///   <item><term>A blueprint instance</term></item>
    ///   <item><term>A blueprint reference</term></item>
    ///   <item><term>A blueprint id as a string, Guid, or BlueprintGuid</term></item>
    ///   <item><term>A blueprint name registered with <see cref="BlueprintCore.Utils.BlueprintTool">BlueprintTool</see></term></item>
    /// </list>
    /// See <see cref="BlueprintCore.Utils.Blueprint{{T, TRef}}">Blueprint</see> for more details.
    /// </para>
    /// </param>
    public TBuilder AddCasterLevelForSpellbook(
        int? bonus = null,
        ModifierDescriptor? descriptor = null,
        List<Blueprint<BlueprintSpellbook, BlueprintSpellbookReference>>? spellbooks = null)
    {
      var component = new AddCasterLevelForSpellbook();
      component.Bonus = bonus ?? component.Bonus;
      component.Descriptor = descriptor ?? component.Descriptor;
      component.m_Spellbooks = spellbooks?.Select(bp => bp.Reference)?.ToArray() ?? component.m_Spellbooks;
      if (component.m_Spellbooks is null)
      {
        component.m_Spellbooks = new BlueprintSpellbookReference[0];
      }
      return AddComponent(component);
    }

    /// <summary>
    /// Adds <see cref="AddClassLevelToSummonDuration"/>
    /// </summary>
    ///
    /// <remarks>
    ///
    /// <list type="bullet">
    /// <listheader>Used by</listheader>
    /// <item><term>SpecializationSchoolConjuration</term><description>cee0f7edbd874a042952ee150f878b84</description></item>
    /// </list>
    /// </remarks>
    ///
    /// <param name="characterClass">
    /// <para>
    /// Blueprint of type BlueprintCharacterClass. You can pass in the blueprint using:
    /// <list type ="bullet">
    ///   <item><term>A blueprint instance</term></item>
    ///   <item><term>A blueprint reference</term></item>
    ///   <item><term>A blueprint id as a string, Guid, or BlueprintGuid</term></item>
    ///   <item><term>A blueprint name registered with <see cref="BlueprintCore.Utils.BlueprintTool">BlueprintTool</see></term></item>
    /// </list>
    /// See <see cref="BlueprintCore.Utils.Blueprint{{T, TRef}}">Blueprint</see> for more details.
    /// </para>
    /// </param>
    public TBuilder AddClassLevelToSummonDuration(
        Blueprint<BlueprintCharacterClass, BlueprintCharacterClassReference>? characterClass = null,
        bool? half = null)
    {
      var component = new AddClassLevelToSummonDuration();
      component.m_CharacterClass = characterClass?.Reference ?? component.m_CharacterClass;
      if (component.m_CharacterClass is null)
      {
        component.m_CharacterClass = BlueprintTool.GetRef<BlueprintCharacterClassReference>(null);
      }
      component.Half = half ?? component.Half;
      return AddComponent(component);
    }

    /// <summary>
    /// Adds <see cref="AddFeatureIfHasFact"/>
    /// </summary>
    ///
    /// <remarks>
    ///
    /// <list type="bullet">
    /// <listheader>Used by</listheader>
    /// <item><term>AcerbicRingFeature</term><description>094b291d04fdde84b963b07400c0df80</description></item>
    /// <item><term>DragonDiscipleFormFeatureWings</term><description>aa36f82ab9a046c4a853dccf0cdbaf53</description></item>
    /// <item><term>ZenArcherReflexiveShotFeature</term><description>e6a3ade07ee84144a90203f5699c07ef</description></item>
    /// </list>
    /// </remarks>
    ///
    /// <param name="checkedFact">
    /// <para>
    /// Blueprint of type BlueprintUnitFact. You can pass in the blueprint using:
    /// <list type ="bullet">
    ///   <item><term>A blueprint instance</term></item>
    ///   <item><term>A blueprint reference</term></item>
    ///   <item><term>A blueprint id as a string, Guid, or BlueprintGuid</term></item>
    ///   <item><term>A blueprint name registered with <see cref="BlueprintCore.Utils.BlueprintTool">BlueprintTool</see></term></item>
    /// </list>
    /// See <see cref="BlueprintCore.Utils.Blueprint{{T, TRef}}">Blueprint</see> for more details.
    /// </para>
    /// </param>
    /// <param name="feature">
    /// <para>
    /// Blueprint of type BlueprintUnitFact. You can pass in the blueprint using:
    /// <list type ="bullet">
    ///   <item><term>A blueprint instance</term></item>
    ///   <item><term>A blueprint reference</term></item>
    ///   <item><term>A blueprint id as a string, Guid, or BlueprintGuid</term></item>
    ///   <item><term>A blueprint name registered with <see cref="BlueprintCore.Utils.BlueprintTool">BlueprintTool</see></term></item>
    /// </list>
    /// See <see cref="BlueprintCore.Utils.Blueprint{{T, TRef}}">Blueprint</see> for more details.
    /// </para>
    /// </param>
    /// <param name="merge">
    /// If mergeBehavior is ComponentMerge.Merge and the component already exists, this expression is called to merge the components.
    /// </param>
    /// <param name="mergeBehavior">
    /// Handling if the component already exists since the component is unique. Defaults to ComponentMerge.Fail.
    /// </param>
    public TBuilder AddFeatureIfHasFact(
        Blueprint<BlueprintUnitFact, BlueprintUnitFactReference>? checkedFact = null,
        Blueprint<BlueprintUnitFact, BlueprintUnitFactReference>? feature = null,
        Action<BlueprintComponent, BlueprintComponent>? merge = null,
        ComponentMerge mergeBehavior = ComponentMerge.Merge,
        bool? not = null)
    {
      var component = new AddFeatureIfHasFact();
      component.m_CheckedFact = checkedFact?.Reference ?? component.m_CheckedFact;
      if (component.m_CheckedFact is null)
      {
        component.m_CheckedFact = BlueprintTool.GetRef<BlueprintUnitFactReference>(null);
      }
      component.m_Feature = feature?.Reference ?? component.m_Feature;
      if (component.m_Feature is null)
      {
        component.m_Feature = BlueprintTool.GetRef<BlueprintUnitFactReference>(null);
      }
      component.Not = not ?? component.Not;
      return AddUniqueComponent(component, mergeBehavior, merge);
    }

    /// <summary>
    /// Adds <see cref="AddFeatureOnAlignment"/>
    /// </summary>
    ///
    /// <remarks>
    ///
    /// <para>
    /// ComponentName: Add feature on class level
    /// </para>
    ///
    /// <list type="bullet">
    /// <listheader>Used by</listheader>
    /// <item><term>CavalierByMyHonorChaoticFortitude</term><description>95047ce9afcad7748a4655a446986b8f</description></item>
    /// <item><term>CavalierByMyHonorLawReflex</term><description>22daa326ce6074f4e9245d8c73039cf1</description></item>
    /// <item><term>TacticalLeaderBattleAcumenFeature</term><description>959a8bdc83b0a3948a3902f9882c522a</description></item>
    /// </list>
    /// </remarks>
    ///
    /// <param name="facts">
    /// <para>
    /// Blueprint of type BlueprintUnitFact. You can pass in the blueprint using:
    /// <list type ="bullet">
    ///   <item><term>A blueprint instance</term></item>
    ///   <item><term>A blueprint reference</term></item>
    ///   <item><term>A blueprint id as a string, Guid, or BlueprintGuid</term></item>
    ///   <item><term>A blueprint name registered with <see cref="BlueprintCore.Utils.BlueprintTool">BlueprintTool</see></term></item>
    /// </list>
    /// See <see cref="BlueprintCore.Utils.Blueprint{{T, TRef}}">Blueprint</see> for more details.
    /// </para>
    /// </param>
    /// <param name="merge">
    /// If mergeBehavior is ComponentMerge.Merge and the component already exists, this expression is called to merge the components.
    /// </param>
    /// <param name="mergeBehavior">
    /// Handling if the component already exists since the component is unique. Defaults to ComponentMerge.Fail.
    /// </param>
    public TBuilder AddFeatureOnAlignment(
        AlignmentComponent? alignment = null,
        List<Blueprint<BlueprintUnitFact, BlueprintUnitFactReference>>? facts = null,
        Action<BlueprintComponent, BlueprintComponent>? merge = null,
        ComponentMerge mergeBehavior = ComponentMerge.Merge)
    {
      var component = new AddFeatureOnAlignment();
      component.Alignment = alignment ?? component.Alignment;
      component.m_Facts = facts?.Select(bp => bp.Reference)?.ToArray() ?? component.m_Facts;
      if (component.m_Facts is null)
      {
        component.m_Facts = new BlueprintUnitFactReference[0];
      }
      return AddUniqueComponent(component, mergeBehavior, merge);
    }

    /// <summary>
    /// Adds <see cref="AddFeatureOnApply"/>
    /// </summary>
    ///
    /// <remarks>
    ///
    /// <list type="bullet">
    /// <listheader>Used by</listheader>
    /// <item><term>AnimalCompanionSelectionBase</term><description>90406c575576aee40a34917a1b429254</description></item>
    /// <item><term>TricksterLoreReligionAnimalDomainFeature</term><description>8c67207f838b43df9f2050de4ca035dd</description></item>
    /// <item><term>TricksterLoreReligionWeatherDomainFeature</term><description>41947e0523ff4eae8236729551a40605</description></item>
    /// </list>
    /// </remarks>
    ///
    /// <param name="feature">
    /// <para>
    /// Blueprint of type BlueprintFeature. You can pass in the blueprint using:
    /// <list type ="bullet">
    ///   <item><term>A blueprint instance</term></item>
    ///   <item><term>A blueprint reference</term></item>
    ///   <item><term>A blueprint id as a string, Guid, or BlueprintGuid</term></item>
    ///   <item><term>A blueprint name registered with <see cref="BlueprintCore.Utils.BlueprintTool">BlueprintTool</see></term></item>
    /// </list>
    /// See <see cref="BlueprintCore.Utils.Blueprint{{T, TRef}}">Blueprint</see> for more details.
    /// </para>
    /// </param>
    /// <param name="merge">
    /// If mergeBehavior is ComponentMerge.Merge and the component already exists, this expression is called to merge the components.
    /// </param>
    /// <param name="mergeBehavior">
    /// Handling if the component already exists since the component is unique. Defaults to ComponentMerge.Fail.
    /// </param>
    public TBuilder AddFeatureOnApply(
        Blueprint<BlueprintFeature, BlueprintFeatureReference>? feature = null,
        Action<BlueprintComponent, BlueprintComponent>? merge = null,
        ComponentMerge mergeBehavior = ComponentMerge.Merge)
    {
      var component = new AddFeatureOnApply();
      component.m_Feature = feature?.Reference ?? component.m_Feature;
      if (component.m_Feature is null)
      {
        component.m_Feature = BlueprintTool.GetRef<BlueprintFeatureReference>(null);
      }
      return AddUniqueComponent(component, mergeBehavior, merge);
    }

    /// <summary>
    /// Adds <see cref="AddFeatureOnClassLevel"/>
    /// </summary>
    ///
    /// <remarks>
    ///
    /// <para>
    /// ComponentName: Add feature on class level
    /// </para>
    ///
    /// <list type="bullet">
    /// <listheader>Used by</listheader>
    /// <item><term>AeonSummonFeatureTier3</term><description>6c999087fd82ca9499cee45f107e9831</description></item>
    /// <item><term>EnlightenedPhilosopherBonesMysteryFeature</term><description>511ee1f805f8d1445b64f4c8398ca938</description></item>
    /// <item><term>ZonKuthonFeature</term><description>f7eed400baa66a744ad361d4df0e6f1b</description></item>
    /// </list>
    /// </remarks>
    ///
    /// <param name="additionalClasses">
    /// <para>
    /// Blueprint of type BlueprintCharacterClass. You can pass in the blueprint using:
    /// <list type ="bullet">
    ///   <item><term>A blueprint instance</term></item>
    ///   <item><term>A blueprint reference</term></item>
    ///   <item><term>A blueprint id as a string, Guid, or BlueprintGuid</term></item>
    ///   <item><term>A blueprint name registered with <see cref="BlueprintCore.Utils.BlueprintTool">BlueprintTool</see></term></item>
    /// </list>
    /// See <see cref="BlueprintCore.Utils.Blueprint{{T, TRef}}">Blueprint</see> for more details.
    /// </para>
    /// </param>
    /// <param name="archetypes">
    /// <para>
    /// Blueprint of type BlueprintArchetype. You can pass in the blueprint using:
    /// <list type ="bullet">
    ///   <item><term>A blueprint instance</term></item>
    ///   <item><term>A blueprint reference</term></item>
    ///   <item><term>A blueprint id as a string, Guid, or BlueprintGuid</term></item>
    ///   <item><term>A blueprint name registered with <see cref="BlueprintCore.Utils.BlueprintTool">BlueprintTool</see></term></item>
    /// </list>
    /// See <see cref="BlueprintCore.Utils.Blueprint{{T, TRef}}">Blueprint</see> for more details.
    /// </para>
    /// </param>
    /// <param name="clazz">
    /// <para>
    /// Blueprint of type BlueprintCharacterClass. You can pass in the blueprint using:
    /// <list type ="bullet">
    ///   <item><term>A blueprint instance</term></item>
    ///   <item><term>A blueprint reference</term></item>
    ///   <item><term>A blueprint id as a string, Guid, or BlueprintGuid</term></item>
    ///   <item><term>A blueprint name registered with <see cref="BlueprintCore.Utils.BlueprintTool">BlueprintTool</see></term></item>
    /// </list>
    /// See <see cref="BlueprintCore.Utils.Blueprint{{T, TRef}}">Blueprint</see> for more details.
    /// </para>
    /// </param>
    /// <param name="feature">
    /// <para>
    /// Blueprint of type BlueprintFeature. You can pass in the blueprint using:
    /// <list type ="bullet">
    ///   <item><term>A blueprint instance</term></item>
    ///   <item><term>A blueprint reference</term></item>
    ///   <item><term>A blueprint id as a string, Guid, or BlueprintGuid</term></item>
    ///   <item><term>A blueprint name registered with <see cref="BlueprintCore.Utils.BlueprintTool">BlueprintTool</see></term></item>
    /// </list>
    /// See <see cref="BlueprintCore.Utils.Blueprint{{T, TRef}}">Blueprint</see> for more details.
    /// </para>
    /// </param>
    /// <param name="merge">
    /// If mergeBehavior is ComponentMerge.Merge and the component already exists, this expression is called to merge the components.
    /// </param>
    /// <param name="mergeBehavior">
    /// Handling if the component already exists since the component is unique. Defaults to ComponentMerge.Fail.
    /// </param>
    public TBuilder AddFeatureOnClassLevel(
        List<Blueprint<BlueprintCharacterClass, BlueprintCharacterClassReference>>? additionalClasses = null,
        List<Blueprint<BlueprintArchetype, BlueprintArchetypeReference>>? archetypes = null,
        bool? beforeThisLevel = null,
        Blueprint<BlueprintCharacterClass, BlueprintCharacterClassReference>? clazz = null,
        Blueprint<BlueprintFeature, BlueprintFeatureReference>? feature = null,
        int? level = null,
        Action<BlueprintComponent, BlueprintComponent>? merge = null,
        ComponentMerge mergeBehavior = ComponentMerge.Merge)
    {
      var component = new AddFeatureOnClassLevel();
      component.m_AdditionalClasses = additionalClasses?.Select(bp => bp.Reference)?.ToArray() ?? component.m_AdditionalClasses;
      if (component.m_AdditionalClasses is null)
      {
        component.m_AdditionalClasses = new BlueprintCharacterClassReference[0];
      }
      component.m_Archetypes = archetypes?.Select(bp => bp.Reference)?.ToArray() ?? component.m_Archetypes;
      if (component.m_Archetypes is null)
      {
        component.m_Archetypes = new BlueprintArchetypeReference[0];
      }
      component.BeforeThisLevel = beforeThisLevel ?? component.BeforeThisLevel;
      component.m_Class = clazz?.Reference ?? component.m_Class;
      if (component.m_Class is null)
      {
        component.m_Class = BlueprintTool.GetRef<BlueprintCharacterClassReference>(null);
      }
      component.m_Feature = feature?.Reference ?? component.m_Feature;
      if (component.m_Feature is null)
      {
        component.m_Feature = BlueprintTool.GetRef<BlueprintFeatureReference>(null);
      }
      component.Level = level ?? component.Level;
      return AddUniqueComponent(component, mergeBehavior, merge);
    }

    /// <summary>
    /// Adds <see cref="AddFeatureOnSkill"/>
    /// </summary>
    ///
    /// <remarks>
    ///
    /// <list type="bullet">
    /// <listheader>Used by</listheader>
    /// <item><term>KitsuneHeritageClassic</term><description>cd6cd774fb7cc844b8417193ee3a5ebe</description></item>
    /// <item><term>KitsuneHeritageKeen</term><description>d6bc49651fbaa2944bba6e2e5a1720ff</description></item>
    /// </list>
    /// </remarks>
    ///
    /// <param name="facts">
    /// <para>
    /// Blueprint of type BlueprintUnitFact. You can pass in the blueprint using:
    /// <list type ="bullet">
    ///   <item><term>A blueprint instance</term></item>
    ///   <item><term>A blueprint reference</term></item>
    ///   <item><term>A blueprint id as a string, Guid, or BlueprintGuid</term></item>
    ///   <item><term>A blueprint name registered with <see cref="BlueprintCore.Utils.BlueprintTool">BlueprintTool</see></term></item>
    /// </list>
    /// See <see cref="BlueprintCore.Utils.Blueprint{{T, TRef}}">Blueprint</see> for more details.
    /// </para>
    /// </param>
    /// <param name="merge">
    /// If mergeBehavior is ComponentMerge.Merge and the component already exists, this expression is called to merge the components.
    /// </param>
    /// <param name="mergeBehavior">
    /// Handling if the component already exists since the component is unique. Defaults to ComponentMerge.Fail.
    /// </param>
    public TBuilder AddFeatureOnSkill(
        List<Blueprint<BlueprintUnitFact, BlueprintUnitFactReference>>? facts = null,
        Action<BlueprintComponent, BlueprintComponent>? merge = null,
        ComponentMerge mergeBehavior = ComponentMerge.Merge,
        int? minimalStat = null,
        StatType? statType = null)
    {
      var component = new AddFeatureOnSkill();
      component.m_Facts = facts?.Select(bp => bp.Reference)?.ToArray() ?? component.m_Facts;
      if (component.m_Facts is null)
      {
        component.m_Facts = new BlueprintUnitFactReference[0];
      }
      component.MinimalStat = minimalStat ?? component.MinimalStat;
      component.StatType = statType ?? component.StatType;
      return AddUniqueComponent(component, mergeBehavior, merge);
    }

    /// <summary>
    /// Adds <see cref="AddFeatureToNPC"/>
    /// </summary>
    ///
    /// <remarks>
    ///
    /// <list type="bullet">
    /// <listheader>Used by</listheader>
    /// <item><term>DifficultyAdvancementBaseFeature</term><description>33bc1b86b3a2fa5489cc0a5bdcf3f6f8</description></item>
    /// <item><term>ImpatienceBaseFeature</term><description>109f01a0cbd151d44a98b17056460bc9</description></item>
    /// </list>
    /// </remarks>
    ///
    /// <param name="feature">
    /// <para>
    /// Blueprint of type BlueprintFeature. You can pass in the blueprint using:
    /// <list type ="bullet">
    ///   <item><term>A blueprint instance</term></item>
    ///   <item><term>A blueprint reference</term></item>
    ///   <item><term>A blueprint id as a string, Guid, or BlueprintGuid</term></item>
    ///   <item><term>A blueprint name registered with <see cref="BlueprintCore.Utils.BlueprintTool">BlueprintTool</see></term></item>
    /// </list>
    /// See <see cref="BlueprintCore.Utils.Blueprint{{T, TRef}}">Blueprint</see> for more details.
    /// </para>
    /// </param>
    public TBuilder AddFeatureToNPC(
        bool? checkParty = null,
        bool? checkSummoned = null,
        Blueprint<BlueprintFeature, BlueprintFeatureReference>? feature = null)
    {
      var component = new AddFeatureToNPC();
      component.CheckParty = checkParty ?? component.CheckParty;
      component.CheckSummoned = checkSummoned ?? component.CheckSummoned;
      component.m_Feature = feature?.Reference ?? component.m_Feature;
      if (component.m_Feature is null)
      {
        component.m_Feature = BlueprintTool.GetRef<BlueprintFeatureReference>(null);
      }
      return AddComponent(component);
    }

    /// <summary>
    /// Adds <see cref="AddFeatureToPet"/>
    /// </summary>
    ///
    /// <remarks>
    ///
    /// <para>
    /// ComponentName: Add feature to companion
    /// </para>
    ///
    /// <list type="bullet">
    /// <listheader>Used by</listheader>
    /// <item><term>AnimalCompanionArchetypeBaseFeature</term><description>e7d53709a33bd9b45a89536ed6766264</description></item>
    /// <item><term>EkunWolfDefensiveMaster</term><description>915616ab61446694dbd73c7d269ea184</description></item>
    /// <item><term>UndeadMountFeature</term><description>a46d64cfd32fc3749a5897657247a680</description></item>
    /// </list>
    /// </remarks>
    ///
    /// <param name="feature">
    /// <para>
    /// Blueprint of type BlueprintFeature. You can pass in the blueprint using:
    /// <list type ="bullet">
    ///   <item><term>A blueprint instance</term></item>
    ///   <item><term>A blueprint reference</term></item>
    ///   <item><term>A blueprint id as a string, Guid, or BlueprintGuid</term></item>
    ///   <item><term>A blueprint name registered with <see cref="BlueprintCore.Utils.BlueprintTool">BlueprintTool</see></term></item>
    /// </list>
    /// See <see cref="BlueprintCore.Utils.Blueprint{{T, TRef}}">Blueprint</see> for more details.
    /// </para>
    /// </param>
    /// <param name="merge">
    /// If mergeBehavior is ComponentMerge.Merge and the component already exists, this expression is called to merge the components.
    /// </param>
    /// <param name="mergeBehavior">
    /// Handling if the component already exists since the component is unique. Defaults to ComponentMerge.Fail.
    /// </param>
    public TBuilder AddFeatureToPet(
        Blueprint<BlueprintFeature, BlueprintFeatureReference>? feature = null,
        Action<BlueprintComponent, BlueprintComponent>? merge = null,
        ComponentMerge mergeBehavior = ComponentMerge.Merge,
        PetType? petType = null)
    {
      var component = new AddFeatureToPet();
      component.m_Feature = feature?.Reference ?? component.m_Feature;
      if (component.m_Feature is null)
      {
        component.m_Feature = BlueprintTool.GetRef<BlueprintFeatureReference>(null);
      }
      component.m_PetType = petType ?? component.m_PetType;
      return AddUniqueComponent(component, mergeBehavior, merge);
    }

    /// <summary>
    /// Adds <see cref="AddSpellListAsAbilities"/>
    /// </summary>
    ///
    /// <remarks>
    ///
    /// <list type="bullet">
    /// <listheader>Used by</listheader>
    /// <item><term>TricksterLoreReligionTier2Parametrized</term><description>3e006bc9bbf0b884a8d8853350bee846</description></item>
    /// <item><term>TricksterLoreReligionTier3Parametrized</term><description>0466cdfa56f943608760952a6bf2a6fa</description></item>
    /// </list>
    /// </remarks>
    ///
    /// <param name="merge">
    /// If mergeBehavior is ComponentMerge.Merge and the component already exists, this expression is called to merge the components.
    /// </param>
    /// <param name="mergeBehavior">
    /// Handling if the component already exists since the component is unique. Defaults to ComponentMerge.Fail.
    /// </param>
    /// <param name="resourcePerSpellLevel">
    /// <para>
    /// InfoBox: NOTE: Spell levels starts from 0!
    /// </para>
    /// <para>
    /// Blueprint of type BlueprintAbilityResource. You can pass in the blueprint using:
    /// <list type ="bullet">
    ///   <item><term>A blueprint instance</term></item>
    ///   <item><term>A blueprint reference</term></item>
    ///   <item><term>A blueprint id as a string, Guid, or BlueprintGuid</term></item>
    ///   <item><term>A blueprint name registered with <see cref="BlueprintCore.Utils.BlueprintTool">BlueprintTool</see></term></item>
    /// </list>
    /// See <see cref="BlueprintCore.Utils.Blueprint{{T, TRef}}">Blueprint</see> for more details.
    /// </para>
    /// </param>
    public TBuilder AddSpellListAsAbilities(
        Action<BlueprintComponent, BlueprintComponent>? merge = null,
        ComponentMerge mergeBehavior = ComponentMerge.Merge,
        List<Blueprint<BlueprintAbilityResource, BlueprintAbilityResourceReference>>? resourcePerSpellLevel = null,
        bool? searchInAddFeatureComponents = null)
    {
      var component = new AddSpellListAsAbilities();
      component.m_ResourcePerSpellLevel = resourcePerSpellLevel?.Select(bp => bp.Reference)?.ToArray() ?? component.m_ResourcePerSpellLevel;
      if (component.m_ResourcePerSpellLevel is null)
      {
        component.m_ResourcePerSpellLevel = new BlueprintAbilityResourceReference[0];
      }
      component.m_SearchInAddFeatureComponents = searchInAddFeatureComponents ?? component.m_SearchInAddFeatureComponents;
      return AddUniqueComponent(component, mergeBehavior, merge);
    }

    /// <summary>
    /// Adds <see cref="AddSpellbook"/>
    /// </summary>
    ///
    /// <remarks>
    ///
    /// <list type="bullet">
    /// <listheader>Used by</listheader>
    /// <item><term>TricksterUseMagicDeviceTier3Feature</term><description>9d1446e4947544429a64e5fa20906ebf</description></item>
    /// </list>
    /// </remarks>
    ///
    /// <param name="spellbook">
    /// <para>
    /// Blueprint of type BlueprintSpellbook. You can pass in the blueprint using:
    /// <list type ="bullet">
    ///   <item><term>A blueprint instance</term></item>
    ///   <item><term>A blueprint reference</term></item>
    ///   <item><term>A blueprint id as a string, Guid, or BlueprintGuid</term></item>
    ///   <item><term>A blueprint name registered with <see cref="BlueprintCore.Utils.BlueprintTool">BlueprintTool</see></term></item>
    /// </list>
    /// See <see cref="BlueprintCore.Utils.Blueprint{{T, TRef}}">Blueprint</see> for more details.
    /// </para>
    /// </param>
    public TBuilder AddSpellbook(
        ContextValue? casterLevel = null,
        Blueprint<BlueprintSpellbook, BlueprintSpellbookReference>? spellbook = null)
    {
      var component = new AddSpellbook();
      component.m_CasterLevel = casterLevel ?? component.m_CasterLevel;
      if (component.m_CasterLevel is null)
      {
        component.m_CasterLevel = ContextValues.Constant(0);
      }
      component.m_Spellbook = spellbook?.Reference ?? component.m_Spellbook;
      if (component.m_Spellbook is null)
      {
        component.m_Spellbook = BlueprintTool.GetRef<BlueprintSpellbookReference>(null);
      }
      return AddComponent(component);
    }

    /// <summary>
    /// Adds <see cref="AddWearinessHours"/>
    /// </summary>
    ///
    /// <remarks>
    ///
    /// <para>
    /// ComponentName: Add weariness hours
    /// </para>
    ///
    /// <list type="bullet">
    /// <listheader>Used by</listheader>
    /// <item><term>CheeseCrostataBuff</term><description>528c368579a414147a0584f608aa8079</description></item>
    /// <item><term>FishOnStickBuff</term><description>2c682648f065e6a4facb8c351e55cde3</description></item>
    /// <item><term>GearsRuleFeature</term><description>88acea521a38dfe4ab9be550a4d8c596</description></item>
    /// </list>
    /// </remarks>
    public TBuilder AddWearinessHours(
        int? hours = null)
    {
      var component = new AddWearinessHours();
      component.Hours = hours ?? component.Hours;
      return AddComponent(component);
    }

    /// <summary>
    /// Adds <see cref="AdditionalDamageOnHit"/>
    /// </summary>
    ///
    /// <remarks>
    ///
    /// <para>
    /// ComponentName: Additional energy damage on hit with a weapon
    /// </para>
    ///
    /// <list type="bullet">
    /// <listheader>Used by</listheader>
    /// <item><term>FighterElementalWeaponBuff</term><description>4bbff3a1c8894a46be2515029ea044b0</description></item>
    /// <item><term>MonarchsGlaiveFeature</term><description>46d82a93335e59648a85b61950eea91e</description></item>
    /// <item><term>ScaledFistDraconicFuryFireBuff</term><description>138d83559ad70f947b7f3c1d385be0c7</description></item>
    /// </list>
    /// </remarks>
    ///
    /// <param name="weapon">
    /// <para>
    /// Blueprint of type BlueprintItemWeapon. You can pass in the blueprint using:
    /// <list type ="bullet">
    ///   <item><term>A blueprint instance</term></item>
    ///   <item><term>A blueprint reference</term></item>
    ///   <item><term>A blueprint id as a string, Guid, or BlueprintGuid</term></item>
    ///   <item><term>A blueprint name registered with <see cref="BlueprintCore.Utils.BlueprintTool">BlueprintTool</see></term></item>
    /// </list>
    /// See <see cref="BlueprintCore.Utils.Blueprint{{T, TRef}}">Blueprint</see> for more details.
    /// </para>
    /// </param>
    public TBuilder AdditionalDamageOnHit(
        DamageEnergyType? element = null,
        DiceFormula? energyDamageDice = null,
        bool? onlyMelee = null,
        bool? onlyNaturalAndUnarmed = null,
        bool? specificWeapon = null,
        Blueprint<BlueprintItemWeapon, BlueprintItemWeaponReference>? weapon = null)
    {
      var component = new AdditionalDamageOnHit();
      component.Element = element ?? component.Element;
      component.EnergyDamageDice = energyDamageDice ?? component.EnergyDamageDice;
      component.OnlyMelee = onlyMelee ?? component.OnlyMelee;
      component.OnlyNaturalAndUnarmed = onlyNaturalAndUnarmed ?? component.OnlyNaturalAndUnarmed;
      component.SpecificWeapon = specificWeapon ?? component.SpecificWeapon;
      component.m_Weapon = weapon?.Reference ?? component.m_Weapon;
      if (component.m_Weapon is null)
      {
        component.m_Weapon = BlueprintTool.GetRef<BlueprintItemWeaponReference>(null);
      }
      return AddComponent(component);
    }

    /// <summary>
    /// Adds <see cref="AdditionalSneakDamageOnHit"/>
    /// </summary>
    ///
    /// <remarks>
    ///
    /// <list type="bullet">
    /// <listheader>Used by</listheader>
    /// <item><term>NecklaceOfDoubleCorssesFeature</term><description>64d5a59feeb292e49a6c459fe37c3953</description></item>
    /// </list>
    /// </remarks>
    public TBuilder AdditionalSneakDamageOnHit(
        bool? onlyNoDexToAC = null,
        DiceFormula? physicalDamageDice = null,
        AdditionalSneakDamageOnHit.WeaponType? weapon = null)
    {
      var component = new AdditionalSneakDamageOnHit();
      component.OnlyNoDexToAC = onlyNoDexToAC ?? component.OnlyNoDexToAC;
      component.PhysicalDamageDice = physicalDamageDice ?? component.PhysicalDamageDice;
      component.m_Weapon = weapon ?? component.m_Weapon;
      return AddComponent(component);
    }

    /// <summary>
    /// Adds <see cref="AlliedSpellcaster"/>
    /// </summary>
    ///
    /// <remarks>
    ///
    /// <list type="bullet">
    /// <listheader>Used by</listheader>
    /// <item><term>AlliedSpellcaster</term><description>9093ceeefe9b84746a5993d619d7c86f</description></item>
    /// </list>
    /// </remarks>
    ///
    /// <param name="alliedSpellcasterFact">
    /// <para>
    /// Blueprint of type BlueprintUnitFact. You can pass in the blueprint using:
    /// <list type ="bullet">
    ///   <item><term>A blueprint instance</term></item>
    ///   <item><term>A blueprint reference</term></item>
    ///   <item><term>A blueprint id as a string, Guid, or BlueprintGuid</term></item>
    ///   <item><term>A blueprint name registered with <see cref="BlueprintCore.Utils.BlueprintTool">BlueprintTool</see></term></item>
    /// </list>
    /// See <see cref="BlueprintCore.Utils.Blueprint{{T, TRef}}">Blueprint</see> for more details.
    /// </para>
    /// </param>
    /// <param name="merge">
    /// If mergeBehavior is ComponentMerge.Merge and the component already exists, this expression is called to merge the components.
    /// </param>
    /// <param name="mergeBehavior">
    /// Handling if the component already exists since the component is unique. Defaults to ComponentMerge.Fail.
    /// </param>
    public TBuilder AddAlliedSpellcaster(
        Blueprint<BlueprintUnitFact, BlueprintUnitFactReference>? alliedSpellcasterFact = null,
        Action<BlueprintComponent, BlueprintComponent>? merge = null,
        ComponentMerge mergeBehavior = ComponentMerge.Merge,
        int? radius = null)
    {
      var component = new AlliedSpellcaster();
      component.m_AlliedSpellcasterFact = alliedSpellcasterFact?.Reference ?? component.m_AlliedSpellcasterFact;
      if (component.m_AlliedSpellcasterFact is null)
      {
        component.m_AlliedSpellcasterFact = BlueprintTool.GetRef<BlueprintUnitFactReference>(null);
      }
      component.Radius = radius ?? component.Radius;
      return AddUniqueComponent(component, mergeBehavior, merge);
    }

    /// <summary>
    /// Adds <see cref="AngelSwordAdditionalDamageAndHeal"/>
    /// </summary>
    ///
    /// <remarks>
    ///
    /// <list type="bullet">
    /// <listheader>Used by</listheader>
    /// <item><term>AngelSwordEffectBuff</term><description>f5f500d6a2a39fc4181af32ad79af488</description></item>
    /// <item><term>AngelSwordEffectBuffNonUnique</term><description>a422afd38359e6a40b71dd41ada6b334</description></item>
    /// </list>
    /// </remarks>
    ///
    /// <param name="cloakFact">
    /// <para>
    /// InfoBox: Changes how this mechanics works if player has Mythic Cloak
    /// </para>
    /// <para>
    /// Blueprint of type BlueprintUnitFact. You can pass in the blueprint using:
    /// <list type ="bullet">
    ///   <item><term>A blueprint instance</term></item>
    ///   <item><term>A blueprint reference</term></item>
    ///   <item><term>A blueprint id as a string, Guid, or BlueprintGuid</term></item>
    ///   <item><term>A blueprint name registered with <see cref="BlueprintCore.Utils.BlueprintTool">BlueprintTool</see></term></item>
    /// </list>
    /// See <see cref="BlueprintCore.Utils.Blueprint{{T, TRef}}">Blueprint</see> for more details.
    /// </para>
    /// </param>
    /// <param name="maximizeFact">
    /// <para>
    /// Blueprint of type BlueprintUnitFact. You can pass in the blueprint using:
    /// <list type ="bullet">
    ///   <item><term>A blueprint instance</term></item>
    ///   <item><term>A blueprint reference</term></item>
    ///   <item><term>A blueprint id as a string, Guid, or BlueprintGuid</term></item>
    ///   <item><term>A blueprint name registered with <see cref="BlueprintCore.Utils.BlueprintTool">BlueprintTool</see></term></item>
    /// </list>
    /// See <see cref="BlueprintCore.Utils.Blueprint{{T, TRef}}">Blueprint</see> for more details.
    /// </para>
    /// </param>
    public TBuilder AddAngelSwordAdditionalDamageAndHeal(
        Blueprint<BlueprintUnitFact, BlueprintUnitFactReference>? cloakFact = null,
        PrefabLink? damagePrefab = null,
        PrefabLink? healingPrefab = null,
        Blueprint<BlueprintUnitFact, BlueprintUnitFactReference>? maximizeFact = null)
    {
      var component = new AngelSwordAdditionalDamageAndHeal();
      component.m_CloakFact = cloakFact?.Reference ?? component.m_CloakFact;
      if (component.m_CloakFact is null)
      {
        component.m_CloakFact = BlueprintTool.GetRef<BlueprintUnitFactReference>(null);
      }
      component.DamagePrefab = damagePrefab ?? component.DamagePrefab;
      if (component.DamagePrefab is null)
      {
        component.DamagePrefab = Utils.Constants.Empty.PrefabLink;
      }
      component.HealingPrefab = healingPrefab ?? component.HealingPrefab;
      if (component.HealingPrefab is null)
      {
        component.HealingPrefab = Utils.Constants.Empty.PrefabLink;
      }
      component.m_MaximizeFact = maximizeFact?.Reference ?? component.m_MaximizeFact;
      if (component.m_MaximizeFact is null)
      {
        component.m_MaximizeFact = BlueprintTool.GetRef<BlueprintUnitFactReference>(null);
      }
      return AddComponent(component);
    }

    /// <summary>
    /// Adds <see cref="AngelSwordAntiDescriptor"/>
    /// </summary>
    ///
    /// <remarks>
    ///
    /// <list type="bullet">
    /// <listheader>Used by</listheader>
    /// <item><term>AngelSwordAntiCompulsionBuff</term><description>5d679978972e8d644a2204ac8aaeba05</description></item>
    /// <item><term>AngelSwordAntiPoisonBuff</term><description>6090c5c388b67404fbf172e6f77ebfa0</description></item>
    /// <item><term>AngelSwordAntiUndeadBuff</term><description>efadad11136c7bb418d060a1a231327d</description></item>
    /// </list>
    /// </remarks>
    ///
    /// <param name="merge">
    /// If mergeBehavior is ComponentMerge.Merge and the component already exists, this expression is called to merge the components.
    /// </param>
    /// <param name="mergeBehavior">
    /// Handling if the component already exists since the component is unique. Defaults to ComponentMerge.Fail.
    /// </param>
    public TBuilder AddAngelSwordAntiDescriptor(
        SpellDescriptorWrapper? checkedDescriptor = null,
        bool? healEnergyDrain = null,
        bool? healStatDamageAndDrain = null,
        Action<BlueprintComponent, BlueprintComponent>? merge = null,
        ComponentMerge mergeBehavior = ComponentMerge.Merge,
        EnergyDrainHealType? permanentNegativeLevelsHeal = null,
        EnergyDrainHealType? temporaryNegativeLevelsHeal = null)
    {
      var component = new AngelSwordAntiDescriptor();
      component.CheckedDescriptor = checkedDescriptor ?? component.CheckedDescriptor;
      component.HealEnergyDrain = healEnergyDrain ?? component.HealEnergyDrain;
      component.HealStatDamageAndDrain = healStatDamageAndDrain ?? component.HealStatDamageAndDrain;
      component.PermanentNegativeLevelsHeal = permanentNegativeLevelsHeal ?? component.PermanentNegativeLevelsHeal;
      component.TemporaryNegativeLevelsHeal = temporaryNegativeLevelsHeal ?? component.TemporaryNegativeLevelsHeal;
      return AddUniqueComponent(component, mergeBehavior, merge);
    }

    /// <summary>
    /// Adds <see cref="AnyWeaponDamageStatReplacement"/>
    /// </summary>
    ///
    /// <remarks>
    ///
    /// <para>
    /// ComponentName: Replace damage stat for weapon
    /// </para>
    ///
    /// <list type="bullet">
    /// <listheader>Used by</listheader>
    /// <item><term>AlushinyrraCasterMiniboss_Features_Stage1</term><description>167558e0daed473aa55f0f30558787e8</description></item>
    /// <item><term>AlushinyrraCasterMiniboss_Features_Stage2</term><description>364240836fe246cfa016a7a1682adcc2</description></item>
    /// <item><term>WeaponFinesseMythicFeat</term><description>d791af1bc179e0e44a0ca1fa6c418993</description></item>
    /// </list>
    /// </remarks>
    ///
    /// <param name="merge">
    /// If mergeBehavior is ComponentMerge.Merge and the component already exists, this expression is called to merge the components.
    /// </param>
    /// <param name="mergeBehavior">
    /// Handling if the component already exists since the component is unique. Defaults to ComponentMerge.Fail.
    /// </param>
    public TBuilder AddAnyWeaponDamageStatReplacement(
        Action<BlueprintComponent, BlueprintComponent>? merge = null,
        ComponentMerge mergeBehavior = ComponentMerge.Merge,
        bool? onlyMelee = null,
        StatType? stat = null)
    {
      var component = new AnyWeaponDamageStatReplacement();
      component.OnlyMelee = onlyMelee ?? component.OnlyMelee;
      component.Stat = stat ?? component.Stat;
      return AddUniqueComponent(component, mergeBehavior, merge);
    }

    /// <summary>
    /// Adds <see cref="ArcaneArmorProficiency"/>
    /// </summary>
    ///
    /// <remarks>
    ///
    /// <para>
    /// ComponentName: Armor check penalty ignore
    /// </para>
    ///
    /// <list type="bullet">
    /// <listheader>Used by</listheader>
    /// <item><term>ArcaneHeavyArmor</term><description>447ca91389e5c9246acb2c640d63f4da</description></item>
    /// <item><term>BardProficiencies</term><description>fa3d3b2211a51994785d85e753f612d3</description></item>
    /// <item><term>SteelbloodArmorProficiency</term><description>86cb0c8eacd562e469375cef71698f9b</description></item>
    /// </list>
    /// </remarks>
    public TBuilder AddArcaneArmorProficiency(
        ArmorProficiencyGroup[]? armor = null)
    {
      var component = new ArcaneArmorProficiency();
      component.Armor = armor ?? component.Armor;
      if (component.Armor is null)
      {
        component.Armor = new ArmorProficiencyGroup[0];
      }
      return AddComponent(component);
    }

    /// <summary>
    /// Adds <see cref="ArcaneBloodlineArcana"/>
    /// </summary>
    ///
    /// <remarks>
    ///
    /// <list type="bullet">
    /// <listheader>Used by</listheader>
    /// <item><term>BloodlineArcaneArcana</term><description>e8e4f56618dd8b04490aa6a0b75ac24f</description></item>
    /// </list>
    /// </remarks>
    public TBuilder AddArcaneBloodlineArcana()
    {
      return AddComponent(new ArcaneBloodlineArcana());
    }

    /// <summary>
    /// Adds <see cref="ArcaneSpellFailureIncrease"/>
    /// </summary>
    ///
    /// <remarks>
    ///
    /// <para>
    /// ComponentName: Armor check penalty increase
    /// </para>
    ///
    /// <list type="bullet">
    /// <listheader>Used by</listheader>
    /// <item><term>ArcaneArmorMastery</term><description>453f5181a5ed3a445abfa3bcd3f4ac0c</description></item>
    /// <item><term>HellKnightOrderOfTheGateFeature5</term><description>bf25e35c3d3ee094a9659045f3b3a9e1</description></item>
    /// <item><term>MithralArmorFeature</term><description>0e5e0e709a16f6240b609616a6dbe916</description></item>
    /// </list>
    /// </remarks>
    public TBuilder AddArcaneSpellFailureIncrease(
        int? bonus = null,
        bool? toShield = null)
    {
      var component = new ArcaneSpellFailureIncrease();
      component.Bonus = bonus ?? component.Bonus;
      component.ToShield = toShield ?? component.ToShield;
      return AddComponent(component);
    }

    /// <summary>
    /// Adds <see cref="AreaEffectEnterTrigger"/>
    /// </summary>
    ///
    /// <remarks>
    ///
    /// <list type="bullet">
    /// <listheader>Used by</listheader>
    /// <item><term>AeonAreaEffectsGazeAllyBuff</term><description>5f628dc321f74a6bbadec25f665a402d</description></item>
    /// <item><term>Valmallos_Buff_AeonGazeAlly</term><description>67e8a3dd2d6a47a2bcf20e059a01fc72</description></item>
    /// <item><term>Valmallos_Buff_AeonGazeAlly_Core</term><description>8c43b0cd1ba54777b2eecb0c16caf5cf</description></item>
    /// </list>
    /// </remarks>
    ///
    /// <param name="areaEffects">
    /// <para>
    /// Blueprint of type BlueprintAbilityAreaEffect. You can pass in the blueprint using:
    /// <list type ="bullet">
    ///   <item><term>A blueprint instance</term></item>
    ///   <item><term>A blueprint reference</term></item>
    ///   <item><term>A blueprint id as a string, Guid, or BlueprintGuid</term></item>
    ///   <item><term>A blueprint name registered with <see cref="BlueprintCore.Utils.BlueprintTool">BlueprintTool</see></term></item>
    /// </list>
    /// See <see cref="BlueprintCore.Utils.Blueprint{{T, TRef}}">Blueprint</see> for more details.
    /// </para>
    /// </param>
    public TBuilder AddAreaEffectEnterTrigger(
        ActionsBuilder? actionsOnOwner = null,
        List<Blueprint<BlueprintAbilityAreaEffect, BlueprintAbilityAreaEffectReference>>? areaEffects = null,
        Kingmaker.UnitLogic.Abilities.Components.TargetType? casterType = null,
        bool? specificAreaEffects = null)
    {
      var component = new AreaEffectEnterTrigger();
      component.m_ActionsOnOwner = actionsOnOwner?.Build() ?? component.m_ActionsOnOwner;
      if (component.m_ActionsOnOwner is null)
      {
        component.m_ActionsOnOwner = Utils.Constants.Empty.Actions;
      }
      component.m_AreaEffects = areaEffects?.Select(bp => bp.Reference)?.ToArray() ?? component.m_AreaEffects;
      if (component.m_AreaEffects is null)
      {
        component.m_AreaEffects = new BlueprintAbilityAreaEffectReference[0];
      }
      component.m_CasterType = casterType ?? component.m_CasterType;
      component.m_SpecificAreaEffects = specificAreaEffects ?? component.m_SpecificAreaEffects;
      return AddComponent(component);
    }

    /// <summary>
    /// Adds <see cref="ArmorCheckPenaltyIncrease"/>
    /// </summary>
    ///
    /// <remarks>
    ///
    /// <para>
    /// ComponentName: Armor check penalty increase
    /// </para>
    ///
    /// <list type="bullet">
    /// <listheader>Used by</listheader>
    /// <item><term>ArmorTraining</term><description>3c380607706f209499d951b29d3c44f3</description></item>
    /// <item><term>MithralArmorFeature</term><description>0e5e0e709a16f6240b609616a6dbe916</description></item>
    /// <item><term>TowerShieldTraining</term><description>d2dbc71b45efa8749bd9c1924534b2bb</description></item>
    /// </list>
    /// </remarks>
    public TBuilder AddArmorCheckPenaltyIncrease(
        int? bonesPerRank = null,
        ContextValue? bonus = null,
        ArmorProficiencyGroup? category = null,
        bool? checkCategory = null)
    {
      var component = new ArmorCheckPenaltyIncrease();
      component.BonesPerRank = bonesPerRank ?? component.BonesPerRank;
      component.Bonus = bonus ?? component.Bonus;
      if (component.Bonus is null)
      {
        component.Bonus = ContextValues.Constant(0);
      }
      component.Category = category ?? component.Category;
      component.CheckCategory = checkCategory ?? component.CheckCategory;
      return AddComponent(component);
    }

    /// <summary>
    /// Adds <see cref="ArmorClassBonusAgainstAlignment"/>
    /// </summary>
    ///
    /// <remarks>
    ///
    /// <para>
    /// ComponentName: Armor class bonus against alignment
    /// </para>
    ///
    /// <list type="bullet">
    /// <listheader>Used by</listheader>
    /// <item><term>AngelHaloEffectBuff</term><description>c6f5ae2a926382b469c77967971f8d10</description></item>
    /// <item><term>HellKnightOrderOfTheGodclawTier2Buff</term><description>85ddbdb40aaa92344b81ef2a6b1fb68e</description></item>
    /// <item><term>SecretsOfSuramgaminNecklaceFeature</term><description>1f740d2180cec2c4bb90d602ee683c93</description></item>
    /// </list>
    /// </remarks>
    ///
    /// <param name="merge">
    /// If mergeBehavior is ComponentMerge.Merge and the component already exists, this expression is called to merge the components.
    /// </param>
    /// <param name="mergeBehavior">
    /// Handling if the component already exists since the component is unique. Defaults to ComponentMerge.Fail.
    /// </param>
    public TBuilder AddArmorClassBonusAgainstAlignment(
        AlignmentComponent? alignment = null,
        ContextValue? bonus = null,
        ModifierDescriptor? descriptor = null,
        Action<BlueprintComponent, BlueprintComponent>? merge = null,
        ComponentMerge mergeBehavior = ComponentMerge.Merge,
        int? value = null)
    {
      var component = new ArmorClassBonusAgainstAlignment();
      component.alignment = alignment ?? component.alignment;
      component.Bonus = bonus ?? component.Bonus;
      if (component.Bonus is null)
      {
        component.Bonus = ContextValues.Constant(0);
      }
      component.Descriptor = descriptor ?? component.Descriptor;
      component.Value = value ?? component.Value;
      return AddUniqueComponent(component, mergeBehavior, merge);
    }

    /// <summary>
    /// Adds <see cref="AscendantElement"/>
    /// </summary>
    ///
    /// <remarks>
    ///
    /// <list type="bullet">
    /// <listheader>Used by</listheader>
    /// <item><term>AscendantElementAcid</term><description>d808baf783a063e4d84a1aaadbdd1cb7</description></item>
    /// <item><term>AscendantElementSonic</term><description>a81e13751f5ee9b4eac75b1dae801661</description></item>
    /// <item><term>ThunderingRageBuff</term><description>e088db07eb1648498cbdc26f9b07d385</description></item>
    /// </list>
    /// </remarks>
    public TBuilder AddAscendantElement(
        DamageEnergyType? element = null)
    {
      var component = new AscendantElement();
      component.Element = element ?? component.Element;
      return AddComponent(component);
    }

    /// <summary>
    /// Adds <see cref="AttackBonusAgainstAlignment"/>
    /// </summary>
    ///
    /// <remarks>
    ///
    /// <list type="bullet">
    /// <listheader>Used by</listheader>
    /// <item><term>HellKnightOrderOfTheGodclawTier1Buff</term><description>7ca21c64bc506144ebf420907382480e</description></item>
    /// <item><term>PF2_DLC1_ChaoticAttackBuff</term><description>fd682b536d62452b91b4d72c81a86f2f</description></item>
    /// <item><term>ShortbowOfCodeFeature</term><description>0a4d68abcf634c548b1b029e55fa16ae</description></item>
    /// </list>
    /// </remarks>
    ///
    /// <param name="merge">
    /// If mergeBehavior is ComponentMerge.Merge and the component already exists, this expression is called to merge the components.
    /// </param>
    /// <param name="mergeBehavior">
    /// Handling if the component already exists since the component is unique. Defaults to ComponentMerge.Fail.
    /// </param>
    public TBuilder AddAttackBonusAgainstAlignment(
        AlignmentComponent? alignment = null,
        ContextValue? bonus = null,
        int? damageBonus = null,
        ModifierDescriptor? descriptor = null,
        Action<BlueprintComponent, BlueprintComponent>? merge = null,
        ComponentMerge mergeBehavior = ComponentMerge.Merge,
        bool? onlyMelee = null)
    {
      var component = new AttackBonusAgainstAlignment();
      component.Alignment = alignment ?? component.Alignment;
      component.Bonus = bonus ?? component.Bonus;
      if (component.Bonus is null)
      {
        component.Bonus = ContextValues.Constant(0);
      }
      component.DamageBonus = damageBonus ?? component.DamageBonus;
      component.Descriptor = descriptor ?? component.Descriptor;
      component.OnlyMelee = onlyMelee ?? component.OnlyMelee;
      return AddUniqueComponent(component, mergeBehavior, merge);
    }

    /// <summary>
    /// Adds <see cref="AttackBonusAgainstArmyProperty"/>
    /// </summary>
    ///
    /// <remarks>
    ///
    /// <list type="bullet">
    /// <listheader>Used by</listheader>
    /// <item><term>ArmyAttackBonusAgainstCaster</term><description>bf99438da3bab0243b70295fc6e81d91</description></item>
    /// <item><term>ArmyBonusAgainstArmored</term><description>683dbb73c8d739c419e3e5915b086172</description></item>
    /// <item><term>ArmyBonusAgainstLarge</term><description>5b5420a735bd99247b8b89578e13af7b</description></item>
    /// </list>
    /// </remarks>
    ///
    /// <param name="armyProperties">
    /// <para>
    /// InfoBox: Works as OR. Unit should have Any of listed property to be processed. None - means any unit
    /// </para>
    /// </param>
    /// <param name="merge">
    /// If mergeBehavior is ComponentMerge.Merge and the component already exists, this expression is called to merge the components.
    /// </param>
    /// <param name="mergeBehavior">
    /// Handling if the component already exists since the component is unique. Defaults to ComponentMerge.Fail.
    /// </param>
    public TBuilder AddAttackBonusAgainstArmyProperty(
        ArmyProperties? armyProperties = null,
        ModifierDescriptor? descriptor = null,
        Action<BlueprintComponent, BlueprintComponent>? merge = null,
        ComponentMerge mergeBehavior = ComponentMerge.Merge,
        ContextValue? value = null)
    {
      var component = new AttackBonusAgainstArmyProperty();
      component.ArmyProperties = armyProperties ?? component.ArmyProperties;
      component.Descriptor = descriptor ?? component.Descriptor;
      component.Value = value ?? component.Value;
      if (component.Value is null)
      {
        component.Value = ContextValues.Constant(0);
      }
      return AddUniqueComponent(component, mergeBehavior, merge);
    }

    /// <summary>
    /// Adds <see cref="AttackBonusAgainstFactOwner"/>
    /// </summary>
    ///
    /// <remarks>
    ///
    /// <para>
    /// ComponentName: Attack bonus against fact owner
    /// </para>
    ///
    /// <list type="bullet">
    /// <listheader>Used by</listheader>
    /// <item><term>AggressorBleedingStrike</term><description>37f3ca7f3e584a5b9edb2cad88cf5ba7</description></item>
    /// <item><term>FeyStalkerPetFeature</term><description>c60869182aa99f94aa79b7cd7fd7f197</description></item>
    /// <item><term>ZeorisDaggerRing_GoverningAllyBuff</term><description>02680be495534b629d543daa89b47079</description></item>
    /// </list>
    /// </remarks>
    ///
    /// <param name="checkedFact">
    /// <para>
    /// Blueprint of type BlueprintUnitFact. You can pass in the blueprint using:
    /// <list type ="bullet">
    ///   <item><term>A blueprint instance</term></item>
    ///   <item><term>A blueprint reference</term></item>
    ///   <item><term>A blueprint id as a string, Guid, or BlueprintGuid</term></item>
    ///   <item><term>A blueprint name registered with <see cref="BlueprintCore.Utils.BlueprintTool">BlueprintTool</see></term></item>
    /// </list>
    /// See <see cref="BlueprintCore.Utils.Blueprint{{T, TRef}}">Blueprint</see> for more details.
    /// </para>
    /// </param>
    /// <param name="merge">
    /// If mergeBehavior is ComponentMerge.Merge and the component already exists, this expression is called to merge the components.
    /// </param>
    /// <param name="mergeBehavior">
    /// Handling if the component already exists since the component is unique. Defaults to ComponentMerge.Fail.
    /// </param>
    public TBuilder AddAttackBonusAgainstFactOwner(
        int? attackBonus = null,
        ContextValue? bonus = null,
        Blueprint<BlueprintUnitFact, BlueprintUnitFactReference>? checkedFact = null,
        ModifierDescriptor? descriptor = null,
        Action<BlueprintComponent, BlueprintComponent>? merge = null,
        ComponentMerge mergeBehavior = ComponentMerge.Merge,
        bool? not = null)
    {
      var component = new AttackBonusAgainstFactOwner();
      component.AttackBonus = attackBonus ?? component.AttackBonus;
      component.Bonus = bonus ?? component.Bonus;
      if (component.Bonus is null)
      {
        component.Bonus = ContextValues.Constant(0);
      }
      component.m_CheckedFact = checkedFact?.Reference ?? component.m_CheckedFact;
      if (component.m_CheckedFact is null)
      {
        component.m_CheckedFact = BlueprintTool.GetRef<BlueprintUnitFactReference>(null);
      }
      component.Descriptor = descriptor ?? component.Descriptor;
      component.Not = not ?? component.Not;
      return AddUniqueComponent(component, mergeBehavior, merge);
    }

    /// <summary>
    /// Adds <see cref="AttackBonusAgainstFriendly"/>
    /// </summary>
    ///
    /// <remarks>
    ///
    /// <list type="bullet">
    /// <listheader>Used by</listheader>
    /// <item><term>LordProtectorFeature</term><description>2a40d3cbefd5925478557db52dc49719</description></item>
    /// </list>
    /// </remarks>
    ///
    /// <param name="merge">
    /// If mergeBehavior is ComponentMerge.Merge and the component already exists, this expression is called to merge the components.
    /// </param>
    /// <param name="mergeBehavior">
    /// Handling if the component already exists since the component is unique. Defaults to ComponentMerge.Fail.
    /// </param>
    public TBuilder AddAttackBonusAgainstFriendly(
        int? attackBonus = null,
        ModifierDescriptor? descriptor = null,
        Action<BlueprintComponent, BlueprintComponent>? merge = null,
        ComponentMerge mergeBehavior = ComponentMerge.Merge)
    {
      var component = new AttackBonusAgainstFriendly();
      component.AttackBonus = attackBonus ?? component.AttackBonus;
      component.Descriptor = descriptor ?? component.Descriptor;
      return AddUniqueComponent(component, mergeBehavior, merge);
    }

    /// <summary>
    /// Adds <see cref="AttackBonusAgainstSize"/>
    /// </summary>
    ///
    /// <remarks>
    ///
    /// <list type="bullet">
    /// <listheader>Used by</listheader>
    /// <item><term>AmuletOfQuickDrawFeature</term><description>60c9144d13674a445aa303fa272aae0a</description></item>
    /// <item><term>BehemothChopperFeature</term><description>54efeb34545e435ea18f3cb2ded38443</description></item>
    /// <item><term>TheBiggerTheyAre</term><description>91a3a658f82ee5044a7c1eaaf756aa50</description></item>
    /// </list>
    /// </remarks>
    ///
    /// <param name="merge">
    /// If mergeBehavior is ComponentMerge.Merge and the component already exists, this expression is called to merge the components.
    /// </param>
    /// <param name="mergeBehavior">
    /// Handling if the component already exists since the component is unique. Defaults to ComponentMerge.Fail.
    /// </param>
    /// <param name="targetFact">
    /// <para>
    /// Blueprint of type BlueprintUnitFact. You can pass in the blueprint using:
    /// <list type ="bullet">
    ///   <item><term>A blueprint instance</term></item>
    ///   <item><term>A blueprint reference</term></item>
    ///   <item><term>A blueprint id as a string, Guid, or BlueprintGuid</term></item>
    ///   <item><term>A blueprint name registered with <see cref="BlueprintCore.Utils.BlueprintTool">BlueprintTool</see></term></item>
    /// </list>
    /// See <see cref="BlueprintCore.Utils.Blueprint{{T, TRef}}">Blueprint</see> for more details.
    /// </para>
    /// </param>
    public TBuilder AddAttackBonusAgainstSize(
        bool? checkTargetFact = null,
        ModifierDescriptor? descriptor = null,
        Action<BlueprintComponent, BlueprintComponent>? merge = null,
        ComponentMerge mergeBehavior = ComponentMerge.Merge,
        bool? onlyForMelee = null,
        bool? onlyForRanged = null,
        Size? size = null,
        bool? sizeMoreThan = null,
        Blueprint<BlueprintUnitFact, BlueprintUnitFactReference>? targetFact = null,
        ContextValue? value = null)
    {
      var component = new AttackBonusAgainstSize();
      component.CheckTargetFact = checkTargetFact ?? component.CheckTargetFact;
      component.Descriptor = descriptor ?? component.Descriptor;
      component.OnlyForMelee = onlyForMelee ?? component.OnlyForMelee;
      component.OnlyForRanged = onlyForRanged ?? component.OnlyForRanged;
      component.Size = size ?? component.Size;
      component.SizeMoreThan = sizeMoreThan ?? component.SizeMoreThan;
      component.m_TargetFact = targetFact?.Reference ?? component.m_TargetFact;
      if (component.m_TargetFact is null)
      {
        component.m_TargetFact = BlueprintTool.GetRef<BlueprintUnitFactReference>(null);
      }
      component.Value = value ?? component.Value;
      if (component.Value is null)
      {
        component.Value = ContextValues.Constant(0);
      }
      return AddUniqueComponent(component, mergeBehavior, merge);
    }

    /// <summary>
    /// Adds <see cref="AttackBonusConditional"/>
    /// </summary>
    ///
    /// <remarks>
    ///
    /// <list type="bullet">
    /// <listheader>Used by</listheader>
    /// <item><term>Airborne</term><description>70cffb448c132fa409e49156d013b175</description></item>
    /// <item><term>EarthMastery</term><description>be65c8334ceac234195be030137563d8</description></item>
    /// <item><term>WrathOfTheUndeadBuff</term><description>6a30b625459e421d862debf0b3d0214f</description></item>
    /// </list>
    /// </remarks>
    ///
    /// <param name="merge">
    /// If mergeBehavior is ComponentMerge.Merge and the component already exists, this expression is called to merge the components.
    /// </param>
    /// <param name="mergeBehavior">
    /// Handling if the component already exists since the component is unique. Defaults to ComponentMerge.Fail.
    /// </param>
    public TBuilder AddAttackBonusConditional(
        ContextValue? bonus = null,
        bool? checkWielder = null,
        ConditionsBuilder? conditions = null,
        ModifierDescriptor? descriptor = null,
        Action<BlueprintComponent, BlueprintComponent>? merge = null,
        ComponentMerge mergeBehavior = ComponentMerge.Merge)
    {
      var component = new AttackBonusConditional();
      component.Bonus = bonus ?? component.Bonus;
      if (component.Bonus is null)
      {
        component.Bonus = ContextValues.Constant(0);
      }
      component.CheckWielder = checkWielder ?? component.CheckWielder;
      component.Conditions = conditions?.Build() ?? component.Conditions;
      if (component.Conditions is null)
      {
        component.Conditions = Utils.Constants.Empty.Conditions;
      }
      component.Descriptor = descriptor ?? component.Descriptor;
      return AddUniqueComponent(component, mergeBehavior, merge);
    }

    /// <summary>
    /// Adds <see cref="AttackOfOpportunityAttackBonus"/>
    /// </summary>
    ///
    /// <remarks>
    ///
    /// <list type="bullet">
    /// <listheader>Used by</listheader>
    /// <item><term>AeonAoOGazeAllyBuff</term><description>a85b9737fba146dcb3468526d67fbc0e</description></item>
    /// <item><term>TheUndyingLoveOfTheHopebringer_DarkAuraCompanionEffectBuff</term><description>fbc3d50954b94fa28b5eceb172549d81</description></item>
    /// <item><term>WanderingDuelistsSpearFeature</term><description>b97ca730b45546a993a72e9f6d8677d8</description></item>
    /// </list>
    /// </remarks>
    public TBuilder AddAttackOfOpportunityAttackBonus(
        ContextValue? bonus = null,
        ModifierDescriptor? descriptor = null,
        bool? notAttackOfOpportunity = null)
    {
      var component = new AttackOfOpportunityAttackBonus();
      component.Bonus = bonus ?? component.Bonus;
      if (component.Bonus is null)
      {
        component.Bonus = ContextValues.Constant(0);
      }
      component.Descriptor = descriptor ?? component.Descriptor;
      component.NotAttackOfOpportunity = notAttackOfOpportunity ?? component.NotAttackOfOpportunity;
      return AddComponent(component);
    }

    /// <summary>
    /// Adds <see cref="AttackOfOpportunityCriticalConfirmationBonus"/>
    /// </summary>
    ///
    /// <remarks>
    ///
    /// <list type="bullet">
    /// <listheader>Used by</listheader>
    /// <item><term>SnapShotGreater</term><description>67b09c86234cecc4c8309f22f7d33973</description></item>
    /// </list>
    /// </remarks>
    public TBuilder AddAttackOfOpportunityCriticalConfirmationBonus(
        ContextValue? bonus = null,
        bool? checkWeaponRangeType = null,
        WeaponRangeType? type = null)
    {
      var component = new AttackOfOpportunityCriticalConfirmationBonus();
      component.Bonus = bonus ?? component.Bonus;
      if (component.Bonus is null)
      {
        component.Bonus = ContextValues.Constant(0);
      }
      component.CheckWeaponRangeType = checkWeaponRangeType ?? component.CheckWeaponRangeType;
      component.Type = type ?? component.Type;
      return AddComponent(component);
    }

    /// <summary>
    /// Adds <see cref="AttackOfOpportunityDamageBonus"/>
    /// </summary>
    ///
    /// <remarks>
    ///
    /// <para>
    /// ComponentName: Distance damage bonus
    /// </para>
    ///
    /// <list type="bullet">
    /// <listheader>Used by</listheader>
    /// <item><term>AeonAoOGazeAllyBuff</term><description>a85b9737fba146dcb3468526d67fbc0e</description></item>
    /// <item><term>Valmallos_Buff_AeonGazeAlly</term><description>67e8a3dd2d6a47a2bcf20e059a01fc72</description></item>
    /// <item><term>WanderingDuelistsSpearFeature</term><description>b97ca730b45546a993a72e9f6d8677d8</description></item>
    /// </list>
    /// </remarks>
    public TBuilder AddAttackOfOpportunityDamageBonus(
        bool? checkWeaponRangeType = null,
        ContextValue? damageBonus = null,
        WeaponRangeType? weaponType = null)
    {
      var component = new AttackOfOpportunityDamageBonus();
      component.CheckWeaponRangeType = checkWeaponRangeType ?? component.CheckWeaponRangeType;
      component.DamageBonus = damageBonus ?? component.DamageBonus;
      if (component.DamageBonus is null)
      {
        component.DamageBonus = ContextValues.Constant(0);
      }
      component.WeaponType = weaponType ?? component.WeaponType;
      return AddComponent(component);
    }

    /// <summary>
    /// Adds <see cref="AttackTypeAttackBonus"/>
    /// </summary>
    ///
    /// <remarks>
    ///
    /// <list type="bullet">
    /// <listheader>Used by</listheader>
    /// <item><term>AspectOfTheFalconBuff</term><description>5de9e71d013d1024eb14f4c5605b31dc</description></item>
    /// <item><term>InspiredRageEffectBuff</term><description>75b3978757908d24aaaecaf2dc209b89</description></item>
    /// <item><term>VrockAspectEffectBuff</term><description>76eb2cd9b1eec0b4681c648d33c5ae3b</description></item>
    /// </list>
    /// </remarks>
    ///
    /// <param name="requiredFact">
    /// <para>
    /// Blueprint of type BlueprintUnitFact. You can pass in the blueprint using:
    /// <list type ="bullet">
    ///   <item><term>A blueprint instance</term></item>
    ///   <item><term>A blueprint reference</term></item>
    ///   <item><term>A blueprint id as a string, Guid, or BlueprintGuid</term></item>
    ///   <item><term>A blueprint name registered with <see cref="BlueprintCore.Utils.BlueprintTool">BlueprintTool</see></term></item>
    /// </list>
    /// See <see cref="BlueprintCore.Utils.Blueprint{{T, TRef}}">Blueprint</see> for more details.
    /// </para>
    /// </param>
    public TBuilder AddAttackTypeAttackBonus(
        bool? allTypesExcept = null,
        int? attackBonus = null,
        bool? checkFact = null,
        ModifierDescriptor? descriptor = null,
        Blueprint<BlueprintUnitFact, BlueprintUnitFactReference>? requiredFact = null,
        WeaponRangeType? type = null,
        ContextValue? value = null)
    {
      var component = new AttackTypeAttackBonus();
      component.AllTypesExcept = allTypesExcept ?? component.AllTypesExcept;
      component.AttackBonus = attackBonus ?? component.AttackBonus;
      component.CheckFact = checkFact ?? component.CheckFact;
      component.Descriptor = descriptor ?? component.Descriptor;
      component.m_RequiredFact = requiredFact?.Reference ?? component.m_RequiredFact;
      if (component.m_RequiredFact is null)
      {
        component.m_RequiredFact = BlueprintTool.GetRef<BlueprintUnitFactReference>(null);
      }
      component.Type = type ?? component.Type;
      component.Value = value ?? component.Value;
      if (component.Value is null)
      {
        component.Value = ContextValues.Constant(0);
      }
      return AddComponent(component);
    }

    /// <summary>
    /// Adds <see cref="AttackTypeChange"/>
    /// </summary>
    ///
    /// <remarks>
    ///
    /// <list type="bullet">
    /// <listheader>Used by</listheader>
    /// <item><term>DimensionStrikeBuff</term><description>c25e4bf29c7baa24aa1d6f630a6c1fc3</description></item>
    /// <item><term>SwarmFeastExtraBuff</term><description>77558f3e79847bb448aa980a1aee326e</description></item>
    /// </list>
    /// </remarks>
    ///
    /// <param name="merge">
    /// If mergeBehavior is ComponentMerge.Merge and the component already exists, this expression is called to merge the components.
    /// </param>
    /// <param name="mergeBehavior">
    /// Handling if the component already exists since the component is unique. Defaults to ComponentMerge.Fail.
    /// </param>
    public TBuilder AddAttackTypeChange(
        bool? changeAllTypes = null,
        Action<BlueprintComponent, BlueprintComponent>? merge = null,
        ComponentMerge mergeBehavior = ComponentMerge.Merge,
        bool? needsWeapon = null,
        AttackType? newType = null,
        AttackType? originalType = null)
    {
      var component = new AttackTypeChange();
      component.ChangeAllTypes = changeAllTypes ?? component.ChangeAllTypes;
      component.NeedsWeapon = needsWeapon ?? component.NeedsWeapon;
      component.NewType = newType ?? component.NewType;
      component.OriginalType = originalType ?? component.OriginalType;
      return AddUniqueComponent(component, mergeBehavior, merge);
    }

    /// <summary>
    /// Adds <see cref="AttackTypeCriticalMultiplierIncrease"/>
    /// </summary>
    ///
    /// <remarks>
    ///
    /// <list type="bullet">
    /// <listheader>Used by</listheader>
    /// <item><term>LethalAccuracyEffectBuff</term><description>cc6a55bdf2220674f9ce6b18123b33e0</description></item>
    /// </list>
    /// </remarks>
    public TBuilder AddAttackTypeCriticalMultiplierIncrease(
        int? additionalMultiplier = null,
        WeaponRangeType? type = null)
    {
      var component = new AttackTypeCriticalMultiplierIncrease();
      component.AdditionalMultiplier = additionalMultiplier ?? component.AdditionalMultiplier;
      component.Type = type ?? component.Type;
      return AddComponent(component);
    }

    /// <summary>
    /// Adds <see cref="AuraFeatureComponent"/>
    /// </summary>
    ///
    /// <remarks>
    ///
    /// <para>
    /// ComponentName: Buff on spawned unit
    /// </para>
    ///
    /// <list type="bullet">
    /// <listheader>Used by</listheader>
    /// <item><term>AngelicAspectGreaterBuff</term><description>87fcda72043d20840b4cdc2adcc69c63</description></item>
    /// <item><term>CorruptedRatSwarmDamageFeature</term><description>1296a787ff02709428b0453805731073</description></item>
    /// <item><term>VolleyFireFeature</term><description>c4b555225f565bb40a855c1bfeeff07e</description></item>
    /// </list>
    /// </remarks>
    ///
    /// <param name="buff">
    /// <para>
    /// Blueprint of type BlueprintBuff. You can pass in the blueprint using:
    /// <list type ="bullet">
    ///   <item><term>A blueprint instance</term></item>
    ///   <item><term>A blueprint reference</term></item>
    ///   <item><term>A blueprint id as a string, Guid, or BlueprintGuid</term></item>
    ///   <item><term>A blueprint name registered with <see cref="BlueprintCore.Utils.BlueprintTool">BlueprintTool</see></term></item>
    /// </list>
    /// See <see cref="BlueprintCore.Utils.Blueprint{{T, TRef}}">Blueprint</see> for more details.
    /// </para>
    /// </param>
    /// <param name="merge">
    /// If mergeBehavior is ComponentMerge.Merge and the component already exists, this expression is called to merge the components.
    /// </param>
    /// <param name="mergeBehavior">
    /// Handling if the component already exists since the component is unique. Defaults to ComponentMerge.Fail.
    /// </param>
    public TBuilder AddAuraFeatureComponent(
        Blueprint<BlueprintBuff, BlueprintBuffReference>? buff = null,
        Action<BlueprintComponent, BlueprintComponent>? merge = null,
        ComponentMerge mergeBehavior = ComponentMerge.Merge)
    {
      var component = new AuraFeatureComponent();
      component.m_Buff = buff?.Reference ?? component.m_Buff;
      if (component.m_Buff is null)
      {
        component.m_Buff = BlueprintTool.GetRef<BlueprintBuffReference>(null);
      }
      return AddUniqueComponent(component, mergeBehavior, merge);
    }

    /// <summary>
    /// Adds <see cref="AutoConfirmCritAgainstFlanked"/>
    /// </summary>
    ///
    /// <remarks>
    ///
    /// <list type="bullet">
    /// <listheader>Used by</listheader>
    /// <item><term>ImpendingDemiseFeature</term><description>20d728c7356647429fd2e5eda3f0106d</description></item>
    /// </list>
    /// </remarks>
    public TBuilder AddAutoConfirmCritAgainstFlanked()
    {
      return AddComponent(new AutoConfirmCritAgainstFlanked());
    }

    /// <summary>
    /// Adds <see cref="AutoDetectStealth"/>
    /// </summary>
    ///
    /// <remarks>
    ///
    /// <list type="bullet">
    /// <listheader>Used by</listheader>
    /// <item><term>TricksterPerceptionTier2Feature</term><description>e9298851786c5334dba1398e9635a83d</description></item>
    /// </list>
    /// </remarks>
    ///
    /// <param name="merge">
    /// If mergeBehavior is ComponentMerge.Merge and the component already exists, this expression is called to merge the components.
    /// </param>
    /// <param name="mergeBehavior">
    /// Handling if the component already exists since the component is unique. Defaults to ComponentMerge.Fail.
    /// </param>
    public TBuilder AddAutoDetectStealth(
        Action<BlueprintComponent, BlueprintComponent>? merge = null,
        ComponentMerge mergeBehavior = ComponentMerge.Merge)
    {
      var component = new AutoDetectStealth();
      return AddUniqueComponent(component, mergeBehavior, merge);
    }

    /// <summary>
    /// Adds <see cref="AutoMetamagic"/>
    /// </summary>
    ///
    /// <remarks>
    ///
    /// <para>
    /// ComponentName: Empower spell from list
    /// </para>
    ///
    /// <list type="bullet">
    /// <listheader>Used by</listheader>
    /// <item><term>AbrogailMetamagicFeature</term><description>f976da658b1344538cfb867e6a3329ec</description></item>
    /// <item><term>LifeDelivererFeature</term><description>240aeac174ee4422aca3d4dd6eefdf91</description></item>
    /// <item><term>Zanedra_Metamagic</term><description>ad77aded6888c69458669e5ecd2fa979</description></item>
    /// </list>
    /// </remarks>
    ///
    /// <param name="abilities">
    /// <para>
    /// Blueprint of type BlueprintAbility. You can pass in the blueprint using:
    /// <list type ="bullet">
    ///   <item><term>A blueprint instance</term></item>
    ///   <item><term>A blueprint reference</term></item>
    ///   <item><term>A blueprint id as a string, Guid, or BlueprintGuid</term></item>
    ///   <item><term>A blueprint name registered with <see cref="BlueprintCore.Utils.BlueprintTool">BlueprintTool</see></term></item>
    /// </list>
    /// See <see cref="BlueprintCore.Utils.Blueprint{{T, TRef}}">Blueprint</see> for more details.
    /// </para>
    /// </param>
    /// <param name="merge">
    /// If mergeBehavior is ComponentMerge.Merge and the component already exists, this expression is called to merge the components.
    /// </param>
    /// <param name="mergeBehavior">
    /// Handling if the component already exists since the component is unique. Defaults to ComponentMerge.Fail.
    /// </param>
    /// <param name="spellbook">
    /// <para>
    /// Blueprint of type BlueprintSpellbook. You can pass in the blueprint using:
    /// <list type ="bullet">
    ///   <item><term>A blueprint instance</term></item>
    ///   <item><term>A blueprint reference</term></item>
    ///   <item><term>A blueprint id as a string, Guid, or BlueprintGuid</term></item>
    ///   <item><term>A blueprint name registered with <see cref="BlueprintCore.Utils.BlueprintTool">BlueprintTool</see></term></item>
    /// </list>
    /// See <see cref="BlueprintCore.Utils.Blueprint{{T, TRef}}">Blueprint</see> for more details.
    /// </para>
    /// </param>
    public TBuilder AddAutoMetamagic(
        List<Blueprint<BlueprintAbility, BlueprintAbilityReference>>? abilities = null,
        AutoMetamagic.AllowedType? allowedAbilities = null,
        bool? checkSpellbook = null,
        SpellDescriptorWrapper? descriptor = null,
        int? maxSpellLevel = null,
        Action<BlueprintComponent, BlueprintComponent>? merge = null,
        ComponentMerge mergeBehavior = ComponentMerge.Merge,
        Metamagic? metamagic = null,
        bool? once = null,
        SpellSchool? school = null,
        Blueprint<BlueprintSpellbook, BlueprintSpellbookReference>? spellbook = null)
    {
      var component = new AutoMetamagic();
      component.Abilities = abilities?.Select(bp => bp.Reference)?.ToList() ?? component.Abilities;
      if (component.Abilities is null)
      {
        component.Abilities = new();
      }
      component.m_AllowedAbilities = allowedAbilities ?? component.m_AllowedAbilities;
      component.CheckSpellbook = checkSpellbook ?? component.CheckSpellbook;
      component.Descriptor = descriptor ?? component.Descriptor;
      component.MaxSpellLevel = maxSpellLevel ?? component.MaxSpellLevel;
      component.Metamagic = metamagic ?? component.Metamagic;
      component.Once = once ?? component.Once;
      component.School = school ?? component.School;
      component.m_Spellbook = spellbook?.Reference ?? component.m_Spellbook;
      if (component.m_Spellbook is null)
      {
        component.m_Spellbook = BlueprintTool.GetRef<BlueprintSpellbookReference>(null);
      }
      return AddUniqueComponent(component, mergeBehavior, merge);
    }

    /// <summary>
    /// Adds <see cref="BackToBack"/>
    /// </summary>
    ///
    /// <remarks>
    ///
    /// <list type="bullet">
    /// <listheader>Used by</listheader>
    /// <item><term>BackToBack</term><description>c920f2cd2244d284aa69a146aeefcb2c</description></item>
    /// </list>
    /// </remarks>
    ///
    /// <param name="backToBackFact">
    /// <para>
    /// Blueprint of type BlueprintUnitFact. You can pass in the blueprint using:
    /// <list type ="bullet">
    ///   <item><term>A blueprint instance</term></item>
    ///   <item><term>A blueprint reference</term></item>
    ///   <item><term>A blueprint id as a string, Guid, or BlueprintGuid</term></item>
    ///   <item><term>A blueprint name registered with <see cref="BlueprintCore.Utils.BlueprintTool">BlueprintTool</see></term></item>
    /// </list>
    /// See <see cref="BlueprintCore.Utils.Blueprint{{T, TRef}}">Blueprint</see> for more details.
    /// </para>
    /// </param>
    /// <param name="merge">
    /// If mergeBehavior is ComponentMerge.Merge and the component already exists, this expression is called to merge the components.
    /// </param>
    /// <param name="mergeBehavior">
    /// Handling if the component already exists since the component is unique. Defaults to ComponentMerge.Fail.
    /// </param>
    public TBuilder AddBackToBack(
        Blueprint<BlueprintUnitFact, BlueprintUnitFactReference>? backToBackFact = null,
        Action<BlueprintComponent, BlueprintComponent>? merge = null,
        ComponentMerge mergeBehavior = ComponentMerge.Merge,
        int? radius = null)
    {
      var component = new BackToBack();
      component.m_BackToBackFact = backToBackFact?.Reference ?? component.m_BackToBackFact;
      if (component.m_BackToBackFact is null)
      {
        component.m_BackToBackFact = BlueprintTool.GetRef<BlueprintUnitFactReference>(null);
      }
      component.Radius = radius ?? component.Radius;
      return AddUniqueComponent(component, mergeBehavior, merge);
    }

    /// <summary>
    /// Adds <see cref="BackToBackBetter"/>
    /// </summary>
    ///
    /// <remarks>
    ///
    /// <list type="bullet">
    /// <listheader>Used by</listheader>
    /// <item><term>AllRoundDefenseFeature</term><description>7060a735afc12e144942d853ad5b7a65</description></item>
    /// </list>
    /// </remarks>
    ///
    /// <param name="backToBackBetterFact">
    /// <para>
    /// Blueprint of type BlueprintUnitFact. You can pass in the blueprint using:
    /// <list type ="bullet">
    ///   <item><term>A blueprint instance</term></item>
    ///   <item><term>A blueprint reference</term></item>
    ///   <item><term>A blueprint id as a string, Guid, or BlueprintGuid</term></item>
    ///   <item><term>A blueprint name registered with <see cref="BlueprintCore.Utils.BlueprintTool">BlueprintTool</see></term></item>
    /// </list>
    /// See <see cref="BlueprintCore.Utils.Blueprint{{T, TRef}}">Blueprint</see> for more details.
    /// </para>
    /// </param>
    /// <param name="merge">
    /// If mergeBehavior is ComponentMerge.Merge and the component already exists, this expression is called to merge the components.
    /// </param>
    /// <param name="mergeBehavior">
    /// Handling if the component already exists since the component is unique. Defaults to ComponentMerge.Fail.
    /// </param>
    public TBuilder AddBackToBackBetter(
        Blueprint<BlueprintUnitFact, BlueprintUnitFactReference>? backToBackBetterFact = null,
        Action<BlueprintComponent, BlueprintComponent>? merge = null,
        ComponentMerge mergeBehavior = ComponentMerge.Merge,
        int? radius = null)
    {
      var component = new BackToBackBetter();
      component.m_BackToBackBetterFact = backToBackBetterFact?.Reference ?? component.m_BackToBackBetterFact;
      if (component.m_BackToBackBetterFact is null)
      {
        component.m_BackToBackBetterFact = BlueprintTool.GetRef<BlueprintUnitFactReference>(null);
      }
      component.Radius = radius ?? component.Radius;
      return AddUniqueComponent(component, mergeBehavior, merge);
    }

    /// <summary>
    /// Adds <see cref="BindAbilitiesToClass"/>
    /// </summary>
    ///
    /// <remarks>
    ///
    /// <para>
    /// ComponentName: Replace stat for Ability DC
    /// </para>
    ///
    /// <list type="bullet">
    /// <listheader>Used by</listheader>
    /// <item><term>AccursedWitchCantripsFeature</term><description>d83becdd1ab644b995ae4aa96a493351</description></item>
    /// <item><term>DevilApostateEvangelizationFeature</term><description>c2e7a4011d3f88041ac428c5a166ca68</description></item>
    /// <item><term>WizardCantripsFeature</term><description>44d19b62d00179e4bad7afae7684f2e2</description></item>
    /// </list>
    /// </remarks>
    ///
    /// <param name="abilites">
    /// <para>
    /// Blueprint of type BlueprintAbility. You can pass in the blueprint using:
    /// <list type ="bullet">
    ///   <item><term>A blueprint instance</term></item>
    ///   <item><term>A blueprint reference</term></item>
    ///   <item><term>A blueprint id as a string, Guid, or BlueprintGuid</term></item>
    ///   <item><term>A blueprint name registered with <see cref="BlueprintCore.Utils.BlueprintTool">BlueprintTool</see></term></item>
    /// </list>
    /// See <see cref="BlueprintCore.Utils.Blueprint{{T, TRef}}">Blueprint</see> for more details.
    /// </para>
    /// </param>
    /// <param name="additionalClasses">
    /// <para>
    /// Blueprint of type BlueprintCharacterClass. You can pass in the blueprint using:
    /// <list type ="bullet">
    ///   <item><term>A blueprint instance</term></item>
    ///   <item><term>A blueprint reference</term></item>
    ///   <item><term>A blueprint id as a string, Guid, or BlueprintGuid</term></item>
    ///   <item><term>A blueprint name registered with <see cref="BlueprintCore.Utils.BlueprintTool">BlueprintTool</see></term></item>
    /// </list>
    /// See <see cref="BlueprintCore.Utils.Blueprint{{T, TRef}}">Blueprint</see> for more details.
    /// </para>
    /// </param>
    /// <param name="archetypes">
    /// <para>
    /// Blueprint of type BlueprintArchetype. You can pass in the blueprint using:
    /// <list type ="bullet">
    ///   <item><term>A blueprint instance</term></item>
    ///   <item><term>A blueprint reference</term></item>
    ///   <item><term>A blueprint id as a string, Guid, or BlueprintGuid</term></item>
    ///   <item><term>A blueprint name registered with <see cref="BlueprintCore.Utils.BlueprintTool">BlueprintTool</see></term></item>
    /// </list>
    /// See <see cref="BlueprintCore.Utils.Blueprint{{T, TRef}}">Blueprint</see> for more details.
    /// </para>
    /// </param>
    /// <param name="characterClass">
    /// <para>
    /// Blueprint of type BlueprintCharacterClass. You can pass in the blueprint using:
    /// <list type ="bullet">
    ///   <item><term>A blueprint instance</term></item>
    ///   <item><term>A blueprint reference</term></item>
    ///   <item><term>A blueprint id as a string, Guid, or BlueprintGuid</term></item>
    ///   <item><term>A blueprint name registered with <see cref="BlueprintCore.Utils.BlueprintTool">BlueprintTool</see></term></item>
    /// </list>
    /// See <see cref="BlueprintCore.Utils.Blueprint{{T, TRef}}">Blueprint</see> for more details.
    /// </para>
    /// </param>
    /// <param name="merge">
    /// If mergeBehavior is ComponentMerge.Merge and the component already exists, this expression is called to merge the components.
    /// </param>
    /// <param name="mergeBehavior">
    /// Handling if the component already exists since the component is unique. Defaults to ComponentMerge.Fail.
    /// </param>
    public TBuilder AddBindAbilitiesToClass(
        List<Blueprint<BlueprintAbility, BlueprintAbilityReference>>? abilites = null,
        List<Blueprint<BlueprintCharacterClass, BlueprintCharacterClassReference>>? additionalClasses = null,
        List<Blueprint<BlueprintArchetype, BlueprintArchetypeReference>>? archetypes = null,
        bool? cantrip = null,
        Blueprint<BlueprintCharacterClass, BlueprintCharacterClassReference>? characterClass = null,
        bool? fullCasterChecks = null,
        int? levelStep = null,
        Action<BlueprintComponent, BlueprintComponent>? merge = null,
        ComponentMerge mergeBehavior = ComponentMerge.Merge,
        bool? odd = null,
        StatType? stat = null)
    {
      var component = new BindAbilitiesToClass();
      component.m_Abilites = abilites?.Select(bp => bp.Reference)?.ToArray() ?? component.m_Abilites;
      if (component.m_Abilites is null)
      {
        component.m_Abilites = new BlueprintAbilityReference[0];
      }
      component.m_AdditionalClasses = additionalClasses?.Select(bp => bp.Reference)?.ToArray() ?? component.m_AdditionalClasses;
      if (component.m_AdditionalClasses is null)
      {
        component.m_AdditionalClasses = new BlueprintCharacterClassReference[0];
      }
      component.m_Archetypes = archetypes?.Select(bp => bp.Reference)?.ToArray() ?? component.m_Archetypes;
      if (component.m_Archetypes is null)
      {
        component.m_Archetypes = new BlueprintArchetypeReference[0];
      }
      component.Cantrip = cantrip ?? component.Cantrip;
      component.m_CharacterClass = characterClass?.Reference ?? component.m_CharacterClass;
      if (component.m_CharacterClass is null)
      {
        component.m_CharacterClass = BlueprintTool.GetRef<BlueprintCharacterClassReference>(null);
      }
      component.FullCasterChecks = fullCasterChecks ?? component.FullCasterChecks;
      component.LevelStep = levelStep ?? component.LevelStep;
      component.Odd = odd ?? component.Odd;
      component.Stat = stat ?? component.Stat;
      return AddUniqueComponent(component, mergeBehavior, merge);
    }

    /// <summary>
    /// Adds <see cref="BindAbilitiesToHighest"/>
    /// </summary>
    ///
    /// <remarks>
    ///
    /// <list type="bullet">
    /// <listheader>Used by</listheader>
    /// <item><term>FireStaffFeature</term><description>00c65aede167c514495e1f7bcd3aa674</description></item>
    /// </list>
    /// </remarks>
    ///
    /// <param name="abilities">
    /// <para>
    /// Blueprint of type BlueprintAbility. You can pass in the blueprint using:
    /// <list type ="bullet">
    ///   <item><term>A blueprint instance</term></item>
    ///   <item><term>A blueprint reference</term></item>
    ///   <item><term>A blueprint id as a string, Guid, or BlueprintGuid</term></item>
    ///   <item><term>A blueprint name registered with <see cref="BlueprintCore.Utils.BlueprintTool">BlueprintTool</see></term></item>
    /// </list>
    /// See <see cref="BlueprintCore.Utils.Blueprint{{T, TRef}}">Blueprint</see> for more details.
    /// </para>
    /// </param>
    /// <param name="merge">
    /// If mergeBehavior is ComponentMerge.Merge and the component already exists, this expression is called to merge the components.
    /// </param>
    /// <param name="mergeBehavior">
    /// Handling if the component already exists since the component is unique. Defaults to ComponentMerge.Fail.
    /// </param>
    public TBuilder AddBindAbilitiesToHighest(
        List<Blueprint<BlueprintAbility, BlueprintAbilityReference>>? abilities = null,
        Action<BlueprintComponent, BlueprintComponent>? merge = null,
        ComponentMerge mergeBehavior = ComponentMerge.Merge)
    {
      var component = new BindAbilitiesToHighest();
      component.m_Abilities = abilities?.Select(bp => bp.Reference)?.ToArray() ?? component.m_Abilities;
      if (component.m_Abilities is null)
      {
        component.m_Abilities = new BlueprintAbilityReference[0];
      }
      return AddUniqueComponent(component, mergeBehavior, merge);
    }

    /// <summary>
    /// Adds <see cref="BlindnessACCompensation"/>
    /// </summary>
    ///
    /// <remarks>
    ///
    /// <list type="bullet">
    /// <listheader>Used by</listheader>
    /// <item><term>BlindFight</term><description>4e219f5894ad0ea4daa0699e28c37b1d</description></item>
    /// <item><term>BlindFightGreater</term><description>80a50d9744a40ac4c96e2cc6451a6703</description></item>
    /// <item><term>BlindFightImproved</term><description>4f1a78b02ac71bd4fa7d6e011d6f8ce0</description></item>
    /// </list>
    /// </remarks>
    public TBuilder AddBlindnessACCompensation()
    {
      return AddComponent(new BlindnessACCompensation());
    }

    /// <summary>
    /// Adds <see cref="Blindsense"/>
    /// </summary>
    ///
    /// <remarks>
    ///
    /// <list type="bullet">
    /// <listheader>Used by</listheader>
    /// <item><term>Blindsight</term><description>236ec7f226d3d784884f066aa4be1570</description></item>
    /// <item><term>FormOfTheDragonIIIGreenBuff</term><description>2d294863adf81f944a7558f7ae248448</description></item>
    /// <item><term>WatchmanFeature</term><description>a0bf73f355bbeaa4dba2cd39132753cd</description></item>
    /// </list>
    /// </remarks>
    public TBuilder AddBlindsense(
        bool? blindsight = null,
        UnitConditionExceptions? exceptions = null,
        Feet? range = null)
    {
      var component = new Blindsense();
      component.Blindsight = blindsight ?? component.Blindsight;
      Validate(exceptions);
      component.Exceptions = exceptions ?? component.Exceptions;
      component.Range = range ?? component.Range;
      return AddComponent(component);
    }

    /// <summary>
    /// Adds <see cref="BuffSubstitutionOnApply"/>
    /// </summary>
    ///
    /// <remarks>
    ///
    /// <para>
    /// ComponentName: Apply fact of event of applying another fact
    /// </para>
    ///
    /// <list type="bullet">
    /// <listheader>Used by</listheader>
    /// <item><term>CravenHalfling</term><description>889fa46af27148f9b9aefa27b7a29a2e</description></item>
    /// <item><term>HermitKnightBracersFeature</term><description>489fd6aff7ad28d4699718392397fb2e</description></item>
    /// <item><term>Unstoppable</term><description>74afc3465db56924c9618a42d84efab8</description></item>
    /// </list>
    /// </remarks>
    ///
    /// <param name="gainedFact">
    /// <para>
    /// Blueprint of type BlueprintBuff. You can pass in the blueprint using:
    /// <list type ="bullet">
    ///   <item><term>A blueprint instance</term></item>
    ///   <item><term>A blueprint reference</term></item>
    ///   <item><term>A blueprint id as a string, Guid, or BlueprintGuid</term></item>
    ///   <item><term>A blueprint name registered with <see cref="BlueprintCore.Utils.BlueprintTool">BlueprintTool</see></term></item>
    /// </list>
    /// See <see cref="BlueprintCore.Utils.Blueprint{{T, TRef}}">Blueprint</see> for more details.
    /// </para>
    /// </param>
    /// <param name="merge">
    /// If mergeBehavior is ComponentMerge.Merge and the component already exists, this expression is called to merge the components.
    /// </param>
    /// <param name="mergeBehavior">
    /// Handling if the component already exists since the component is unique. Defaults to ComponentMerge.Fail.
    /// </param>
    /// <param name="substituteBuff">
    /// <para>
    /// Blueprint of type BlueprintBuff. You can pass in the blueprint using:
    /// <list type ="bullet">
    ///   <item><term>A blueprint instance</term></item>
    ///   <item><term>A blueprint reference</term></item>
    ///   <item><term>A blueprint id as a string, Guid, or BlueprintGuid</term></item>
    ///   <item><term>A blueprint name registered with <see cref="BlueprintCore.Utils.BlueprintTool">BlueprintTool</see></term></item>
    /// </list>
    /// See <see cref="BlueprintCore.Utils.Blueprint{{T, TRef}}">Blueprint</see> for more details.
    /// </para>
    /// </param>
    public TBuilder AddBuffSubstitutionOnApply(
        bool? checkDescriptor = null,
        Blueprint<BlueprintBuff, BlueprintBuffReference>? gainedFact = null,
        Action<BlueprintComponent, BlueprintComponent>? merge = null,
        ComponentMerge mergeBehavior = ComponentMerge.Merge,
        SpellDescriptorWrapper? spellDescriptor = null,
        Blueprint<BlueprintBuff, BlueprintBuffReference>? substituteBuff = null)
    {
      var component = new BuffSubstitutionOnApply();
      component.CheckDescriptor = checkDescriptor ?? component.CheckDescriptor;
      component.m_GainedFact = gainedFact?.Reference ?? component.m_GainedFact;
      if (component.m_GainedFact is null)
      {
        component.m_GainedFact = BlueprintTool.GetRef<BlueprintBuffReference>(null);
      }
      component.SpellDescriptor = spellDescriptor ?? component.SpellDescriptor;
      component.m_SubstituteBuff = substituteBuff?.Reference ?? component.m_SubstituteBuff;
      if (component.m_SubstituteBuff is null)
      {
        component.m_SubstituteBuff = BlueprintTool.GetRef<BlueprintBuffReference>(null);
      }
      return AddUniqueComponent(component, mergeBehavior, merge);
    }

    /// <summary>
    /// Adds <see cref="CMBBonus"/>
    /// </summary>
    ///
    /// <remarks>
    ///
    /// <list type="bullet">
    /// <listheader>Used by</listheader>
    /// <item><term>StudentOfWarKnowYourEnemyTacticalStanceBuff</term><description>61d4fb7720e25b3498c93043d369c35a</description></item>
    /// </list>
    /// </remarks>
    ///
    /// <param name="checkedFact">
    /// <para>
    /// Blueprint of type BlueprintUnitFact. You can pass in the blueprint using:
    /// <list type ="bullet">
    ///   <item><term>A blueprint instance</term></item>
    ///   <item><term>A blueprint reference</term></item>
    ///   <item><term>A blueprint id as a string, Guid, or BlueprintGuid</term></item>
    ///   <item><term>A blueprint name registered with <see cref="BlueprintCore.Utils.BlueprintTool">BlueprintTool</see></term></item>
    /// </list>
    /// See <see cref="BlueprintCore.Utils.Blueprint{{T, TRef}}">Blueprint</see> for more details.
    /// </para>
    /// </param>
    /// <param name="merge">
    /// If mergeBehavior is ComponentMerge.Merge and the component already exists, this expression is called to merge the components.
    /// </param>
    /// <param name="mergeBehavior">
    /// Handling if the component already exists since the component is unique. Defaults to ComponentMerge.Fail.
    /// </param>
    public TBuilder AddCMBBonus(
        Blueprint<BlueprintUnitFact, BlueprintUnitFactReference>? checkedFact = null,
        bool? checkFact = null,
        ModifierDescriptor? descriptor = null,
        Action<BlueprintComponent, BlueprintComponent>? merge = null,
        ComponentMerge mergeBehavior = ComponentMerge.Merge,
        ContextValue? value = null)
    {
      var component = new CMBBonus();
      component.m_CheckedFact = checkedFact?.Reference ?? component.m_CheckedFact;
      if (component.m_CheckedFact is null)
      {
        component.m_CheckedFact = BlueprintTool.GetRef<BlueprintUnitFactReference>(null);
      }
      component.CheckFact = checkFact ?? component.CheckFact;
      component.Descriptor = descriptor ?? component.Descriptor;
      component.Value = value ?? component.Value;
      if (component.Value is null)
      {
        component.Value = ContextValues.Constant(0);
      }
      return AddUniqueComponent(component, mergeBehavior, merge);
    }

    /// <summary>
    /// Adds <see cref="CMBBonusAgainstSize"/>
    /// </summary>
    ///
    /// <remarks>
    ///
    /// <list type="bullet">
    /// <listheader>Used by</listheader>
    /// <item><term>BardingOfElderBeastsFeature</term><description>b94875a04bf8df44494f810b7b240940</description></item>
    /// <item><term>SpawnSlayerGainLeverage</term><description>c14f5310a3a8fd84f868c65135708a31</description></item>
    /// </list>
    /// </remarks>
    ///
    /// <param name="checkedFact">
    /// <para>
    /// Blueprint of type BlueprintUnitFact. You can pass in the blueprint using:
    /// <list type ="bullet">
    ///   <item><term>A blueprint instance</term></item>
    ///   <item><term>A blueprint reference</term></item>
    ///   <item><term>A blueprint id as a string, Guid, or BlueprintGuid</term></item>
    ///   <item><term>A blueprint name registered with <see cref="BlueprintCore.Utils.BlueprintTool">BlueprintTool</see></term></item>
    /// </list>
    /// See <see cref="BlueprintCore.Utils.Blueprint{{T, TRef}}">Blueprint</see> for more details.
    /// </para>
    /// </param>
    /// <param name="merge">
    /// If mergeBehavior is ComponentMerge.Merge and the component already exists, this expression is called to merge the components.
    /// </param>
    /// <param name="mergeBehavior">
    /// Handling if the component already exists since the component is unique. Defaults to ComponentMerge.Fail.
    /// </param>
    public TBuilder AddCMBBonusAgainstSize(
        Blueprint<BlueprintUnitFact, BlueprintUnitFactReference>? checkedFact = null,
        bool? checkFact = null,
        ModifierDescriptor? descriptor = null,
        Action<BlueprintComponent, BlueprintComponent>? merge = null,
        ComponentMerge mergeBehavior = ComponentMerge.Merge,
        Size? size = null,
        ContextValue? value = null)
    {
      var component = new CMBBonusAgainstSize();
      component.m_CheckedFact = checkedFact?.Reference ?? component.m_CheckedFact;
      if (component.m_CheckedFact is null)
      {
        component.m_CheckedFact = BlueprintTool.GetRef<BlueprintUnitFactReference>(null);
      }
      component.CheckFact = checkFact ?? component.CheckFact;
      component.Descriptor = descriptor ?? component.Descriptor;
      component.Size = size ?? component.Size;
      component.Value = value ?? component.Value;
      if (component.Value is null)
      {
        component.Value = ContextValues.Constant(0);
      }
      return AddUniqueComponent(component, mergeBehavior, merge);
    }

    /// <summary>
    /// Adds <see cref="CMBBonusForManeuver"/>
    /// </summary>
    ///
    /// <remarks>
    ///
    /// <list type="bullet">
    /// <listheader>Used by</listheader>
    /// <item><term>Abrikandilu_Feature_DestructiveAttacks</term><description>e2f2dbb45d753f74fbe15f7ac9562be8</description></item>
    /// <item><term>OracleRevelationManeuverMasteryDirtyTrickBuff</term><description>7b1acc94ff9b2564f9d6436b37424dea</description></item>
    /// <item><term>OrderOfThePawCanineFerocityBuff</term><description>a4a2a29970e84e89b612830b0c2a9f83</description></item>
    /// </list>
    /// </remarks>
    ///
    /// <param name="checkedFact">
    /// <para>
    /// Blueprint of type BlueprintUnitFact. You can pass in the blueprint using:
    /// <list type ="bullet">
    ///   <item><term>A blueprint instance</term></item>
    ///   <item><term>A blueprint reference</term></item>
    ///   <item><term>A blueprint id as a string, Guid, or BlueprintGuid</term></item>
    ///   <item><term>A blueprint name registered with <see cref="BlueprintCore.Utils.BlueprintTool">BlueprintTool</see></term></item>
    /// </list>
    /// See <see cref="BlueprintCore.Utils.Blueprint{{T, TRef}}">Blueprint</see> for more details.
    /// </para>
    /// </param>
    /// <param name="merge">
    /// If mergeBehavior is ComponentMerge.Merge and the component already exists, this expression is called to merge the components.
    /// </param>
    /// <param name="mergeBehavior">
    /// Handling if the component already exists since the component is unique. Defaults to ComponentMerge.Fail.
    /// </param>
    public TBuilder AddCMBBonusForManeuver(
        Blueprint<BlueprintUnitFact, BlueprintUnitFactReference>? checkedFact = null,
        bool? checkFact = null,
        ModifierDescriptor? descriptor = null,
        CombatManeuver[]? maneuvers = null,
        Action<BlueprintComponent, BlueprintComponent>? merge = null,
        ComponentMerge mergeBehavior = ComponentMerge.Merge,
        ContextValue? value = null)
    {
      var component = new CMBBonusForManeuver();
      component.m_CheckedFact = checkedFact?.Reference ?? component.m_CheckedFact;
      if (component.m_CheckedFact is null)
      {
        component.m_CheckedFact = BlueprintTool.GetRef<BlueprintUnitFactReference>(null);
      }
      component.CheckFact = checkFact ?? component.CheckFact;
      component.Descriptor = descriptor ?? component.Descriptor;
      component.Maneuvers = maneuvers ?? component.Maneuvers;
      if (component.Maneuvers is null)
      {
        component.Maneuvers = new CombatManeuver[0];
      }
      component.Value = value ?? component.Value;
      if (component.Value is null)
      {
        component.Value = ContextValues.Constant(0);
      }
      return AddUniqueComponent(component, mergeBehavior, merge);
    }

    /// <summary>
    /// Adds <see cref="CMDBonus"/>
    /// </summary>
    ///
    /// <remarks>
    ///
    /// <list type="bullet">
    /// <listheader>Used by</listheader>
    /// <item><term>StudentOfWarKnowYourEnemyTacticalStanceBuff</term><description>61d4fb7720e25b3498c93043d369c35a</description></item>
    /// </list>
    /// </remarks>
    ///
    /// <param name="checkedFact">
    /// <para>
    /// Blueprint of type BlueprintUnitFact. You can pass in the blueprint using:
    /// <list type ="bullet">
    ///   <item><term>A blueprint instance</term></item>
    ///   <item><term>A blueprint reference</term></item>
    ///   <item><term>A blueprint id as a string, Guid, or BlueprintGuid</term></item>
    ///   <item><term>A blueprint name registered with <see cref="BlueprintCore.Utils.BlueprintTool">BlueprintTool</see></term></item>
    /// </list>
    /// See <see cref="BlueprintCore.Utils.Blueprint{{T, TRef}}">Blueprint</see> for more details.
    /// </para>
    /// </param>
    /// <param name="merge">
    /// If mergeBehavior is ComponentMerge.Merge and the component already exists, this expression is called to merge the components.
    /// </param>
    /// <param name="mergeBehavior">
    /// Handling if the component already exists since the component is unique. Defaults to ComponentMerge.Fail.
    /// </param>
    public TBuilder AddCMDBonus(
        Blueprint<BlueprintUnitFact, BlueprintUnitFactReference>? checkedFact = null,
        bool? checkFact = null,
        ModifierDescriptor? descriptor = null,
        Action<BlueprintComponent, BlueprintComponent>? merge = null,
        ComponentMerge mergeBehavior = ComponentMerge.Merge,
        bool? onCaster = null,
        ContextValue? value = null)
    {
      var component = new CMDBonus();
      component.m_CheckedFact = checkedFact?.Reference ?? component.m_CheckedFact;
      if (component.m_CheckedFact is null)
      {
        component.m_CheckedFact = BlueprintTool.GetRef<BlueprintUnitFactReference>(null);
      }
      component.CheckFact = checkFact ?? component.CheckFact;
      component.Descriptor = descriptor ?? component.Descriptor;
      component.OnCaster = onCaster ?? component.OnCaster;
      component.Value = value ?? component.Value;
      if (component.Value is null)
      {
        component.Value = ContextValues.Constant(0);
      }
      return AddUniqueComponent(component, mergeBehavior, merge);
    }

    /// <summary>
    /// Adds <see cref="CMDBonusAgainstManeuvers"/>
    /// </summary>
    ///
    /// <remarks>
    ///
    /// <list type="bullet">
    /// <listheader>Used by</listheader>
    /// <item><term>AnimalCompanionUnitArmoredPony_ForNPC</term><description>6da038f9c2364ffbb863938b6fb0c50e</description></item>
    /// <item><term>AnimalCompanionUnitHorseArmyPaladinCavalry_Large</term><description>77f9914fa25e4d9eb6d71070fc2275f9</description></item>
    /// <item><term>StrengthOfStoneFeature</term><description>8e63b163f1a6a83488815e762db5e268</description></item>
    /// </list>
    /// </remarks>
    ///
    /// <param name="merge">
    /// If mergeBehavior is ComponentMerge.Merge and the component already exists, this expression is called to merge the components.
    /// </param>
    /// <param name="mergeBehavior">
    /// Handling if the component already exists since the component is unique. Defaults to ComponentMerge.Fail.
    /// </param>
    public TBuilder AddCMDBonusAgainstManeuvers(
        ModifierDescriptor? descriptor = null,
        CombatManeuver[]? maneuvers = null,
        Action<BlueprintComponent, BlueprintComponent>? merge = null,
        ComponentMerge mergeBehavior = ComponentMerge.Merge,
        ContextValue? value = null)
    {
      var component = new CMDBonusAgainstManeuvers();
      component.Descriptor = descriptor ?? component.Descriptor;
      component.Maneuvers = maneuvers ?? component.Maneuvers;
      if (component.Maneuvers is null)
      {
        component.Maneuvers = new CombatManeuver[0];
      }
      component.Value = value ?? component.Value;
      if (component.Value is null)
      {
        component.Value = ContextValues.Constant(0);
      }
      return AddUniqueComponent(component, mergeBehavior, merge);
    }

    /// <summary>
    /// Adds <see cref="CMDBonusAgainstSize"/>
    /// </summary>
    ///
    /// <remarks>
    ///
    /// <list type="bullet">
    /// <listheader>Used by</listheader>
    /// <item><term>SpawnSlayerGainLeverage</term><description>c14f5310a3a8fd84f868c65135708a31</description></item>
    /// </list>
    /// </remarks>
    ///
    /// <param name="checkedFact">
    /// <para>
    /// Blueprint of type BlueprintUnitFact. You can pass in the blueprint using:
    /// <list type ="bullet">
    ///   <item><term>A blueprint instance</term></item>
    ///   <item><term>A blueprint reference</term></item>
    ///   <item><term>A blueprint id as a string, Guid, or BlueprintGuid</term></item>
    ///   <item><term>A blueprint name registered with <see cref="BlueprintCore.Utils.BlueprintTool">BlueprintTool</see></term></item>
    /// </list>
    /// See <see cref="BlueprintCore.Utils.Blueprint{{T, TRef}}">Blueprint</see> for more details.
    /// </para>
    /// </param>
    /// <param name="merge">
    /// If mergeBehavior is ComponentMerge.Merge and the component already exists, this expression is called to merge the components.
    /// </param>
    /// <param name="mergeBehavior">
    /// Handling if the component already exists since the component is unique. Defaults to ComponentMerge.Fail.
    /// </param>
    public TBuilder AddCMDBonusAgainstSize(
        Blueprint<BlueprintUnitFact, BlueprintUnitFactReference>? checkedFact = null,
        bool? checkFact = null,
        ModifierDescriptor? descriptor = null,
        Action<BlueprintComponent, BlueprintComponent>? merge = null,
        ComponentMerge mergeBehavior = ComponentMerge.Merge,
        bool? onCaster = null,
        Size? size = null,
        ContextValue? value = null)
    {
      var component = new CMDBonusAgainstSize();
      component.m_CheckedFact = checkedFact?.Reference ?? component.m_CheckedFact;
      if (component.m_CheckedFact is null)
      {
        component.m_CheckedFact = BlueprintTool.GetRef<BlueprintUnitFactReference>(null);
      }
      component.CheckFact = checkFact ?? component.CheckFact;
      component.Descriptor = descriptor ?? component.Descriptor;
      component.OnCaster = onCaster ?? component.OnCaster;
      component.Size = size ?? component.Size;
      component.Value = value ?? component.Value;
      if (component.Value is null)
      {
        component.Value = ContextValues.Constant(0);
      }
      return AddUniqueComponent(component, mergeBehavior, merge);
    }

    /// <summary>
    /// Adds <see cref="CavalierMountedMastery"/>
    /// </summary>
    ///
    /// <remarks>
    ///
    /// <list type="bullet">
    /// <listheader>Used by</listheader>
    /// <item><term>CavalierMountedMastery</term><description>fde5b47705ea18444947633c5f025703</description></item>
    /// </list>
    /// </remarks>
    ///
    /// <param name="merge">
    /// If mergeBehavior is ComponentMerge.Merge and the component already exists, this expression is called to merge the components.
    /// </param>
    /// <param name="mergeBehavior">
    /// Handling if the component already exists since the component is unique. Defaults to ComponentMerge.Fail.
    /// </param>
    public TBuilder AddCavalierMountedMastery(
        ModifierDescriptor? descriptor = null,
        Action<BlueprintComponent, BlueprintComponent>? merge = null,
        ComponentMerge mergeBehavior = ComponentMerge.Merge)
    {
      var component = new CavalierMountedMastery();
      component.Descriptor = descriptor ?? component.Descriptor;
      return AddUniqueComponent(component, mergeBehavior, merge);
    }

    /// <summary>
    /// Adds <see cref="CavalierRetribution"/>
    /// </summary>
    ///
    /// <remarks>
    ///
    /// <list type="bullet">
    /// <listheader>Used by</listheader>
    /// <item><term>CavalierRetribution</term><description>bb1487fcae090c446aff904b0980347c</description></item>
    /// </list>
    /// </remarks>
    ///
    /// <param name="buff">
    /// <para>
    /// Blueprint of type BlueprintBuff. You can pass in the blueprint using:
    /// <list type ="bullet">
    ///   <item><term>A blueprint instance</term></item>
    ///   <item><term>A blueprint reference</term></item>
    ///   <item><term>A blueprint id as a string, Guid, or BlueprintGuid</term></item>
    ///   <item><term>A blueprint name registered with <see cref="BlueprintCore.Utils.BlueprintTool">BlueprintTool</see></term></item>
    /// </list>
    /// See <see cref="BlueprintCore.Utils.Blueprint{{T, TRef}}">Blueprint</see> for more details.
    /// </para>
    /// </param>
    /// <param name="merge">
    /// If mergeBehavior is ComponentMerge.Merge and the component already exists, this expression is called to merge the components.
    /// </param>
    /// <param name="mergeBehavior">
    /// Handling if the component already exists since the component is unique. Defaults to ComponentMerge.Fail.
    /// </param>
    public TBuilder AddCavalierRetribution(
        Blueprint<BlueprintBuff, BlueprintBuffReference>? buff = null,
        Action<BlueprintComponent, BlueprintComponent>? merge = null,
        ComponentMerge mergeBehavior = ComponentMerge.Merge)
    {
      var component = new CavalierRetribution();
      component.m_Buff = buff?.Reference ?? component.m_Buff;
      if (component.m_Buff is null)
      {
        component.m_Buff = BlueprintTool.GetRef<BlueprintBuffReference>(null);
      }
      return AddUniqueComponent(component, mergeBehavior, merge);
    }

    /// <summary>
    /// Adds <see cref="CavalierStandAgainstDarkness"/>
    /// </summary>
    ///
    /// <remarks>
    ///
    /// <list type="bullet">
    /// <listheader>Used by</listheader>
    /// <item><term>CavalierStandAgainstDarkness</term><description>323fb6a07905bbd4b9b73906fc4f6534</description></item>
    /// </list>
    /// </remarks>
    ///
    /// <param name="checkedFact">
    /// <para>
    /// Blueprint of type BlueprintUnitFact. You can pass in the blueprint using:
    /// <list type ="bullet">
    ///   <item><term>A blueprint instance</term></item>
    ///   <item><term>A blueprint reference</term></item>
    ///   <item><term>A blueprint id as a string, Guid, or BlueprintGuid</term></item>
    ///   <item><term>A blueprint name registered with <see cref="BlueprintCore.Utils.BlueprintTool">BlueprintTool</see></term></item>
    /// </list>
    /// See <see cref="BlueprintCore.Utils.Blueprint{{T, TRef}}">Blueprint</see> for more details.
    /// </para>
    /// </param>
    /// <param name="merge">
    /// If mergeBehavior is ComponentMerge.Merge and the component already exists, this expression is called to merge the components.
    /// </param>
    /// <param name="mergeBehavior">
    /// Handling if the component already exists since the component is unique. Defaults to ComponentMerge.Fail.
    /// </param>
    public TBuilder AddCavalierStandAgainstDarkness(
        Blueprint<BlueprintUnitFact, BlueprintUnitFactReference>? checkedFact = null,
        Action<BlueprintComponent, BlueprintComponent>? merge = null,
        ComponentMerge mergeBehavior = ComponentMerge.Merge)
    {
      var component = new CavalierStandAgainstDarkness();
      component.m_CheckedFact = checkedFact?.Reference ?? component.m_CheckedFact;
      if (component.m_CheckedFact is null)
      {
        component.m_CheckedFact = BlueprintTool.GetRef<BlueprintUnitFactReference>(null);
      }
      return AddUniqueComponent(component, mergeBehavior, merge);
    }

    /// <summary>
    /// Adds <see cref="CavalierStealGlory"/>
    /// </summary>
    ///
    /// <remarks>
    ///
    /// <list type="bullet">
    /// <listheader>Used by</listheader>
    /// <item><term>CavalierStealGlory</term><description>2f96ffadc3dcc5d449a022c7dc537c05</description></item>
    /// </list>
    /// </remarks>
    ///
    /// <param name="merge">
    /// If mergeBehavior is ComponentMerge.Merge and the component already exists, this expression is called to merge the components.
    /// </param>
    /// <param name="mergeBehavior">
    /// Handling if the component already exists since the component is unique. Defaults to ComponentMerge.Fail.
    /// </param>
    public TBuilder AddCavalierStealGlory(
        Action<BlueprintComponent, BlueprintComponent>? merge = null,
        ComponentMerge mergeBehavior = ComponentMerge.Merge)
    {
      var component = new CavalierStealGlory();
      return AddUniqueComponent(component, mergeBehavior, merge);
    }

    /// <summary>
    /// Adds <see cref="ChargeAttackBonus"/>
    /// </summary>
    ///
    /// <remarks>
    ///
    /// <list type="bullet">
    /// <listheader>Used by</listheader>
    /// <item><term>CavalierBannerBuff</term><description>4d3b79e464282af4897c1d860bf9e9b3</description></item>
    /// </list>
    /// </remarks>
    ///
    /// <param name="merge">
    /// If mergeBehavior is ComponentMerge.Merge and the component already exists, this expression is called to merge the components.
    /// </param>
    /// <param name="mergeBehavior">
    /// Handling if the component already exists since the component is unique. Defaults to ComponentMerge.Fail.
    /// </param>
    public TBuilder AddChargeAttackBonus(
        ContextValue? bonus = null,
        bool? checkWielder = null,
        ModifierDescriptor? descriptor = null,
        Action<BlueprintComponent, BlueprintComponent>? merge = null,
        ComponentMerge mergeBehavior = ComponentMerge.Merge)
    {
      var component = new ChargeAttackBonus();
      component.Bonus = bonus ?? component.Bonus;
      if (component.Bonus is null)
      {
        component.Bonus = ContextValues.Constant(0);
      }
      component.CheckWielder = checkWielder ?? component.CheckWielder;
      component.Descriptor = descriptor ?? component.Descriptor;
      return AddUniqueComponent(component, mergeBehavior, merge);
    }

    /// <summary>
    /// Adds <see cref="ChargeImprovedCritical"/>
    /// </summary>
    ///
    /// <remarks>
    ///
    /// <list type="bullet">
    /// <listheader>Used by</listheader>
    /// <item><term>CavalierMightyChargeCheckBuff</term><description>c7f20be24b1545b08951bb668d8708b1</description></item>
    /// </list>
    /// </remarks>
    ///
    /// <param name="merge">
    /// If mergeBehavior is ComponentMerge.Merge and the component already exists, this expression is called to merge the components.
    /// </param>
    /// <param name="mergeBehavior">
    /// Handling if the component already exists since the component is unique. Defaults to ComponentMerge.Fail.
    /// </param>
    public TBuilder AddChargeImprovedCritical(
        Action<BlueprintComponent, BlueprintComponent>? merge = null,
        ComponentMerge mergeBehavior = ComponentMerge.Merge)
    {
      var component = new ChargeImprovedCritical();
      return AddUniqueComponent(component, mergeBehavior, merge);
    }

    /// <summary>
    /// Adds <see cref="ClassLevelsForPrerequisites"/>
    /// </summary>
    ///
    /// <remarks>
    ///
    /// <para>
    /// ComponentName: Add ability resources
    /// </para>
    ///
    /// <list type="bullet">
    /// <listheader>Used by</listheader>
    /// <item><term>EldritchKnightDiverseTraining</term><description>983e8ad193160b44da80b38af4927e75</description></item>
    /// <item><term>FighterTraining</term><description>2b636b9e8dd7df94cbd372c52237eebf</description></item>
    /// <item><term>WarpriestClassAsBABFeature</term><description>2e134d80fef14a44aae9c087215c15af</description></item>
    /// </list>
    /// </remarks>
    ///
    /// <param name="actualClass">
    /// <para>
    /// Blueprint of type BlueprintCharacterClass. You can pass in the blueprint using:
    /// <list type ="bullet">
    ///   <item><term>A blueprint instance</term></item>
    ///   <item><term>A blueprint reference</term></item>
    ///   <item><term>A blueprint id as a string, Guid, or BlueprintGuid</term></item>
    ///   <item><term>A blueprint name registered with <see cref="BlueprintCore.Utils.BlueprintTool">BlueprintTool</see></term></item>
    /// </list>
    /// See <see cref="BlueprintCore.Utils.Blueprint{{T, TRef}}">Blueprint</see> for more details.
    /// </para>
    /// </param>
    /// <param name="fakeClass">
    /// <para>
    /// Blueprint of type BlueprintCharacterClass. You can pass in the blueprint using:
    /// <list type ="bullet">
    ///   <item><term>A blueprint instance</term></item>
    ///   <item><term>A blueprint reference</term></item>
    ///   <item><term>A blueprint id as a string, Guid, or BlueprintGuid</term></item>
    ///   <item><term>A blueprint name registered with <see cref="BlueprintCore.Utils.BlueprintTool">BlueprintTool</see></term></item>
    /// </list>
    /// See <see cref="BlueprintCore.Utils.Blueprint{{T, TRef}}">Blueprint</see> for more details.
    /// </para>
    /// </param>
    /// <param name="merge">
    /// If mergeBehavior is ComponentMerge.Merge and the component already exists, this expression is called to merge the components.
    /// </param>
    /// <param name="mergeBehavior">
    /// Handling if the component already exists since the component is unique. Defaults to ComponentMerge.Fail.
    /// </param>
    public TBuilder AddClassLevelsForPrerequisites(
        Blueprint<BlueprintCharacterClass, BlueprintCharacterClassReference>? actualClass = null,
        Blueprint<BlueprintCharacterClass, BlueprintCharacterClassReference>? fakeClass = null,
        Action<BlueprintComponent, BlueprintComponent>? merge = null,
        ComponentMerge mergeBehavior = ComponentMerge.Merge,
        double? modifier = null,
        int? summand = null)
    {
      var component = new ClassLevelsForPrerequisites();
      component.m_ActualClass = actualClass?.Reference ?? component.m_ActualClass;
      if (component.m_ActualClass is null)
      {
        component.m_ActualClass = BlueprintTool.GetRef<BlueprintCharacterClassReference>(null);
      }
      component.m_FakeClass = fakeClass?.Reference ?? component.m_FakeClass;
      if (component.m_FakeClass is null)
      {
        component.m_FakeClass = BlueprintTool.GetRef<BlueprintCharacterClassReference>(null);
      }
      component.Modifier = modifier ?? component.Modifier;
      component.Summand = summand ?? component.Summand;
      return AddUniqueComponent(component, mergeBehavior, merge);
    }

    /// <summary>
    /// Adds <see cref="CombatAgainstMeTrigger"/>
    /// </summary>
    ///
    /// <remarks>
    ///
    /// <list type="bullet">
    /// <listheader>Used by</listheader>
    /// <item><term>TricksterPersuasionTier1Feature</term><description>4eefa883f5908a347a0b0a891fb859dd</description></item>
    /// </list>
    /// </remarks>
    public TBuilder AddCombatAgainstMeTrigger(
        ActionsBuilder? combatEndActions = null,
        ActionsBuilder? combatStartActions = null)
    {
      var component = new CombatAgainstMeTrigger();
      component.CombatEndActions = combatEndActions?.Build() ?? component.CombatEndActions;
      if (component.CombatEndActions is null)
      {
        component.CombatEndActions = Utils.Constants.Empty.Actions;
      }
      component.CombatStartActions = combatStartActions?.Build() ?? component.CombatStartActions;
      if (component.CombatStartActions is null)
      {
        component.CombatStartActions = Utils.Constants.Empty.Actions;
      }
      return AddComponent(component);
    }

    /// <summary>
    /// Adds <see cref="CombatStateTrigger"/>
    /// </summary>
    ///
    /// <remarks>
    ///
    /// <list type="bullet">
    /// <listheader>Used by</listheader>
    /// <item><term>AdaptiveTactics</term><description>e01152417a8ac2248b4f69711b819441</description></item>
    /// <item><term>HermitRevelationReclusesStride5</term><description>3ba547071772fe9489128ca3b0270308</description></item>
    /// <item><term>ZeorisDaggerRing_BetrayalEnemyFeature</term><description>1a695b8dfffc46f7a74527e510fd452b</description></item>
    /// </list>
    /// </remarks>
    public TBuilder AddCombatStateTrigger(
        ActionsBuilder? combatEndActions = null,
        ActionsBuilder? combatStartActions = null)
    {
      var component = new CombatStateTrigger();
      component.CombatEndActions = combatEndActions?.Build() ?? component.CombatEndActions;
      if (component.CombatEndActions is null)
      {
        component.CombatEndActions = Utils.Constants.Empty.Actions;
      }
      component.CombatStartActions = combatStartActions?.Build() ?? component.CombatStartActions;
      if (component.CombatStartActions is null)
      {
        component.CombatStartActions = Utils.Constants.Empty.Actions;
      }
      return AddComponent(component);
    }

    /// <summary>
    /// Adds <see cref="CompanionBoon"/>
    /// </summary>
    ///
    /// <remarks>
    ///
    /// <para>
    /// ComponentName: Add feature on class level
    /// </para>
    ///
    /// <list type="bullet">
    /// <listheader>Used by</listheader>
    /// <item><term>CompanionBoon</term><description>8fc01f06eab4dd946baa5bc658cac556</description></item>
    /// </list>
    /// </remarks>
    ///
    /// <param name="merge">
    /// If mergeBehavior is ComponentMerge.Merge and the component already exists, this expression is called to merge the components.
    /// </param>
    /// <param name="mergeBehavior">
    /// Handling if the component already exists since the component is unique. Defaults to ComponentMerge.Fail.
    /// </param>
    /// <param name="rankFeature">
    /// <para>
    /// Blueprint of type BlueprintFeature. You can pass in the blueprint using:
    /// <list type ="bullet">
    ///   <item><term>A blueprint instance</term></item>
    ///   <item><term>A blueprint reference</term></item>
    ///   <item><term>A blueprint id as a string, Guid, or BlueprintGuid</term></item>
    ///   <item><term>A blueprint name registered with <see cref="BlueprintCore.Utils.BlueprintTool">BlueprintTool</see></term></item>
    /// </list>
    /// See <see cref="BlueprintCore.Utils.Blueprint{{T, TRef}}">Blueprint</see> for more details.
    /// </para>
    /// </param>
    public TBuilder AddCompanionBoon(
        int? bonus = null,
        Action<BlueprintComponent, BlueprintComponent>? merge = null,
        ComponentMerge mergeBehavior = ComponentMerge.Merge,
        Blueprint<BlueprintFeature, BlueprintFeatureReference>? rankFeature = null)
    {
      var component = new CompanionBoon();
      component.Bonus = bonus ?? component.Bonus;
      component.m_RankFeature = rankFeature?.Reference ?? component.m_RankFeature;
      if (component.m_RankFeature is null)
      {
        component.m_RankFeature = BlueprintTool.GetRef<BlueprintFeatureReference>(null);
      }
      return AddUniqueComponent(component, mergeBehavior, merge);
    }

    /// <summary>
    /// Adds <see cref="ConcentrationBonus"/>
    /// </summary>
    ///
    /// <remarks>
    ///
    /// <para>
    /// ComponentName: Attack Dice Reroll
    /// </para>
    ///
    /// <list type="bullet">
    /// <listheader>Used by</listheader>
    /// <item><term>AcornPieBuff</term><description>58879110ddb29e740acfc313e8d57d35</description></item>
    /// <item><term>GreaterSpellCombat</term><description>379887a82a7248946bbf6d0158663b5e</description></item>
    /// <item><term>WhiteroseOystersBuff</term><description>45082bf27cf15e94ca0fae92dc3db992</description></item>
    /// </list>
    /// </remarks>
    ///
    /// <param name="requiredFact">
    /// <para>
    /// Blueprint of type BlueprintUnitFact. You can pass in the blueprint using:
    /// <list type ="bullet">
    ///   <item><term>A blueprint instance</term></item>
    ///   <item><term>A blueprint reference</term></item>
    ///   <item><term>A blueprint id as a string, Guid, or BlueprintGuid</term></item>
    ///   <item><term>A blueprint name registered with <see cref="BlueprintCore.Utils.BlueprintTool">BlueprintTool</see></term></item>
    /// </list>
    /// See <see cref="BlueprintCore.Utils.Blueprint{{T, TRef}}">Blueprint</see> for more details.
    /// </para>
    /// </param>
    public TBuilder AddConcentrationBonus(
        bool? checkFact = null,
        Blueprint<BlueprintUnitFact, BlueprintUnitFactReference>? requiredFact = null,
        ContextValue? value = null)
    {
      var component = new ConcentrationBonus();
      component.CheckFact = checkFact ?? component.CheckFact;
      component.m_RequiredFact = requiredFact?.Reference ?? component.m_RequiredFact;
      if (component.m_RequiredFact is null)
      {
        component.m_RequiredFact = BlueprintTool.GetRef<BlueprintUnitFactReference>(null);
      }
      component.Value = value ?? component.Value;
      if (component.Value is null)
      {
        component.Value = ContextValues.Constant(0);
      }
      return AddComponent(component);
    }

    /// <summary>
    /// Adds <see cref="ConcentrationBonusOnArmorType"/>
    /// </summary>
    ///
    /// <remarks>
    ///
    /// <para>
    /// ComponentName: Concentration Bonus On Armor Type
    /// </para>
    ///
    /// <list type="bullet">
    /// <listheader>Used by</listheader>
    /// <item><term>ArmoredBattlemageMediumArmor</term><description>9a4287e181c450447af1a7565c1b260b</description></item>
    /// </list>
    /// </remarks>
    public TBuilder AddConcentrationBonusOnArmorType(
        ArmorProficiencyGroup? armorCategory = null,
        ContextValue? value = null)
    {
      var component = new ConcentrationBonusOnArmorType();
      component.ArmorCategory = armorCategory ?? component.ArmorCategory;
      component.Value = value ?? component.Value;
      if (component.Value is null)
      {
        component.Value = ContextValues.Constant(0);
      }
      return AddComponent(component);
    }

    /// <summary>
    /// Adds <see cref="ConstructHealth"/>
    /// </summary>
    ///
    /// <remarks>
    ///
    /// <para>
    /// ComponentName: Add hit points from size
    /// </para>
    ///
    /// <list type="bullet">
    /// <listheader>Used by</listheader>
    /// <item><term>ConstructType</term><description>fd389783027d63343b4a5634bd81645f</description></item>
    /// </list>
    /// </remarks>
    public TBuilder AddConstructHealth()
    {
      return AddComponent(new ConstructHealth());
    }

    /// <summary>
    /// Adds <see cref="ContextRendFeature"/>
    /// </summary>
    ///
    /// <remarks>
    ///
    /// <list type="bullet">
    /// <listheader>Used by</listheader>
    /// <item><term>DemonicVerminTemplate</term><description>c98d087554803054e8e1ca1d670ad9ff</description></item>
    /// </list>
    /// </remarks>
    public TBuilder AddContextRendFeature(
        DamageTypeDescription? rendType = null,
        ContextDiceValue? value = null)
    {
      var component = new ContextRendFeature();
      Validate(rendType);
      component.RendType = rendType ?? component.RendType;
      component.Value = value ?? component.Value;
      if (component.Value is null)
      {
        component.Value = Utils.Constants.Empty.DiceValue;
      }
      return AddComponent(component);
    }

    /// <summary>
    /// Adds <see cref="CoordinatedDefense"/>
    /// </summary>
    ///
    /// <remarks>
    ///
    /// <list type="bullet">
    /// <listheader>Used by</listheader>
    /// <item><term>CoordinatedDefense</term><description>992fd59da1783de49b135ad89142c6d7</description></item>
    /// </list>
    /// </remarks>
    ///
    /// <param name="coordinatedDefenseFact">
    /// <para>
    /// Blueprint of type BlueprintUnitFact. You can pass in the blueprint using:
    /// <list type ="bullet">
    ///   <item><term>A blueprint instance</term></item>
    ///   <item><term>A blueprint reference</term></item>
    ///   <item><term>A blueprint id as a string, Guid, or BlueprintGuid</term></item>
    ///   <item><term>A blueprint name registered with <see cref="BlueprintCore.Utils.BlueprintTool">BlueprintTool</see></term></item>
    /// </list>
    /// See <see cref="BlueprintCore.Utils.Blueprint{{T, TRef}}">Blueprint</see> for more details.
    /// </para>
    /// </param>
    /// <param name="merge">
    /// If mergeBehavior is ComponentMerge.Merge and the component already exists, this expression is called to merge the components.
    /// </param>
    /// <param name="mergeBehavior">
    /// Handling if the component already exists since the component is unique. Defaults to ComponentMerge.Fail.
    /// </param>
    public TBuilder AddCoordinatedDefense(
        Blueprint<BlueprintUnitFact, BlueprintUnitFactReference>? coordinatedDefenseFact = null,
        Action<BlueprintComponent, BlueprintComponent>? merge = null,
        ComponentMerge mergeBehavior = ComponentMerge.Merge,
        int? radius = null)
    {
      var component = new CoordinatedDefense();
      component.m_CoordinatedDefenseFact = coordinatedDefenseFact?.Reference ?? component.m_CoordinatedDefenseFact;
      if (component.m_CoordinatedDefenseFact is null)
      {
        component.m_CoordinatedDefenseFact = BlueprintTool.GetRef<BlueprintUnitFactReference>(null);
      }
      component.Radius = radius ?? component.Radius;
      return AddUniqueComponent(component, mergeBehavior, merge);
    }

    /// <summary>
    /// Adds <see cref="CoordinatedManeuvers"/>
    /// </summary>
    ///
    /// <remarks>
    ///
    /// <list type="bullet">
    /// <listheader>Used by</listheader>
    /// <item><term>CoordinatedManeuvers</term><description>b186cea78dce3a04aacff0a81786008c</description></item>
    /// </list>
    /// </remarks>
    ///
    /// <param name="coordinatedManeuversFact">
    /// <para>
    /// Blueprint of type BlueprintUnitFact. You can pass in the blueprint using:
    /// <list type ="bullet">
    ///   <item><term>A blueprint instance</term></item>
    ///   <item><term>A blueprint reference</term></item>
    ///   <item><term>A blueprint id as a string, Guid, or BlueprintGuid</term></item>
    ///   <item><term>A blueprint name registered with <see cref="BlueprintCore.Utils.BlueprintTool">BlueprintTool</see></term></item>
    /// </list>
    /// See <see cref="BlueprintCore.Utils.Blueprint{{T, TRef}}">Blueprint</see> for more details.
    /// </para>
    /// </param>
    /// <param name="merge">
    /// If mergeBehavior is ComponentMerge.Merge and the component already exists, this expression is called to merge the components.
    /// </param>
    /// <param name="mergeBehavior">
    /// Handling if the component already exists since the component is unique. Defaults to ComponentMerge.Fail.
    /// </param>
    public TBuilder AddCoordinatedManeuvers(
        Blueprint<BlueprintUnitFact, BlueprintUnitFactReference>? coordinatedManeuversFact = null,
        Action<BlueprintComponent, BlueprintComponent>? merge = null,
        ComponentMerge mergeBehavior = ComponentMerge.Merge,
        int? radius = null)
    {
      var component = new CoordinatedManeuvers();
      component.m_CoordinatedManeuversFact = coordinatedManeuversFact?.Reference ?? component.m_CoordinatedManeuversFact;
      if (component.m_CoordinatedManeuversFact is null)
      {
        component.m_CoordinatedManeuversFact = BlueprintTool.GetRef<BlueprintUnitFactReference>(null);
      }
      component.Radius = radius ?? component.Radius;
      return AddUniqueComponent(component, mergeBehavior, merge);
    }

    /// <summary>
    /// Adds <see cref="CraftBonus"/>
    /// </summary>
    ///
    /// <remarks>
    ///
    /// <list type="bullet">
    /// <listheader>Used by</listheader>
    /// <item><term>RingOfRenownArtisanFeature</term><description>b325d593e7ee8ea409906afd30db11d9</description></item>
    /// <item><term>UndergroundScavengerFeature</term><description>44a03874cf2ef8e4495cee3e99761e3d</description></item>
    /// </list>
    /// </remarks>
    ///
    /// <param name="merge">
    /// If mergeBehavior is ComponentMerge.Merge and the component already exists, this expression is called to merge the components.
    /// </param>
    /// <param name="mergeBehavior">
    /// Handling if the component already exists since the component is unique. Defaults to ComponentMerge.Fail.
    /// </param>
    public TBuilder AddCraftBonus(
        UsableItemType? bonusFor = null,
        Action<BlueprintComponent, BlueprintComponent>? merge = null,
        ComponentMerge mergeBehavior = ComponentMerge.Merge,
        ContextValue? value = null)
    {
      var component = new CraftBonus();
      component.m_BonusFor = bonusFor ?? component.m_BonusFor;
      component.m_Value = value ?? component.m_Value;
      if (component.m_Value is null)
      {
        component.m_Value = ContextValues.Constant(0);
      }
      return AddUniqueComponent(component, mergeBehavior, merge);
    }

    /// <summary>
    /// Adds <see cref="CritAutoconfirmAgainstAlignment"/>
    /// </summary>
    ///
    /// <remarks>
    ///
    /// <para>
    /// ComponentName: Crits against target with certain alignment are autoconfirmed
    /// </para>
    ///
    /// <list type="bullet">
    /// <listheader>Used by</listheader>
    /// <item><term>ChaosScourgeFeature</term><description>7df1da60a64d417598db94ac5f56e89a</description></item>
    /// <item><term>GreyGarrison_SuperMythicBuff</term><description>4b11247a4988c254fb9d1cd67f0b1e4a</description></item>
    /// <item><term>HavocHarbingerFeature</term><description>ec559f41dfb44c6bbd2f920a7c2cb63f</description></item>
    /// </list>
    /// </remarks>
    public TBuilder AddCritAutoconfirmAgainstAlignment(
        AlignmentComponent? enemyAlignment = null)
    {
      var component = new CritAutoconfirmAgainstAlignment();
      component.EnemyAlignment = enemyAlignment ?? component.EnemyAlignment;
      return AddComponent(component);
    }

    /// <summary>
    /// Adds <see cref="CriticalConfirmationACBonus"/>
    /// </summary>
    ///
    /// <remarks>
    ///
    /// <list type="bullet">
    /// <listheader>Used by</listheader>
    /// <item><term>HardAsStoneFeature</term><description>cc149e28ee821a942bdbb90fa80b1bc2</description></item>
    /// <item><term>OracleBattleFinalRevelation</term><description>9caa8060ec83c0842b127c318571c6d1</description></item>
    /// <item><term>ProtectVitalsEffectBuff</term><description>5b5e566167a3f2746b7d3a26bc8a50a6</description></item>
    /// </list>
    /// </remarks>
    public TBuilder AddCriticalConfirmationACBonus(
        int? bonus = null,
        ModifierDescriptor? descriptor = null,
        bool? onlyPositiveValue = null,
        ContextValue? value = null)
    {
      var component = new CriticalConfirmationACBonus();
      component.Bonus = bonus ?? component.Bonus;
      component.Descriptor = descriptor ?? component.Descriptor;
      component.OnlyPositiveValue = onlyPositiveValue ?? component.OnlyPositiveValue;
      component.Value = value ?? component.Value;
      if (component.Value is null)
      {
        component.Value = ContextValues.Constant(0);
      }
      return AddComponent(component);
    }

    /// <summary>
    /// Adds <see cref="CriticalConfirmationACBonusAgainstFactOwner"/>
    /// </summary>
    ///
    /// <remarks>
    ///
    /// <list type="bullet">
    /// <listheader>Used by</listheader>
    /// <item><term>CavalierStandAgainstDarkness</term><description>323fb6a07905bbd4b9b73906fc4f6534</description></item>
    /// </list>
    /// </remarks>
    ///
    /// <param name="checkedFact">
    /// <para>
    /// Blueprint of type BlueprintUnitFact. You can pass in the blueprint using:
    /// <list type ="bullet">
    ///   <item><term>A blueprint instance</term></item>
    ///   <item><term>A blueprint reference</term></item>
    ///   <item><term>A blueprint id as a string, Guid, or BlueprintGuid</term></item>
    ///   <item><term>A blueprint name registered with <see cref="BlueprintCore.Utils.BlueprintTool">BlueprintTool</see></term></item>
    /// </list>
    /// See <see cref="BlueprintCore.Utils.Blueprint{{T, TRef}}">Blueprint</see> for more details.
    /// </para>
    /// </param>
    public TBuilder AddCriticalConfirmationACBonusAgainstFactOwner(
        int? bonus = null,
        Blueprint<BlueprintUnitFact, BlueprintUnitFactReference>? checkedFact = null,
        ModifierDescriptor? descriptor = null,
        bool? onlyPositiveValue = null,
        ContextValue? value = null)
    {
      var component = new CriticalConfirmationACBonusAgainstFactOwner();
      component.Bonus = bonus ?? component.Bonus;
      component.m_CheckedFact = checkedFact?.Reference ?? component.m_CheckedFact;
      if (component.m_CheckedFact is null)
      {
        component.m_CheckedFact = BlueprintTool.GetRef<BlueprintUnitFactReference>(null);
      }
      component.Descriptor = descriptor ?? component.Descriptor;
      component.OnlyPositiveValue = onlyPositiveValue ?? component.OnlyPositiveValue;
      component.Value = value ?? component.Value;
      if (component.Value is null)
      {
        component.Value = ContextValues.Constant(0);
      }
      return AddComponent(component);
    }

    /// <summary>
    /// Adds <see cref="CriticalConfirmationACBonusInHeavyArmor"/>
    /// </summary>
    ///
    /// <remarks>
    ///
    /// <list type="bullet">
    /// <listheader>Used by</listheader>
    /// <item><term>ArmoredHulkResilienceOfSteel</term><description>ac8f1fcec10a9584c9e40a5cd8100830</description></item>
    /// </list>
    /// </remarks>
    public TBuilder AddCriticalConfirmationACBonusInHeavyArmor(
        int? bonus = null,
        ModifierDescriptor? descriptor = null)
    {
      var component = new CriticalConfirmationACBonusInHeavyArmor();
      component.Bonus = bonus ?? component.Bonus;
      component.Descriptor = descriptor ?? component.Descriptor;
      return AddComponent(component);
    }

    /// <summary>
    /// Adds <see cref="CriticalConfirmationBonus"/>
    /// </summary>
    ///
    /// <remarks>
    ///
    /// <list type="bullet">
    /// <listheader>Used by</listheader>
    /// <item><term>AssassinsChainshirtFeature</term><description>bb04a43775d12b344a36ae8850cefa0c</description></item>
    /// <item><term>HelmetArmagFeature</term><description>095b64f04a46d5d4c802562a9719b9f0</description></item>
    /// <item><term>TieflingHeritageDemon</term><description>c09ffb2657f6c2b41b5ed0ed607b362a</description></item>
    /// </list>
    /// </remarks>
    public TBuilder AddCriticalConfirmationBonus(
        int? bonus = null,
        bool? checkWeaponRangeType = null,
        bool? onlyPositiveValue = null,
        WeaponRangeType? type = null,
        ContextValue? value = null)
    {
      var component = new CriticalConfirmationBonus();
      component.Bonus = bonus ?? component.Bonus;
      component.CheckWeaponRangeType = checkWeaponRangeType ?? component.CheckWeaponRangeType;
      component.OnlyPositiveValue = onlyPositiveValue ?? component.OnlyPositiveValue;
      component.Type = type ?? component.Type;
      component.Value = value ?? component.Value;
      if (component.Value is null)
      {
        component.Value = ContextValues.Constant(0);
      }
      return AddComponent(component);
    }

    /// <summary>
    /// Adds <see cref="DamageBonusAgainstAlignment"/>
    /// </summary>
    ///
    /// <remarks>
    ///
    /// <list type="bullet">
    /// <listheader>Used by</listheader>
    /// <item><term>HellKnightOrderOfTheGodclawTier1Buff</term><description>7ca21c64bc506144ebf420907382480e</description></item>
    /// <item><term>HellKnightOrderOfTheGodclawTier3Buff</term><description>9ea5d02c3ce4f104488d6760b488d1ba</description></item>
    /// <item><term>ReformedFiendBloodrageBuff</term><description>72a679f712bd4f69a07bf03d5800900b</description></item>
    /// </list>
    /// </remarks>
    ///
    /// <param name="merge">
    /// If mergeBehavior is ComponentMerge.Merge and the component already exists, this expression is called to merge the components.
    /// </param>
    /// <param name="mergeBehavior">
    /// Handling if the component already exists since the component is unique. Defaults to ComponentMerge.Fail.
    /// </param>
    public TBuilder AddDamageBonusAgainstAlignment(
        AlignmentComponent? alignment = null,
        ContextValue? bonus = null,
        int? damageBonus = null,
        ModifierDescriptor? descriptor = null,
        Action<BlueprintComponent, BlueprintComponent>? merge = null,
        ComponentMerge mergeBehavior = ComponentMerge.Merge,
        bool? onlyMelee = null)
    {
      var component = new DamageBonusAgainstAlignment();
      component.Alignment = alignment ?? component.Alignment;
      component.Bonus = bonus ?? component.Bonus;
      if (component.Bonus is null)
      {
        component.Bonus = ContextValues.Constant(0);
      }
      component.DamageBonus = damageBonus ?? component.DamageBonus;
      component.Descriptor = descriptor ?? component.Descriptor;
      component.OnlyMelee = onlyMelee ?? component.OnlyMelee;
      return AddUniqueComponent(component, mergeBehavior, merge);
    }

    /// <summary>
    /// Adds <see cref="DamageBonusAgainstFactOwner"/>
    /// </summary>
    ///
    /// <remarks>
    ///
    /// <list type="bullet">
    /// <listheader>Used by</listheader>
    /// <item><term>AggressorBleedingStrike</term><description>37f3ca7f3e584a5b9edb2cad88cf5ba7</description></item>
    /// <item><term>GogglesOfPiercingGazeFeature</term><description>946b597ee9e74ce4eaacdafc73d2ec3c</description></item>
    /// <item><term>UltimatePredatorsGauntletsFeature</term><description>34de3a3c62738df4392185764bf7c980</description></item>
    /// </list>
    /// </remarks>
    ///
    /// <param name="checkedFact">
    /// <para>
    /// Blueprint of type BlueprintUnitFact. You can pass in the blueprint using:
    /// <list type ="bullet">
    ///   <item><term>A blueprint instance</term></item>
    ///   <item><term>A blueprint reference</term></item>
    ///   <item><term>A blueprint id as a string, Guid, or BlueprintGuid</term></item>
    ///   <item><term>A blueprint name registered with <see cref="BlueprintCore.Utils.BlueprintTool">BlueprintTool</see></term></item>
    /// </list>
    /// See <see cref="BlueprintCore.Utils.Blueprint{{T, TRef}}">Blueprint</see> for more details.
    /// </para>
    /// </param>
    /// <param name="merge">
    /// If mergeBehavior is ComponentMerge.Merge and the component already exists, this expression is called to merge the components.
    /// </param>
    /// <param name="mergeBehavior">
    /// Handling if the component already exists since the component is unique. Defaults to ComponentMerge.Fail.
    /// </param>
    public TBuilder AddDamageBonusAgainstFactOwner(
        ContextValue? bonus = null,
        Blueprint<BlueprintUnitFact, BlueprintUnitFactReference>? checkedFact = null,
        int? damageBonus = null,
        ModifierDescriptor? descriptor = null,
        Action<BlueprintComponent, BlueprintComponent>? merge = null,
        ComponentMerge mergeBehavior = ComponentMerge.Merge)
    {
      var component = new DamageBonusAgainstFactOwner();
      component.Bonus = bonus ?? component.Bonus;
      if (component.Bonus is null)
      {
        component.Bonus = ContextValues.Constant(0);
      }
      component.m_CheckedFact = checkedFact?.Reference ?? component.m_CheckedFact;
      if (component.m_CheckedFact is null)
      {
        component.m_CheckedFact = BlueprintTool.GetRef<BlueprintUnitFactReference>(null);
      }
      component.DamageBonus = damageBonus ?? component.DamageBonus;
      component.Descriptor = descriptor ?? component.Descriptor;
      return AddUniqueComponent(component, mergeBehavior, merge);
    }

    /// <summary>
    /// Adds <see cref="DamageBonusOrderOfCockatrice"/>
    /// </summary>
    ///
    /// <remarks>
    ///
    /// <list type="bullet">
    /// <listheader>Used by</listheader>
    /// <item><term>CavalierCockatriceChallenge</term><description>ba176bca404967b47bf9e583e80c3fd5</description></item>
    /// </list>
    /// </remarks>
    ///
    /// <param name="checkedFact">
    /// <para>
    /// Blueprint of type BlueprintUnitFact. You can pass in the blueprint using:
    /// <list type ="bullet">
    ///   <item><term>A blueprint instance</term></item>
    ///   <item><term>A blueprint reference</term></item>
    ///   <item><term>A blueprint id as a string, Guid, or BlueprintGuid</term></item>
    ///   <item><term>A blueprint name registered with <see cref="BlueprintCore.Utils.BlueprintTool">BlueprintTool</see></term></item>
    /// </list>
    /// See <see cref="BlueprintCore.Utils.Blueprint{{T, TRef}}">Blueprint</see> for more details.
    /// </para>
    /// </param>
    /// <param name="merge">
    /// If mergeBehavior is ComponentMerge.Merge and the component already exists, this expression is called to merge the components.
    /// </param>
    /// <param name="mergeBehavior">
    /// Handling if the component already exists since the component is unique. Defaults to ComponentMerge.Fail.
    /// </param>
    public TBuilder AddDamageBonusOrderOfCockatrice(
        ContextValue? bonus = null,
        Blueprint<BlueprintUnitFact, BlueprintUnitFactReference>? checkedFact = null,
        ModifierDescriptor? descriptor = null,
        Action<BlueprintComponent, BlueprintComponent>? merge = null,
        ComponentMerge mergeBehavior = ComponentMerge.Merge)
    {
      var component = new DamageBonusOrderOfCockatrice();
      component.Bonus = bonus ?? component.Bonus;
      if (component.Bonus is null)
      {
        component.Bonus = ContextValues.Constant(0);
      }
      component.m_CheckedFact = checkedFact?.Reference ?? component.m_CheckedFact;
      if (component.m_CheckedFact is null)
      {
        component.m_CheckedFact = BlueprintTool.GetRef<BlueprintUnitFactReference>(null);
      }
      component.Descriptor = descriptor ?? component.Descriptor;
      return AddUniqueComponent(component, mergeBehavior, merge);
    }

    /// <summary>
    /// Adds <see cref="DamageGrace"/>
    /// </summary>
    ///
    /// <remarks>
    ///
    /// <para>
    /// ComponentName: Replace damage stat for weapon
    /// </para>
    ///
    /// <list type="bullet">
    /// <listheader>Used by</listheader>
    /// <item><term>FencingGrace</term><description>47b352ea0f73c354aba777945760b441</description></item>
    /// <item><term>SlashingGrace</term><description>697d64669eb2c0543abb9c9b07998a38</description></item>
    /// </list>
    /// </remarks>
    ///
    /// <param name="merge">
    /// If mergeBehavior is ComponentMerge.Merge and the component already exists, this expression is called to merge the components.
    /// </param>
    /// <param name="mergeBehavior">
    /// Handling if the component already exists since the component is unique. Defaults to ComponentMerge.Fail.
    /// </param>
    public TBuilder AddDamageGrace(
        Action<BlueprintComponent, BlueprintComponent>? merge = null,
        ComponentMerge mergeBehavior = ComponentMerge.Merge)
    {
      var component = new DamageGrace();
      return AddUniqueComponent(component, mergeBehavior, merge);
    }

    /// <summary>
    /// Adds <see cref="DamageReductionAgainstFactOwner"/>
    /// </summary>
    ///
    /// <remarks>
    ///
    /// <list type="bullet">
    /// <listheader>Used by</listheader>
    /// <item><term>ArmyUnitsTormentedFeature</term><description>71aca34e66cf4fdabfac934aef4a70ed</description></item>
    /// <item><term>CapeOfDesinsectorFeature</term><description>3324580696eb62645994508ec0e4a1ad</description></item>
    /// </list>
    /// </remarks>
    ///
    /// <param name="checkedFact">
    /// <para>
    /// Blueprint of type BlueprintUnitFact. You can pass in the blueprint using:
    /// <list type ="bullet">
    ///   <item><term>A blueprint instance</term></item>
    ///   <item><term>A blueprint reference</term></item>
    ///   <item><term>A blueprint id as a string, Guid, or BlueprintGuid</term></item>
    ///   <item><term>A blueprint name registered with <see cref="BlueprintCore.Utils.BlueprintTool">BlueprintTool</see></term></item>
    /// </list>
    /// See <see cref="BlueprintCore.Utils.Blueprint{{T, TRef}}">Blueprint</see> for more details.
    /// </para>
    /// </param>
    /// <param name="merge">
    /// If mergeBehavior is ComponentMerge.Merge and the component already exists, this expression is called to merge the components.
    /// </param>
    /// <param name="mergeBehavior">
    /// Handling if the component already exists since the component is unique. Defaults to ComponentMerge.Fail.
    /// </param>
    public TBuilder AddDamageReductionAgainstFactOwner(
        Blueprint<BlueprintUnitFact, BlueprintUnitFactReference>? checkedFact = null,
        Action<BlueprintComponent, BlueprintComponent>? merge = null,
        ComponentMerge mergeBehavior = ComponentMerge.Merge,
        int? reduction = null)
    {
      var component = new DamageReductionAgainstFactOwner();
      component.m_CheckedFact = checkedFact?.Reference ?? component.m_CheckedFact;
      if (component.m_CheckedFact is null)
      {
        component.m_CheckedFact = BlueprintTool.GetRef<BlueprintUnitFactReference>(null);
      }
      component.Reduction = reduction ?? component.Reduction;
      return AddUniqueComponent(component, mergeBehavior, merge);
    }

    /// <summary>
    /// Adds <see cref="DamageReductionAgainstRangedWeapons"/>
    /// </summary>
    ///
    /// <remarks>
    ///
    /// <para>
    /// ComponentName: BuffMechanics/Damage resist pool
    /// </para>
    ///
    /// <list type="bullet">
    /// <listheader>Used by</listheader>
    /// <item><term>TrailblazerHelmetFeature</term><description>a32d8eb9c88e3b64ab1bbf84c41524d6</description></item>
    /// </list>
    /// </remarks>
    ///
    /// <param name="type">
    /// <para>
    /// Blueprint of type BlueprintWeaponType. You can pass in the blueprint using:
    /// <list type ="bullet">
    ///   <item><term>A blueprint instance</term></item>
    ///   <item><term>A blueprint reference</term></item>
    ///   <item><term>A blueprint id as a string, Guid, or BlueprintGuid</term></item>
    ///   <item><term>A blueprint name registered with <see cref="BlueprintCore.Utils.BlueprintTool">BlueprintTool</see></term></item>
    /// </list>
    /// See <see cref="BlueprintCore.Utils.Blueprint{{T, TRef}}">Blueprint</see> for more details.
    /// </para>
    /// </param>
    public TBuilder AddDamageReductionAgainstRangedWeapons(
        int? reductionFalse = null,
        int? reductionTrue = null,
        Blueprint<BlueprintWeaponType, BlueprintWeaponTypeReference>? type = null)
    {
      var component = new DamageReductionAgainstRangedWeapons();
      component.ReductionFalse = reductionFalse ?? component.ReductionFalse;
      component.ReductionTrue = reductionTrue ?? component.ReductionTrue;
      component.m_Type = type?.Reference ?? component.m_Type;
      if (component.m_Type is null)
      {
        component.m_Type = BlueprintTool.GetRef<BlueprintWeaponTypeReference>(null);
      }
      return AddComponent(component);
    }

    /// <summary>
    /// Adds <see cref="DamageReductionAgainstSpells"/>
    /// </summary>
    ///
    /// <remarks>
    ///
    /// <para>
    /// ComponentName: BuffMechanics/Damage resist pool
    /// </para>
    ///
    /// <list type="bullet">
    /// <listheader>Used by</listheader>
    /// <item><term>TrailblazerHelmetFeature</term><description>a32d8eb9c88e3b64ab1bbf84c41524d6</description></item>
    /// </list>
    /// </remarks>
    ///
    /// <param name="spells">
    /// <para>
    /// Blueprint of type BlueprintAbility. You can pass in the blueprint using:
    /// <list type ="bullet">
    ///   <item><term>A blueprint instance</term></item>
    ///   <item><term>A blueprint reference</term></item>
    ///   <item><term>A blueprint id as a string, Guid, or BlueprintGuid</term></item>
    ///   <item><term>A blueprint name registered with <see cref="BlueprintCore.Utils.BlueprintTool">BlueprintTool</see></term></item>
    /// </list>
    /// See <see cref="BlueprintCore.Utils.Blueprint{{T, TRef}}">Blueprint</see> for more details.
    /// </para>
    /// </param>
    public TBuilder AddDamageReductionAgainstSpells(
        int? reduction = null,
        List<Blueprint<BlueprintAbility, BlueprintAbilityReference>>? spells = null)
    {
      var component = new DamageReductionAgainstSpells();
      component.Reduction = reduction ?? component.Reduction;
      component.m_Spells = spells?.Select(bp => bp.Reference)?.ToArray() ?? component.m_Spells;
      if (component.m_Spells is null)
      {
        component.m_Spells = new BlueprintAbilityReference[0];
      }
      return AddComponent(component);
    }

    /// <summary>
    /// Adds <see cref="DamageReductionBelowZero"/>
    /// </summary>
    ///
    /// <remarks>
    ///
    /// <list type="bullet">
    /// <listheader>Used by</listheader>
    /// <item><term>ToughnessMythicFeat</term><description>d8df8f8ad7149824e8e60dd3453557d2</description></item>
    /// </list>
    /// </remarks>
    ///
    /// <param name="merge">
    /// If mergeBehavior is ComponentMerge.Merge and the component already exists, this expression is called to merge the components.
    /// </param>
    /// <param name="mergeBehavior">
    /// Handling if the component already exists since the component is unique. Defaults to ComponentMerge.Fail.
    /// </param>
    public TBuilder AddDamageReductionBelowZero(
        bool? epicBypass = null,
        Action<BlueprintComponent, BlueprintComponent>? merge = null,
        ComponentMerge mergeBehavior = ComponentMerge.Merge,
        int? reduction = null)
    {
      var component = new DamageReductionBelowZero();
      component.EpicBypass = epicBypass ?? component.EpicBypass;
      component.Reduction = reduction ?? component.Reduction;
      return AddUniqueComponent(component, mergeBehavior, merge);
    }

    /// <summary>
    /// Adds <see cref="DeathOnLevelStacks"/>
    /// </summary>
    ///
    /// <remarks>
    ///
    /// <list type="bullet">
    /// <listheader>Used by</listheader>
    /// <item><term>TemporaryNegativeLevel</term><description>df95c24fa8c51eb49b2595cf532d40ad</description></item>
    /// </list>
    /// </remarks>
    public TBuilder AddDeathOnLevelStacks()
    {
      return AddComponent(new DeathOnLevelStacks());
    }

    /// <summary>
    /// Adds <see cref="DefensiveCombatTraining"/>
    /// </summary>
    ///
    /// <remarks>
    ///
    /// <para>
    /// ComponentName: Maneuver Defence Bonus
    /// </para>
    ///
    /// <list type="bullet">
    /// <listheader>Used by</listheader>
    /// <item><term>DefensiveCombatTraining</term><description>479c7f3b0dba69a4bbcb43e101f3f7f9</description></item>
    /// <item><term>DefensiveCombatTrainingMythicFeat</term><description>479ee593a2a9cad4db68468c39a623ba</description></item>
    /// </list>
    /// </remarks>
    public TBuilder AddDefensiveCombatTraining(
        bool? mythic = null)
    {
      var component = new DefensiveCombatTraining();
      component.Mythic = mythic ?? component.Mythic;
      return AddComponent(component);
    }

    /// <summary>
    /// Adds <see cref="DerivativeStatBonus"/>
    /// </summary>
    ///
    /// <remarks>
    ///
    /// <list type="bullet">
    /// <listheader>Used by</listheader>
    /// <item><term>ArmyImmuneToEverything</term><description>c9ee8a77a2f64870b6980f318d9e3d3a</description></item>
    /// <item><term>DivineGrace</term><description>8a5b5e272e5c34e41aa8b4facbb746d3</description></item>
    /// <item><term>UrgathoaBlessingFeature</term><description>42e32b46fb7cfd349a6c51ec6d0ced14</description></item>
    /// </list>
    /// </remarks>
    ///
    /// <param name="merge">
    /// If mergeBehavior is ComponentMerge.Merge and the component already exists, this expression is called to merge the components.
    /// </param>
    /// <param name="mergeBehavior">
    /// Handling if the component already exists since the component is unique. Defaults to ComponentMerge.Fail.
    /// </param>
    public TBuilder AddDerivativeStatBonus(
        StatType? baseStat = null,
        StatType? derivativeStat = null,
        ModifierDescriptor? descriptor = null,
        Action<BlueprintComponent, BlueprintComponent>? merge = null,
        ComponentMerge mergeBehavior = ComponentMerge.Merge)
    {
      var component = new DerivativeStatBonus();
      component.BaseStat = baseStat ?? component.BaseStat;
      component.DerivativeStat = derivativeStat ?? component.DerivativeStat;
      component.Descriptor = descriptor ?? component.Descriptor;
      return AddUniqueComponent(component, mergeBehavior, merge);
    }

    /// <summary>
    /// Adds <see cref="DetachBuffOnNearMiss"/>
    /// </summary>
    ///
    /// <remarks>
    ///
    /// <para>
    /// ComponentName: AC bonus against Attacks
    /// </para>
    ///
    /// <list type="bullet">
    /// <listheader>Used by</listheader>
    /// <item><term>CraneStyleWingBuff</term><description>f78a249bacba9924b9595e52495cb02f</description></item>
    /// </list>
    /// </remarks>
    ///
    /// <param name="merge">
    /// If mergeBehavior is ComponentMerge.Merge and the component already exists, this expression is called to merge the components.
    /// </param>
    /// <param name="mergeBehavior">
    /// Handling if the component already exists since the component is unique. Defaults to ComponentMerge.Fail.
    /// </param>
    public TBuilder AddDetachBuffOnNearMiss(
        ActionsBuilder? action = null,
        int? hitAndArmorDifference = null,
        bool? meleeOnly = null,
        Action<BlueprintComponent, BlueprintComponent>? merge = null,
        ComponentMerge mergeBehavior = ComponentMerge.Merge,
        bool? onAttacker = null,
        bool? rangedOnly = null)
    {
      var component = new DetachBuffOnNearMiss();
      component.Action = action?.Build() ?? component.Action;
      if (component.Action is null)
      {
        component.Action = Utils.Constants.Empty.Actions;
      }
      component.HitAndArmorDifference = hitAndArmorDifference ?? component.HitAndArmorDifference;
      component.MeleeOnly = meleeOnly ?? component.MeleeOnly;
      component.OnAttacker = onAttacker ?? component.OnAttacker;
      component.RangedOnly = rangedOnly ?? component.RangedOnly;
      return AddUniqueComponent(component, mergeBehavior, merge);
    }

    /// <summary>
    /// Adds <see cref="DiceDamageBonusOnSpell"/>
    /// </summary>
    ///
    /// <remarks>
    ///
    /// <list type="bullet">
    /// <listheader>Used by</listheader>
    /// <item><term>GlovesOfNeophyteFeature</term><description>aa84d44512e5ef64aa92f79be5aa8734</description></item>
    /// </list>
    /// </remarks>
    ///
    /// <param name="spells">
    /// <para>
    /// Blueprint of type BlueprintAbility. You can pass in the blueprint using:
    /// <list type ="bullet">
    ///   <item><term>A blueprint instance</term></item>
    ///   <item><term>A blueprint reference</term></item>
    ///   <item><term>A blueprint id as a string, Guid, or BlueprintGuid</term></item>
    ///   <item><term>A blueprint name registered with <see cref="BlueprintCore.Utils.BlueprintTool">BlueprintTool</see></term></item>
    /// </list>
    /// See <see cref="BlueprintCore.Utils.Blueprint{{T, TRef}}">Blueprint</see> for more details.
    /// </para>
    /// </param>
    public TBuilder AddDiceDamageBonusOnSpell(
        List<Blueprint<BlueprintAbility, BlueprintAbilityReference>>? spells = null,
        bool? useContextBonus = null,
        ContextValue? value = null)
    {
      var component = new DiceDamageBonusOnSpell();
      component.m_Spells = spells?.Select(bp => bp.Reference)?.ToArray() ?? component.m_Spells;
      if (component.m_Spells is null)
      {
        component.m_Spells = new BlueprintAbilityReference[0];
      }
      component.UseContextBonus = useContextBonus ?? component.UseContextBonus;
      component.Value = value ?? component.Value;
      if (component.Value is null)
      {
        component.Value = ContextValues.Constant(0);
      }
      return AddComponent(component);
    }

    /// <summary>
    /// Adds <see cref="DisableRegenerationOnCriticalHit"/>
    /// </summary>
    ///
    /// <remarks>
    ///
    /// <list type="bullet">
    /// <listheader>Used by</listheader>
    /// <item><term>ExploitWeakness</term><description>374a73288a36e2d4f9e54c75d2e6e573</description></item>
    /// </list>
    /// </remarks>
    public TBuilder AddDisableRegenerationOnCriticalHit()
    {
      return AddComponent(new DisableRegenerationOnCriticalHit());
    }

    /// <summary>
    /// Adds <see cref="DispelBonusOnDescriptor"/>
    /// </summary>
    ///
    /// <remarks>
    ///
    /// <list type="bullet">
    /// <listheader>Used by</listheader>
    /// <item><term>PerniciousPoisonBuff</term><description>2d10623d79e11014c9f70db93a28554c</description></item>
    /// </list>
    /// </remarks>
    public TBuilder AddDispelBonusOnDescriptor(
        int? bonus = null,
        SpellDescriptorWrapper? descriptor = null)
    {
      var component = new DispelBonusOnDescriptor();
      component.Bonus = bonus ?? component.Bonus;
      component.Descriptor = descriptor ?? component.Descriptor;
      return AddComponent(component);
    }

    /// <summary>
    /// Adds <see cref="DispelCasterLevelCheckBonus"/>
    /// </summary>
    ///
    /// <remarks>
    ///
    /// <list type="bullet">
    /// <listheader>Used by</listheader>
    /// <item><term>DivinationSchoolForetellAidEffect</term><description>535ddd49a2e9d74428c56a0ed6c1774c</description></item>
    /// <item><term>GlovesOfTheScribeFeature</term><description>82ec84da788ab854eb44e594b2ecf792</description></item>
    /// <item><term>WhiteroseOystersBuff</term><description>45082bf27cf15e94ca0fae92dc3db992</description></item>
    /// </list>
    /// </remarks>
    public TBuilder AddDispelCasterLevelCheckBonus(
        ContextValue? value = null)
    {
      var component = new DispelCasterLevelCheckBonus();
      component.Value = value ?? component.Value;
      if (component.Value is null)
      {
        component.Value = ContextValues.Constant(0);
      }
      return AddComponent(component);
    }

    /// <summary>
    /// Adds <see cref="DistanceAttackBonus"/>
    /// </summary>
    ///
    /// <remarks>
    ///
    /// <para>
    /// ComponentName: Distance attack bonus
    /// </para>
    ///
    /// <list type="bullet">
    /// <listheader>Used by</listheader>
    /// <item><term>PointBlankShot</term><description>0da0c194d6e1d43419eb8d990b28e0ab</description></item>
    /// <item><term>PointBlankShotMythicFeat</term><description>b651baa5f6faba646b7e3082929dfaf5</description></item>
    /// <item><term>ShootDownBuff</term><description>6a8fd7126b32c3d46beff689cac50215</description></item>
    /// </list>
    /// </remarks>
    ///
    /// <param name="merge">
    /// If mergeBehavior is ComponentMerge.Merge and the component already exists, this expression is called to merge the components.
    /// </param>
    /// <param name="mergeBehavior">
    /// Handling if the component already exists since the component is unique. Defaults to ComponentMerge.Fail.
    /// </param>
    public TBuilder AddDistanceAttackBonus(
        int? attackBonus = null,
        ModifierDescriptor? descriptor = null,
        Action<BlueprintComponent, BlueprintComponent>? merge = null,
        ComponentMerge mergeBehavior = ComponentMerge.Merge,
        Feet? range = null)
    {
      var component = new DistanceAttackBonus();
      component.AttackBonus = attackBonus ?? component.AttackBonus;
      component.Descriptor = descriptor ?? component.Descriptor;
      component.Range = range ?? component.Range;
      return AddUniqueComponent(component, mergeBehavior, merge);
    }

    /// <summary>
    /// Adds <see cref="DistanceDamageBonus"/>
    /// </summary>
    ///
    /// <remarks>
    ///
    /// <para>
    /// ComponentName: Distance damage bonus
    /// </para>
    ///
    /// <list type="bullet">
    /// <listheader>Used by</listheader>
    /// <item><term>PointBlankShot</term><description>0da0c194d6e1d43419eb8d990b28e0ab</description></item>
    /// <item><term>PointBlankShotMythicFeat</term><description>b651baa5f6faba646b7e3082929dfaf5</description></item>
    /// </list>
    /// </remarks>
    public TBuilder AddDistanceDamageBonus(
        int? damageBonus = null,
        Feet? range = null)
    {
      var component = new DistanceDamageBonus();
      component.DamageBonus = damageBonus ?? component.DamageBonus;
      component.Range = range ?? component.Range;
      return AddComponent(component);
    }

    /// <summary>
    /// Adds <see cref="DoNotBenefitFromConcealment"/>
    /// </summary>
    ///
    /// <remarks>
    ///
    /// <list type="bullet">
    /// <listheader>Used by</listheader>
    /// <item><term>FaerieFireBuff</term><description>cc383a9eaae4d2b45a925d442b367b54</description></item>
    /// <item><term>JudgeGreaterSentenceBuff</term><description>acd6efa9f76547ebba81ffe051d2fd7d</description></item>
    /// <item><term>ShamanHexFireNimbusBuff</term><description>b89bcff63880d6e439c4908ff03e212d</description></item>
    /// </list>
    /// </remarks>
    public TBuilder AddDoNotBenefitFromConcealment()
    {
      return AddComponent(new DoNotBenefitFromConcealment());
    }

    /// <summary>
    /// Adds <see cref="DoubleDamageDiceOnAttack"/>
    /// </summary>
    ///
    /// <remarks>
    ///
    /// <para>
    /// ComponentName: Roll weapon damage dice twice on attack
    /// </para>
    ///
    /// <list type="bullet">
    /// <listheader>Used by</listheader>
    /// <item><term>HammerblowBuff</term><description>928f89c30f4ad6a48862980e5f6f81cf</description></item>
    /// </list>
    /// </remarks>
    ///
    /// <param name="weaponType">
    /// <para>
    /// Blueprint of type BlueprintWeaponType. You can pass in the blueprint using:
    /// <list type ="bullet">
    ///   <item><term>A blueprint instance</term></item>
    ///   <item><term>A blueprint reference</term></item>
    ///   <item><term>A blueprint id as a string, Guid, or BlueprintGuid</term></item>
    ///   <item><term>A blueprint name registered with <see cref="BlueprintCore.Utils.BlueprintTool">BlueprintTool</see></term></item>
    /// </list>
    /// See <see cref="BlueprintCore.Utils.Blueprint{{T, TRef}}">Blueprint</see> for more details.
    /// </para>
    /// </param>
    public TBuilder AddDoubleDamageDiceOnAttack(
        bool? criticalHit = null,
        bool? onlyOnFirstAttack = null,
        bool? onlyOnFullAttack = null,
        Blueprint<BlueprintWeaponType, BlueprintWeaponTypeReference>? weaponType = null)
    {
      var component = new DoubleDamageDiceOnAttack();
      component.CriticalHit = criticalHit ?? component.CriticalHit;
      component.OnlyOnFirstAttack = onlyOnFirstAttack ?? component.OnlyOnFirstAttack;
      component.OnlyOnFullAttack = onlyOnFullAttack ?? component.OnlyOnFullAttack;
      component.m_WeaponType = weaponType?.Reference ?? component.m_WeaponType;
      if (component.m_WeaponType is null)
      {
        component.m_WeaponType = BlueprintTool.GetRef<BlueprintWeaponTypeReference>(null);
      }
      return AddComponent(component);
    }

    /// <summary>
    /// Adds <see cref="DraconicBloodlineArcana"/>
    /// </summary>
    ///
    /// <remarks>
    ///
    /// <list type="bullet">
    /// <listheader>Used by</listheader>
    /// <item><term>AmuletOfFourElementsEnchant</term><description>ccf3bd576cea03a4bb7beb08f55b0a0f</description></item>
    /// <item><term>DragonAzataBuffAlliesBuff</term><description>a8bebfbc3f5cd1b4e82a778869ecfac4</description></item>
    /// <item><term>TwinSerpentsFeature</term><description>eae9f27c1fb62394f9ad9b834b5d4e2b</description></item>
    /// </list>
    /// </remarks>
    public TBuilder AddDraconicBloodlineArcana(
        SpellDescriptorWrapper? spellDescriptor = null,
        bool? spellsOnly = null,
        bool? useContextBonus = null,
        ContextValue? value = null)
    {
      var component = new DraconicBloodlineArcana();
      component.SpellDescriptor = spellDescriptor ?? component.SpellDescriptor;
      component.SpellsOnly = spellsOnly ?? component.SpellsOnly;
      component.UseContextBonus = useContextBonus ?? component.UseContextBonus;
      component.Value = value ?? component.Value;
      if (component.Value is null)
      {
        component.Value = ContextValues.Constant(0);
      }
      return AddComponent(component);
    }

    /// <summary>
    /// Adds <see cref="DuelistPreciseStrike"/>
    /// </summary>
    ///
    /// <remarks>
    ///
    /// <list type="bullet">
    /// <listheader>Used by</listheader>
    /// <item><term>PreciseStrikeAbility</term><description>4247758d93b218a43aed6aecc1f50fbb</description></item>
    /// </list>
    /// </remarks>
    ///
    /// <param name="cloakDuelistFact">
    /// <para>
    /// InfoBox: Changes the mechanic if the White Wind Cloak is equipped by a Duelist
    /// </para>
    /// <para>
    /// Blueprint of type BlueprintBuff. You can pass in the blueprint using:
    /// <list type ="bullet">
    ///   <item><term>A blueprint instance</term></item>
    ///   <item><term>A blueprint reference</term></item>
    ///   <item><term>A blueprint id as a string, Guid, or BlueprintGuid</term></item>
    ///   <item><term>A blueprint name registered with <see cref="BlueprintCore.Utils.BlueprintTool">BlueprintTool</see></term></item>
    /// </list>
    /// See <see cref="BlueprintCore.Utils.Blueprint{{T, TRef}}">Blueprint</see> for more details.
    /// </para>
    /// </param>
    /// <param name="cloakNonDuelistFact">
    /// <para>
    /// InfoBox: Changes the mechanic if the White Wind Cloak is equipped by a non-Duelist
    /// </para>
    /// <para>
    /// Blueprint of type BlueprintBuff. You can pass in the blueprint using:
    /// <list type ="bullet">
    ///   <item><term>A blueprint instance</term></item>
    ///   <item><term>A blueprint reference</term></item>
    ///   <item><term>A blueprint id as a string, Guid, or BlueprintGuid</term></item>
    ///   <item><term>A blueprint name registered with <see cref="BlueprintCore.Utils.BlueprintTool">BlueprintTool</see></term></item>
    /// </list>
    /// See <see cref="BlueprintCore.Utils.Blueprint{{T, TRef}}">Blueprint</see> for more details.
    /// </para>
    /// </param>
    /// <param name="duelist">
    /// <para>
    /// Blueprint of type BlueprintCharacterClass. You can pass in the blueprint using:
    /// <list type ="bullet">
    ///   <item><term>A blueprint instance</term></item>
    ///   <item><term>A blueprint reference</term></item>
    ///   <item><term>A blueprint id as a string, Guid, or BlueprintGuid</term></item>
    ///   <item><term>A blueprint name registered with <see cref="BlueprintCore.Utils.BlueprintTool">BlueprintTool</see></term></item>
    /// </list>
    /// See <see cref="BlueprintCore.Utils.Blueprint{{T, TRef}}">Blueprint</see> for more details.
    /// </para>
    /// </param>
    public TBuilder AddDuelistPreciseStrike(
        Blueprint<BlueprintBuff, BlueprintBuffReference>? cloakDuelistFact = null,
        Blueprint<BlueprintBuff, BlueprintBuffReference>? cloakNonDuelistFact = null,
        Blueprint<BlueprintCharacterClass, BlueprintCharacterClassReference>? duelist = null)
    {
      var component = new DuelistPreciseStrike();
      component.m_CloakDuelistFact = cloakDuelistFact?.Reference ?? component.m_CloakDuelistFact;
      if (component.m_CloakDuelistFact is null)
      {
        component.m_CloakDuelistFact = BlueprintTool.GetRef<BlueprintBuffReference>(null);
      }
      component.m_CloakNonDuelistFact = cloakNonDuelistFact?.Reference ?? component.m_CloakNonDuelistFact;
      if (component.m_CloakNonDuelistFact is null)
      {
        component.m_CloakNonDuelistFact = BlueprintTool.GetRef<BlueprintBuffReference>(null);
      }
      component.m_Duelist = duelist?.Reference ?? component.m_Duelist;
      if (component.m_Duelist is null)
      {
        component.m_Duelist = BlueprintTool.GetRef<BlueprintCharacterClassReference>(null);
      }
      return AddComponent(component);
    }

    /// <summary>
    /// Adds <see cref="EnduringSpells"/>
    /// </summary>
    ///
    /// <remarks>
    ///
    /// <list type="bullet">
    /// <listheader>Used by</listheader>
    /// <item><term>EnduringSpells</term><description>2f206e6d292bdfb4d981e99dcf08153f</description></item>
    /// </list>
    /// </remarks>
    ///
    /// <param name="greater">
    /// <para>
    /// Blueprint of type BlueprintUnitFact. You can pass in the blueprint using:
    /// <list type ="bullet">
    ///   <item><term>A blueprint instance</term></item>
    ///   <item><term>A blueprint reference</term></item>
    ///   <item><term>A blueprint id as a string, Guid, or BlueprintGuid</term></item>
    ///   <item><term>A blueprint name registered with <see cref="BlueprintCore.Utils.BlueprintTool">BlueprintTool</see></term></item>
    /// </list>
    /// See <see cref="BlueprintCore.Utils.Blueprint{{T, TRef}}">Blueprint</see> for more details.
    /// </para>
    /// </param>
    /// <param name="merge">
    /// If mergeBehavior is ComponentMerge.Merge and the component already exists, this expression is called to merge the components.
    /// </param>
    /// <param name="mergeBehavior">
    /// Handling if the component already exists since the component is unique. Defaults to ComponentMerge.Fail.
    /// </param>
    public TBuilder AddEnduringSpells(
        Blueprint<BlueprintUnitFact, BlueprintUnitFactReference>? greater = null,
        Action<BlueprintComponent, BlueprintComponent>? merge = null,
        ComponentMerge mergeBehavior = ComponentMerge.Merge)
    {
      var component = new EnduringSpells();
      component.m_Greater = greater?.Reference ?? component.m_Greater;
      if (component.m_Greater is null)
      {
        component.m_Greater = BlueprintTool.GetRef<BlueprintUnitFactReference>(null);
      }
      return AddUniqueComponent(component, mergeBehavior, merge);
    }

    /// <summary>
    /// Adds <see cref="Evasion"/>
    /// </summary>
    ///
    /// <remarks>
    ///
    /// <list type="bullet">
    /// <listheader>Used by</listheader>
    /// <item><term>AerialEvasionBuff</term><description>1f6b996a2ccf0454a9fde4625b89591f</description></item>
    /// <item><term>RingOfDevastatingWillFeature</term><description>8498f37c5a0d3bc46adb49ca82b8e230</description></item>
    /// <item><term>SubtypeInevitable</term><description>6c8a550544aa425f8f6f8e7667cb04ec</description></item>
    /// </list>
    /// </remarks>
    ///
    /// <param name="merge">
    /// If mergeBehavior is ComponentMerge.Merge and the component already exists, this expression is called to merge the components.
    /// </param>
    /// <param name="mergeBehavior">
    /// Handling if the component already exists since the component is unique. Defaults to ComponentMerge.Fail.
    /// </param>
    public TBuilder AddEvasion(
        Action<BlueprintComponent, BlueprintComponent>? merge = null,
        ComponentMerge mergeBehavior = ComponentMerge.Merge,
        SavingThrowType? savingThrow = null)
    {
      var component = new Evasion();
      component.SavingThrow = savingThrow ?? component.SavingThrow;
      return AddUniqueComponent(component, mergeBehavior, merge);
    }

    /// <summary>
    /// Adds <see cref="EvasionWithTowerShield"/>
    /// </summary>
    ///
    /// <remarks>
    ///
    /// <list type="bullet">
    /// <listheader>Used by</listheader>
    /// <item><term>TowerShieldEvasion</term><description>bc678dd87b293ed4a99d0d75c1974f64</description></item>
    /// <item><term>TowerShieldImprovedEvasion</term><description>a2daced5523237e4ab92309a03250cc0</description></item>
    /// </list>
    /// </remarks>
    ///
    /// <param name="merge">
    /// If mergeBehavior is ComponentMerge.Merge and the component already exists, this expression is called to merge the components.
    /// </param>
    /// <param name="mergeBehavior">
    /// Handling if the component already exists since the component is unique. Defaults to ComponentMerge.Fail.
    /// </param>
    public TBuilder AddEvasionWithTowerShield(
        bool? improved = null,
        Action<BlueprintComponent, BlueprintComponent>? merge = null,
        ComponentMerge mergeBehavior = ComponentMerge.Merge)
    {
      var component = new EvasionWithTowerShield();
      component.Improved = improved ?? component.Improved;
      return AddUniqueComponent(component, mergeBehavior, merge);
    }

    /// <summary>
    /// Adds <see cref="FactSinglify"/>
    /// </summary>
    ///
    /// <remarks>
    ///
    /// <list type="bullet">
    /// <listheader>Used by</listheader>
    /// <item><term>AlchemistBombsFeature</term><description>c59b2f256f5a70a4d896568658315b7d</description></item>
    /// <item><term>CoupDeGraceFeature</term><description>3fbd5466fcc609d40bb2dfc3e502f4c4</description></item>
    /// <item><term>MadnessDomainBaseFeature</term><description>84bf46e8086dbdc438bac875ab0e5c2f</description></item>
    /// </list>
    /// </remarks>
    ///
    /// <param name="merge">
    /// If mergeBehavior is ComponentMerge.Merge and the component already exists, this expression is called to merge the components.
    /// </param>
    /// <param name="mergeBehavior">
    /// Handling if the component already exists since the component is unique. Defaults to ComponentMerge.Fail.
    /// </param>
    /// <param name="newFacts">
    /// <para>
    /// Tooltip: List of facts to be added and then singlified - their possible copies are removed
    /// </para>
    /// <para>
    /// Blueprint of type BlueprintUnitFact. You can pass in the blueprint using:
    /// <list type ="bullet">
    ///   <item><term>A blueprint instance</term></item>
    ///   <item><term>A blueprint reference</term></item>
    ///   <item><term>A blueprint id as a string, Guid, or BlueprintGuid</term></item>
    ///   <item><term>A blueprint name registered with <see cref="BlueprintCore.Utils.BlueprintTool">BlueprintTool</see></term></item>
    /// </list>
    /// See <see cref="BlueprintCore.Utils.Blueprint{{T, TRef}}">Blueprint</see> for more details.
    /// </para>
    /// </param>
    /// <param name="oldFacts">
    /// <para>
    /// Tooltip: List of facts to be removed, if they exist
    /// </para>
    /// <para>
    /// Blueprint of type BlueprintUnitFact. You can pass in the blueprint using:
    /// <list type ="bullet">
    ///   <item><term>A blueprint instance</term></item>
    ///   <item><term>A blueprint reference</term></item>
    ///   <item><term>A blueprint id as a string, Guid, or BlueprintGuid</term></item>
    ///   <item><term>A blueprint name registered with <see cref="BlueprintCore.Utils.BlueprintTool">BlueprintTool</see></term></item>
    /// </list>
    /// See <see cref="BlueprintCore.Utils.Blueprint{{T, TRef}}">Blueprint</see> for more details.
    /// </para>
    /// </param>
    public TBuilder AddFactSinglify(
        Action<BlueprintComponent, BlueprintComponent>? merge = null,
        ComponentMerge mergeBehavior = ComponentMerge.Merge,
        List<Blueprint<BlueprintUnitFact, BlueprintUnitFactReference>>? newFacts = null,
        List<Blueprint<BlueprintUnitFact, BlueprintUnitFactReference>>? oldFacts = null)
    {
      var component = new FactSinglify();
      component.m_NewFacts = newFacts?.Select(bp => bp.Reference)?.ToArray() ?? component.m_NewFacts;
      if (component.m_NewFacts is null)
      {
        component.m_NewFacts = new BlueprintUnitFactReference[0];
      }
      component.m_OldFacts = oldFacts?.Select(bp => bp.Reference)?.ToArray() ?? component.m_OldFacts;
      if (component.m_OldFacts is null)
      {
        component.m_OldFacts = new BlueprintUnitFactReference[0];
      }
      return AddUniqueComponent(component, mergeBehavior, merge);
    }

    /// <summary>
    /// Adds <see cref="FactsChangeTrigger"/>
    /// </summary>
    ///
    /// <remarks>
    ///
    /// <list type="bullet">
    /// <listheader>Used by</listheader>
    /// <item><term>RavagerOfDreadRingFeature</term><description>26cbb4e193bd5fc47aefc10ac237551d</description></item>
    /// </list>
    /// </remarks>
    ///
    /// <param name="checkedFacts">
    /// <para>
    /// Blueprint of type BlueprintUnitFact. You can pass in the blueprint using:
    /// <list type ="bullet">
    ///   <item><term>A blueprint instance</term></item>
    ///   <item><term>A blueprint reference</term></item>
    ///   <item><term>A blueprint id as a string, Guid, or BlueprintGuid</term></item>
    ///   <item><term>A blueprint name registered with <see cref="BlueprintCore.Utils.BlueprintTool">BlueprintTool</see></term></item>
    /// </list>
    /// See <see cref="BlueprintCore.Utils.Blueprint{{T, TRef}}">Blueprint</see> for more details.
    /// </para>
    /// </param>
    /// <param name="merge">
    /// If mergeBehavior is ComponentMerge.Merge and the component already exists, this expression is called to merge the components.
    /// </param>
    /// <param name="mergeBehavior">
    /// Handling if the component already exists since the component is unique. Defaults to ComponentMerge.Fail.
    /// </param>
    public TBuilder AddFactsChangeTrigger(
        List<Blueprint<BlueprintUnitFact, BlueprintUnitFactReference>>? checkedFacts = null,
        Action<BlueprintComponent, BlueprintComponent>? merge = null,
        ComponentMerge mergeBehavior = ComponentMerge.Merge,
        ActionsBuilder? onFactGainedActions = null,
        ActionsBuilder? onFactLostActions = null)
    {
      var component = new FactsChangeTrigger();
      component.m_CheckedFacts = checkedFacts?.Select(bp => bp.Reference)?.ToArray() ?? component.m_CheckedFacts;
      if (component.m_CheckedFacts is null)
      {
        component.m_CheckedFacts = new BlueprintUnitFactReference[0];
      }
      component.OnFactGainedActions = onFactGainedActions?.Build() ?? component.OnFactGainedActions;
      if (component.OnFactGainedActions is null)
      {
        component.OnFactGainedActions = Utils.Constants.Empty.Actions;
      }
      component.OnFactLostActions = onFactLostActions?.Build() ?? component.OnFactLostActions;
      if (component.OnFactLostActions is null)
      {
        component.OnFactLostActions = Utils.Constants.Empty.Actions;
      }
      return AddUniqueComponent(component, mergeBehavior, merge);
    }

    /// <summary>
    /// Adds <see cref="FlankedAttackBonus"/>
    /// </summary>
    ///
    /// <remarks>
    ///
    /// <para>
    /// ComponentName: Bonus to attack against flanked opponents
    /// </para>
    ///
    /// <list type="bullet">
    /// <listheader>Used by</listheader>
    /// <item><term>ArmyFlankingAttackBonus</term><description>216e068eb420e774ea9b1d50df617fcf</description></item>
    /// <item><term>FreebootersBondBuff</term><description>06c374a073284ac43b047850a18efd8e</description></item>
    /// <item><term>StagHelmetFeature</term><description>32c73d4df6c4f4746a748bc1f140d629</description></item>
    /// </list>
    /// </remarks>
    ///
    /// <param name="merge">
    /// If mergeBehavior is ComponentMerge.Merge and the component already exists, this expression is called to merge the components.
    /// </param>
    /// <param name="mergeBehavior">
    /// Handling if the component already exists since the component is unique. Defaults to ComponentMerge.Fail.
    /// </param>
    public TBuilder AddFlankedAttackBonus(
        int? attackBonus = null,
        ModifierDescriptor? descriptor = null,
        Action<BlueprintComponent, BlueprintComponent>? merge = null,
        ComponentMerge mergeBehavior = ComponentMerge.Merge)
    {
      var component = new FlankedAttackBonus();
      component.AttackBonus = attackBonus ?? component.AttackBonus;
      component.Descriptor = descriptor ?? component.Descriptor;
      return AddUniqueComponent(component, mergeBehavior, merge);
    }

    /// <summary>
    /// Adds <see cref="FlatFootedIgnore"/>
    /// </summary>
    ///
    /// <remarks>
    ///
    /// <para>
    /// ComponentName: 
    /// </para>
    ///
    /// <list type="bullet">
    /// <listheader>Used by</listheader>
    /// <item><term>BlindFight</term><description>4e219f5894ad0ea4daa0699e28c37b1d</description></item>
    /// <item><term>ForesightBuff</term><description>8c385a7610aa409468f3a6c0f904ac92</description></item>
    /// <item><term>UncannyDodge</term><description>3c08d842e802c3e4eb19d15496145709</description></item>
    /// </list>
    /// </remarks>
    public TBuilder AddFlatFootedIgnore(
        FlatFootedIgnoreType? type = null)
    {
      var component = new FlatFootedIgnore();
      component.Type = type ?? component.Type;
      return AddComponent(component);
    }

    /// <summary>
    /// Adds <see cref="FullSpeedInStealth"/>
    /// </summary>
    ///
    /// <remarks>
    ///
    /// <para>
    /// ComponentName: Full Speed In Stealth
    /// </para>
    ///
    /// <list type="bullet">
    /// <listheader>Used by</listheader>
    /// <item><term>FastStealth</term><description>97a6aa2b64dd21a4fac67658a91067d7</description></item>
    /// <item><term>RogueCapFeature</term><description>b8e0399759a1fe04aa81f71e2687043f</description></item>
    /// </list>
    /// </remarks>
    public TBuilder AddFullSpeedInStealth()
    {
      return AddComponent(new FullSpeedInStealth());
    }

    /// <summary>
    /// Adds <see cref="Hardy"/>
    /// </summary>
    ///
    /// <remarks>
    ///
    /// <list type="bullet">
    /// <listheader>Used by</listheader>
    /// <item><term>Hardy</term><description>f75d3b6110f04d1409564b9d7647db60</description></item>
    /// </list>
    /// </remarks>
    ///
    /// <param name="merge">
    /// If mergeBehavior is ComponentMerge.Merge and the component already exists, this expression is called to merge the components.
    /// </param>
    /// <param name="mergeBehavior">
    /// Handling if the component already exists since the component is unique. Defaults to ComponentMerge.Fail.
    /// </param>
    /// <param name="steelSoul">
    /// <para>
    /// Blueprint of type BlueprintFeature. You can pass in the blueprint using:
    /// <list type ="bullet">
    ///   <item><term>A blueprint instance</term></item>
    ///   <item><term>A blueprint reference</term></item>
    ///   <item><term>A blueprint id as a string, Guid, or BlueprintGuid</term></item>
    ///   <item><term>A blueprint name registered with <see cref="BlueprintCore.Utils.BlueprintTool">BlueprintTool</see></term></item>
    /// </list>
    /// See <see cref="BlueprintCore.Utils.Blueprint{{T, TRef}}">Blueprint</see> for more details.
    /// </para>
    /// </param>
    public TBuilder AddHardy(
        Action<BlueprintComponent, BlueprintComponent>? merge = null,
        ComponentMerge mergeBehavior = ComponentMerge.Merge,
        Blueprint<BlueprintFeature, BlueprintFeatureReference>? steelSoul = null)
    {
      var component = new Hardy();
      component.m_SteelSoul = steelSoul?.Reference ?? component.m_SteelSoul;
      if (component.m_SteelSoul is null)
      {
        component.m_SteelSoul = BlueprintTool.GetRef<BlueprintFeatureReference>(null);
      }
      return AddUniqueComponent(component, mergeBehavior, merge);
    }

    /// <summary>
    /// Adds <see cref="IgnoreConcealment"/>
    /// </summary>
    ///
    /// <remarks>
    ///
    /// <para>
    /// ComponentName: Attack Dice Reroll
    /// </para>
    ///
    /// <list type="bullet">
    /// <listheader>Used by</listheader>
    /// <item><term>KiTrueStrikeBuff</term><description>294e43af05aba134a8a24b05113cf472</description></item>
    /// <item><term>UmbralStrike</term><description>474ed0aa656cc38499cc9a073d113716</description></item>
    /// <item><term>WildLink_ArcherEffectBuff</term><description>f325218a4482d0145a94dcdb5b3bcb42</description></item>
    /// </list>
    /// </remarks>
    public TBuilder AddIgnoreConcealment()
    {
      return AddComponent(new IgnoreConcealment());
    }

    /// <summary>
    /// Adds <see cref="IgnoreCritImmunity"/>
    /// </summary>
    ///
    /// <remarks>
    ///
    /// <para>
    /// ComponentName: Ignore crit immunity
    /// </para>
    ///
    /// <list type="bullet">
    /// <listheader>Used by</listheader>
    /// <item><term>StudentOfWarDeadlyBlow</term><description>d71d6c64e0a174f4a99c1f115d630300</description></item>
    /// </list>
    /// </remarks>
    ///
    /// <param name="checkedFact">
    /// <para>
    /// Blueprint of type BlueprintUnitFact. You can pass in the blueprint using:
    /// <list type ="bullet">
    ///   <item><term>A blueprint instance</term></item>
    ///   <item><term>A blueprint reference</term></item>
    ///   <item><term>A blueprint id as a string, Guid, or BlueprintGuid</term></item>
    ///   <item><term>A blueprint name registered with <see cref="BlueprintCore.Utils.BlueprintTool">BlueprintTool</see></term></item>
    /// </list>
    /// See <see cref="BlueprintCore.Utils.Blueprint{{T, TRef}}">Blueprint</see> for more details.
    /// </para>
    /// </param>
    public TBuilder AddIgnoreCritImmunity(
        Blueprint<BlueprintUnitFact, BlueprintUnitFactReference>? checkedFact = null,
        bool? checkFact = null,
        bool? not = null)
    {
      var component = new IgnoreCritImmunity();
      component.m_CheckedFact = checkedFact?.Reference ?? component.m_CheckedFact;
      if (component.m_CheckedFact is null)
      {
        component.m_CheckedFact = BlueprintTool.GetRef<BlueprintUnitFactReference>(null);
      }
      component.CheckFact = checkFact ?? component.CheckFact;
      component.Not = not ?? component.Not;
      return AddComponent(component);
    }

    /// <summary>
    /// Adds <see cref="IgnoreDamageReductionOnAttack"/>
    /// </summary>
    ///
    /// <remarks>
    ///
    /// <para>
    /// ComponentName: Ignore damage reduction on attack
    /// </para>
    ///
    /// <list type="bullet">
    /// <listheader>Used by</listheader>
    /// <item><term>ChampionOfTheFaithSmiteBuff</term><description>c362c2d961d28f1438094bac025e06a2</description></item>
    /// <item><term>HeartOfTheHeraldEffectBuff</term><description>00d86b5aef5d4999a6bb3f3adc627d52</description></item>
    /// <item><term>WreckerDR</term><description>589aa3d4131727b43aa57bc96003bb06</description></item>
    /// </list>
    /// </remarks>
    ///
    /// <param name="checkedFact">
    /// <para>
    /// Blueprint of type BlueprintUnitFact. You can pass in the blueprint using:
    /// <list type ="bullet">
    ///   <item><term>A blueprint instance</term></item>
    ///   <item><term>A blueprint reference</term></item>
    ///   <item><term>A blueprint id as a string, Guid, or BlueprintGuid</term></item>
    ///   <item><term>A blueprint name registered with <see cref="BlueprintCore.Utils.BlueprintTool">BlueprintTool</see></term></item>
    /// </list>
    /// See <see cref="BlueprintCore.Utils.Blueprint{{T, TRef}}">Blueprint</see> for more details.
    /// </para>
    /// </param>
    /// <param name="weaponType">
    /// <para>
    /// Blueprint of type BlueprintWeaponType. You can pass in the blueprint using:
    /// <list type ="bullet">
    ///   <item><term>A blueprint instance</term></item>
    ///   <item><term>A blueprint reference</term></item>
    ///   <item><term>A blueprint id as a string, Guid, or BlueprintGuid</term></item>
    ///   <item><term>A blueprint name registered with <see cref="BlueprintCore.Utils.BlueprintTool">BlueprintTool</see></term></item>
    /// </list>
    /// See <see cref="BlueprintCore.Utils.Blueprint{{T, TRef}}">Blueprint</see> for more details.
    /// </para>
    /// </param>
    public TBuilder AddIgnoreDamageReductionOnAttack(
        Blueprint<BlueprintUnitFact, BlueprintUnitFactReference>? checkedFact = null,
        bool? checkEnemyFact = null,
        bool? criticalHit = null,
        bool? onlyNaturalAttacks = null,
        bool? onlyOnFirstAttack = null,
        bool? onlyOnFullAttack = null,
        Blueprint<BlueprintWeaponType, BlueprintWeaponTypeReference>? weaponType = null)
    {
      var component = new IgnoreDamageReductionOnAttack();
      component.m_CheckedFact = checkedFact?.Reference ?? component.m_CheckedFact;
      if (component.m_CheckedFact is null)
      {
        component.m_CheckedFact = BlueprintTool.GetRef<BlueprintUnitFactReference>(null);
      }
      component.CheckEnemyFact = checkEnemyFact ?? component.CheckEnemyFact;
      component.CriticalHit = criticalHit ?? component.CriticalHit;
      component.OnlyNaturalAttacks = onlyNaturalAttacks ?? component.OnlyNaturalAttacks;
      component.OnlyOnFirstAttack = onlyOnFirstAttack ?? component.OnlyOnFirstAttack;
      component.OnlyOnFullAttack = onlyOnFullAttack ?? component.OnlyOnFullAttack;
      component.m_WeaponType = weaponType?.Reference ?? component.m_WeaponType;
      if (component.m_WeaponType is null)
      {
        component.m_WeaponType = BlueprintTool.GetRef<BlueprintWeaponTypeReference>(null);
      }
      return AddComponent(component);
    }

    /// <summary>
    /// Adds <see cref="IgnoreDamageReductionOnCriticalHit"/>
    /// </summary>
    ///
    /// <remarks>
    ///
    /// <list type="bullet">
    /// <listheader>Used by</listheader>
    /// <item><term>ExploitWeakness</term><description>374a73288a36e2d4f9e54c75d2e6e573</description></item>
    /// <item><term>OracleBattleFinalRevelation</term><description>9caa8060ec83c0842b127c318571c6d1</description></item>
    /// </list>
    /// </remarks>
    public TBuilder AddIgnoreDamageReductionOnCriticalHit()
    {
      return AddComponent(new IgnoreDamageReductionOnCriticalHit());
    }

    /// <summary>
    /// Adds <see cref="IgnoreDamageReductionOnTarget"/>
    /// </summary>
    ///
    /// <remarks>
    ///
    /// <para>
    /// ComponentName: Ignore damage reduction and immunity
    /// </para>
    ///
    /// <list type="bullet">
    /// <listheader>Used by</listheader>
    /// <item><term>AeonTenthLevelImmunities</term><description>711f6abfab877d342af9743a11c8f3aa</description></item>
    /// <item><term>Valmallos_Feature_Immunities</term><description>cb539d689d9d47858b96715a29363820</description></item>
    /// </list>
    /// </remarks>
    public TBuilder AddIgnoreDamageReductionOnTarget(
        AlignmentComponent? alignment = null,
        bool? checkTargetAlignment = null)
    {
      var component = new IgnoreDamageReductionOnTarget();
      component.Alignment = alignment ?? component.Alignment;
      component.CheckTargetAlignment = checkTargetAlignment ?? component.CheckTargetAlignment;
      return AddComponent(component);
    }

    /// <summary>
    /// Adds <see cref="IgnorePartialConcealmentOnRangedAttacks"/>
    /// </summary>
    ///
    /// <remarks>
    ///
    /// <list type="bullet">
    /// <listheader>Used by</listheader>
    /// <item><term>ImprovedPreciseShot</term><description>46f970a6b9b5d2346b10892673fe6e74</description></item>
    /// </list>
    /// </remarks>
    public TBuilder AddIgnorePartialConcealmentOnRangedAttacks()
    {
      return AddComponent(new IgnorePartialConcealmentOnRangedAttacks());
    }

    /// <summary>
    /// Adds <see cref="IgnoreSpellResistanceForSpells"/>
    /// </summary>
    ///
    /// <remarks>
    ///
    /// <list type="bullet">
    /// <listheader>Used by</listheader>
    /// <item><term>DeadlyMagicBuff</term><description>27ebfae71cce46045814eb3ba4fefa6b</description></item>
    /// <item><term>GreyGarrison_SuperMythicBuff</term><description>4b11247a4988c254fb9d1cd67f0b1e4a</description></item>
    /// <item><term>ZachariusFallenWandFeatureLich</term><description>176d0d2b6339447ab92001bc05a32360</description></item>
    /// </list>
    /// </remarks>
    ///
    /// <param name="abilityList">
    /// <para>
    /// Blueprint of type BlueprintAbility. You can pass in the blueprint using:
    /// <list type ="bullet">
    ///   <item><term>A blueprint instance</term></item>
    ///   <item><term>A blueprint reference</term></item>
    ///   <item><term>A blueprint id as a string, Guid, or BlueprintGuid</term></item>
    ///   <item><term>A blueprint name registered with <see cref="BlueprintCore.Utils.BlueprintTool">BlueprintTool</see></term></item>
    /// </list>
    /// See <see cref="BlueprintCore.Utils.Blueprint{{T, TRef}}">Blueprint</see> for more details.
    /// </para>
    /// </param>
    public TBuilder AddIgnoreSpellResistanceForSpells(
        List<Blueprint<BlueprintAbility, BlueprintAbilityReference>>? abilityList = null,
        bool? allSpells = null)
    {
      var component = new IgnoreSpellResistanceForSpells();
      component.m_AbilityList = abilityList?.Select(bp => bp.Reference)?.ToArray() ?? component.m_AbilityList;
      if (component.m_AbilityList is null)
      {
        component.m_AbilityList = new BlueprintAbilityReference[0];
      }
      component.AllSpells = allSpells ?? component.AllSpells;
      return AddComponent(component);
    }

    /// <summary>
    /// Adds <see cref="ImpromptuSneakAttack"/>
    /// </summary>
    ///
    /// <remarks>
    ///
    /// <list type="bullet">
    /// <listheader>Used by</listheader>
    /// <item><term>ImpromptuSneakAttackBuff</term><description>47d4e61b336b6a94c9c0d8949af0253b</description></item>
    /// <item><term>PrescientAttackBuff</term><description>2544b9d16793e2642a645c8e3aece7d3</description></item>
    /// </list>
    /// </remarks>
    public TBuilder AddImpromptuSneakAttack()
    {
      return AddComponent(new ImpromptuSneakAttack());
    }

    /// <summary>
    /// Adds <see cref="ImprovedEvasion"/>
    /// </summary>
    ///
    /// <remarks>
    ///
    /// <list type="bullet">
    /// <listheader>Used by</listheader>
    /// <item><term>AnimalCompanionImprovedEvasion</term><description>bcb37922402e40d4684e7fb7e001d110</description></item>
    /// <item><term>ImprovedEvasion</term><description>0d35d6c4d5eef8d4790d09bd9a874e57</description></item>
    /// <item><term>SubtypeInevitable</term><description>6c8a550544aa425f8f6f8e7667cb04ec</description></item>
    /// </list>
    /// </remarks>
    ///
    /// <param name="merge">
    /// If mergeBehavior is ComponentMerge.Merge and the component already exists, this expression is called to merge the components.
    /// </param>
    /// <param name="mergeBehavior">
    /// Handling if the component already exists since the component is unique. Defaults to ComponentMerge.Fail.
    /// </param>
    public TBuilder AddImprovedEvasion(
        Action<BlueprintComponent, BlueprintComponent>? merge = null,
        ComponentMerge mergeBehavior = ComponentMerge.Merge,
        SavingThrowType? savingThrow = null)
    {
      var component = new ImprovedEvasion();
      component.SavingThrow = savingThrow ?? component.SavingThrow;
      return AddUniqueComponent(component, mergeBehavior, merge);
    }

    /// <summary>
    /// Adds <see cref="IncreaseAllSpellsDC"/>
    /// </summary>
    ///
    /// <remarks>
    ///
    /// <para>
    /// ComponentName: Increase all spells DC
    /// </para>
    ///
    /// <list type="bullet">
    /// <listheader>Used by</listheader>
    /// <item><term>AcornPieBuff</term><description>58879110ddb29e740acfc313e8d57d35</description></item>
    /// <item><term>HellsDecreeAbilityMagicTransmutationBuff</term><description>ded8dddbbf78c48408582980da0608b7</description></item>
    /// <item><term>Valmallos_Buff_AeonGazeEnemy_Core</term><description>217c83b902de44ffa2602d52bafe3d2e</description></item>
    /// </list>
    /// </remarks>
    ///
    /// <param name="spellsOnly">
    /// <para>
    /// InfoBox: Turn on to increase DC only for spells from spellbook
    /// </para>
    /// </param>
    public TBuilder AddIncreaseAllSpellsDC(
        ModifierDescriptor? descriptor = null,
        bool? spellsOnly = null,
        ContextValue? value = null)
    {
      var component = new IncreaseAllSpellsDC();
      component.Descriptor = descriptor ?? component.Descriptor;
      component.SpellsOnly = spellsOnly ?? component.SpellsOnly;
      component.Value = value ?? component.Value;
      if (component.Value is null)
      {
        component.Value = ContextValues.Constant(0);
      }
      return AddComponent(component);
    }

    /// <summary>
    /// Adds <see cref="IncreaseCasterLevel"/>
    /// </summary>
    ///
    /// <remarks>
    ///
    /// <para>
    /// ComponentName: Increase all spells CL
    /// </para>
    ///
    /// <list type="bullet">
    /// <listheader>Used by</listheader>
    /// <item><term>AeonCLGazeAllyBuff</term><description>b26ce61b589a4c34b878a67dc1059f12</description></item>
    /// <item><term>HellsDecreeAbilityMagicIllusionBuff</term><description>a3720ccc52393f24da5241594084a2d8</description></item>
    /// <item><term>Valmallos_Buff_AeonGazeEnemy_Core</term><description>217c83b902de44ffa2602d52bafe3d2e</description></item>
    /// </list>
    /// </remarks>
    public TBuilder AddIncreaseCasterLevel(
        ModifierDescriptor? descriptor = null,
        ContextValue? value = null)
    {
      var component = new IncreaseCasterLevel();
      component.Descriptor = descriptor ?? component.Descriptor;
      component.Value = value ?? component.Value;
      if (component.Value is null)
      {
        component.Value = ContextValues.Constant(0);
      }
      return AddComponent(component);
    }

    /// <summary>
    /// Adds <see cref="IncreaseCastersSavingThrowTypeDC"/>
    /// </summary>
    ///
    /// <remarks>
    ///
    /// <list type="bullet">
    /// <listheader>Used by</listheader>
    /// <item><term>OdeToMiraculousMagicBuff</term><description>f6ef0e25745114d46bf16fd5a1d93cc9</description></item>
    /// <item><term>QuarterstaffOfStrongwilledFeature</term><description>e15d6b56117a1804596f43a1307b6e0d</description></item>
    /// <item><term>RobeOfDeterminationFeature</term><description>b50ccdb58ae51d646b7ec8a5d2dc2a97</description></item>
    /// </list>
    /// </remarks>
    ///
    /// <param name="merge">
    /// If mergeBehavior is ComponentMerge.Merge and the component already exists, this expression is called to merge the components.
    /// </param>
    /// <param name="mergeBehavior">
    /// Handling if the component already exists since the component is unique. Defaults to ComponentMerge.Fail.
    /// </param>
    public TBuilder AddIncreaseCastersSavingThrowTypeDC(
        int? bonusDC = null,
        Action<BlueprintComponent, BlueprintComponent>? merge = null,
        ComponentMerge mergeBehavior = ComponentMerge.Merge,
        SavingThrowType? type = null)
    {
      var component = new IncreaseCastersSavingThrowTypeDC();
      component.BonusDC = bonusDC ?? component.BonusDC;
      component.Type = type ?? component.Type;
      return AddUniqueComponent(component, mergeBehavior, merge);
    }

    /// <summary>
    /// Adds <see cref="IncreaseFeatRankByGroup"/>
    /// </summary>
    ///
    /// <remarks>
    ///
    /// <list type="bullet">
    /// <listheader>Used by</listheader>
    /// <item><term>FencersGiftFeature</term><description>df266754759ade74eb6e3fd650bdb7c9</description></item>
    /// <item><term>GlovesOfDuelingFeature2</term><description>f063942ce72136c49a12d34a3fd88197</description></item>
    /// <item><term>GlovesOfEntropyFeature</term><description>79b47a435975401cab345d2cea0d3c16</description></item>
    /// </list>
    /// </remarks>
    ///
    /// <param name="merge">
    /// If mergeBehavior is ComponentMerge.Merge and the component already exists, this expression is called to merge the components.
    /// </param>
    /// <param name="mergeBehavior">
    /// Handling if the component already exists since the component is unique. Defaults to ComponentMerge.Fail.
    /// </param>
    public TBuilder AddIncreaseFeatRankByGroup(
        FeatureGroup? group = null,
        Action<BlueprintComponent, BlueprintComponent>? merge = null,
        ComponentMerge mergeBehavior = ComponentMerge.Merge)
    {
      var component = new IncreaseFeatRankByGroup();
      component.Group = group ?? component.Group;
      return AddUniqueComponent(component, mergeBehavior, merge);
    }

    /// <summary>
    /// Adds <see cref="IncreaseSpellContextDescriptorDC"/>
    /// </summary>
    ///
    /// <remarks>
    ///
    /// <para>
    /// ComponentName: Increase spell descriptor DC
    /// </para>
    ///
    /// <list type="bullet">
    /// <listheader>Used by</listheader>
    /// <item><term>DirgeBardHauntingRefrainFeature</term><description>d90802b1a74ae004aac439036263825a</description></item>
    /// <item><term>TheUndyingLoveOfTheHopebringer_DarkAuraCompanionEffectBuff</term><description>fbc3d50954b94fa28b5eceb172549d81</description></item>
    /// <item><term>WinterWitchColdSpecialization</term><description>9b827777e51ec0540ba6a0cbea6ea84a</description></item>
    /// </list>
    /// </remarks>
    ///
    /// <param name="spellsOnly">
    /// <para>
    /// InfoBox: Turn on to increase DC only for spells from spellbook
    /// </para>
    /// </param>
    public TBuilder AddIncreaseSpellContextDescriptorDC(
        SpellDescriptorWrapper? descriptor = null,
        ModifierDescriptor? modifierDescriptor = null,
        bool? spellsOnly = null,
        ContextValue? value = null)
    {
      var component = new IncreaseSpellContextDescriptorDC();
      component.Descriptor = descriptor ?? component.Descriptor;
      component.ModifierDescriptor = modifierDescriptor ?? component.ModifierDescriptor;
      component.SpellsOnly = spellsOnly ?? component.SpellsOnly;
      component.Value = value ?? component.Value;
      if (component.Value is null)
      {
        component.Value = ContextValues.Constant(0);
      }
      return AddComponent(component);
    }

    /// <summary>
    /// Adds <see cref="IncreaseSpellDC"/>
    /// </summary>
    ///
    /// <remarks>
    ///
    /// <para>
    /// ComponentName: Increase spell descriptor DC
    /// </para>
    ///
    /// <list type="bullet">
    /// <listheader>Used by</listheader>
    /// <item><term>ArmyDominateDCBuff</term><description>6ce81cd4e365402f8f865d7169118932</description></item>
    /// <item><term>GloryDomainBaseFeature</term><description>17e891b3964492f43aae44f994b5d454</description></item>
    /// <item><term>XavornsCrossFeature</term><description>35f473c44b5a94b42898be80f3248ca0</description></item>
    /// </list>
    /// </remarks>
    ///
    /// <param name="merge">
    /// If mergeBehavior is ComponentMerge.Merge and the component already exists, this expression is called to merge the components.
    /// </param>
    /// <param name="mergeBehavior">
    /// Handling if the component already exists since the component is unique. Defaults to ComponentMerge.Fail.
    /// </param>
    /// <param name="spell">
    /// <para>
    /// Blueprint of type BlueprintAbility. You can pass in the blueprint using:
    /// <list type ="bullet">
    ///   <item><term>A blueprint instance</term></item>
    ///   <item><term>A blueprint reference</term></item>
    ///   <item><term>A blueprint id as a string, Guid, or BlueprintGuid</term></item>
    ///   <item><term>A blueprint name registered with <see cref="BlueprintCore.Utils.BlueprintTool">BlueprintTool</see></term></item>
    /// </list>
    /// See <see cref="BlueprintCore.Utils.Blueprint{{T, TRef}}">Blueprint</see> for more details.
    /// </para>
    /// </param>
    /// <param name="spellsOnly">
    /// <para>
    /// InfoBox: Turn on to increase DC only for spells from spellbook
    /// </para>
    /// </param>
    public TBuilder AddIncreaseSpellDC(
        int? bonusDC = null,
        ModifierDescriptor? descriptor = null,
        bool? halfMythicRank = null,
        Action<BlueprintComponent, BlueprintComponent>? merge = null,
        ComponentMerge mergeBehavior = ComponentMerge.Merge,
        Blueprint<BlueprintAbility, BlueprintAbilityReference>? spell = null,
        bool? spellsOnly = null,
        bool? useContextBonus = null,
        ContextValue? value = null)
    {
      var component = new IncreaseSpellDC();
      component.BonusDC = bonusDC ?? component.BonusDC;
      component.Descriptor = descriptor ?? component.Descriptor;
      component.HalfMythicRank = halfMythicRank ?? component.HalfMythicRank;
      component.m_Spell = spell?.Reference ?? component.m_Spell;
      if (component.m_Spell is null)
      {
        component.m_Spell = BlueprintTool.GetRef<BlueprintAbilityReference>(null);
      }
      component.SpellsOnly = spellsOnly ?? component.SpellsOnly;
      component.UseContextBonus = useContextBonus ?? component.UseContextBonus;
      component.Value = value ?? component.Value;
      if (component.Value is null)
      {
        component.Value = ContextValues.Constant(0);
      }
      return AddUniqueComponent(component, mergeBehavior, merge);
    }

    /// <summary>
    /// Adds <see cref="IncreaseSpellDescriptorCasterLevel"/>
    /// </summary>
    ///
    /// <remarks>
    ///
    /// <para>
    /// ComponentName: Increase spell descriptor CL
    /// </para>
    ///
    /// <list type="bullet">
    /// <listheader>Used by</listheader>
    /// <item><term>BloodragerElementalAcidPowerOfTheElementsBuff</term><description>69b9e9b52f11d664da60728939d29a00</description></item>
    /// <item><term>NegativeEmpowerBuff</term><description>67d1c0362e934fb1809fee2f7612bbe4</description></item>
    /// <item><term>WinterWitchFreezingColdUpgradeFeature</term><description>b2552d80cdd24e17af922ec8ef669192</description></item>
    /// </list>
    /// </remarks>
    public TBuilder AddIncreaseSpellDescriptorCasterLevel(
        int? bonusCasterLevel = null,
        SpellDescriptorWrapper? descriptor = null,
        ModifierDescriptor? modifierDescriptor = null)
    {
      var component = new IncreaseSpellDescriptorCasterLevel();
      component.BonusCasterLevel = bonusCasterLevel ?? component.BonusCasterLevel;
      component.Descriptor = descriptor ?? component.Descriptor;
      component.ModifierDescriptor = modifierDescriptor ?? component.ModifierDescriptor;
      return AddComponent(component);
    }

    /// <summary>
    /// Adds <see cref="IncreaseSpellDescriptorDC"/>
    /// </summary>
    ///
    /// <remarks>
    ///
    /// <para>
    /// ComponentName: Increase spell descriptor DC
    /// </para>
    ///
    /// <list type="bullet">
    /// <listheader>Used by</listheader>
    /// <item><term>AcidAffinityOread</term><description>763a97c2216fd124da93b164994fd82b</description></item>
    /// <item><term>GearsRuleFeature</term><description>88acea521a38dfe4ab9be550a4d8c596</description></item>
    /// <item><term>ZachariusNecromancyFeature</term><description>0c96ac8f976a4fc38148a259cf8ef917</description></item>
    /// </list>
    /// </remarks>
    ///
    /// <param name="spellsOnly">
    /// <para>
    /// InfoBox: Turn on to increase DC only for spells from spellbook
    /// </para>
    /// </param>
    public TBuilder AddIncreaseSpellDescriptorDC(
        int? bonusDC = null,
        SpellDescriptorWrapper? descriptor = null,
        ModifierDescriptor? modifierDescriptor = null,
        bool? spellsOnly = null)
    {
      var component = new IncreaseSpellDescriptorDC();
      component.BonusDC = bonusDC ?? component.BonusDC;
      component.Descriptor = descriptor ?? component.Descriptor;
      component.ModifierDescriptor = modifierDescriptor ?? component.ModifierDescriptor;
      component.SpellsOnly = spellsOnly ?? component.SpellsOnly;
      return AddComponent(component);
    }

    /// <summary>
    /// Adds <see cref="IncreaseSpellHealing"/>
    /// </summary>
    ///
    /// <remarks>
    ///
    /// <list type="bullet">
    /// <listheader>Used by</listheader>
    /// <item><term>AeonPrimordialMagicHealGazeAllyBuff</term><description>5ca4a0c3b6ba465fb8e4c6e10e361cd7</description></item>
    /// <item><term>AeonPrimordialMagicHealGazeEnemyBuff</term><description>3a33539cffd94d4f9dc20bffd094bae8</description></item>
    /// </list>
    /// </remarks>
    ///
    /// <param name="healBonus">
    /// <para>
    /// InfoBox: Value can be negative as well (to decrease healing)
    /// </para>
    /// </param>
    /// <param name="merge">
    /// If mergeBehavior is ComponentMerge.Merge and the component already exists, this expression is called to merge the components.
    /// </param>
    /// <param name="mergeBehavior">
    /// Handling if the component already exists since the component is unique. Defaults to ComponentMerge.Fail.
    /// </param>
    /// <param name="school">
    /// <para>
    /// InfoBox: Leave None to skip school check
    /// </para>
    /// </param>
    public TBuilder AddIncreaseSpellHealing(
        ContextValue? healBonus = null,
        Action<BlueprintComponent, BlueprintComponent>? merge = null,
        ComponentMerge mergeBehavior = ComponentMerge.Merge,
        SpellSchool? school = null)
    {
      var component = new IncreaseSpellHealing();
      component.HealBonus = healBonus ?? component.HealBonus;
      if (component.HealBonus is null)
      {
        component.HealBonus = ContextValues.Constant(0);
      }
      component.School = school ?? component.School;
      return AddUniqueComponent(component, mergeBehavior, merge);
    }

    /// <summary>
    /// Adds <see cref="IncreaseSpellSchoolCasterLevel"/>
    /// </summary>
    ///
    /// <remarks>
    ///
    /// <para>
    /// ComponentName: Increase spell school CL
    /// </para>
    ///
    /// <list type="bullet">
    /// <listheader>Used by</listheader>
    /// <item><term>AshmakerFeature</term><description>27ffa0263026b3c449c7db15795c27fa</description></item>
    /// <item><term>PhantasmalGuideFeature</term><description>2c5fde95eef5303489c819057ff0a65b</description></item>
    /// <item><term>XanthirRevelationsFeature</term><description>c231414680fc4c45889e14bec45e7674</description></item>
    /// </list>
    /// </remarks>
    public TBuilder AddIncreaseSpellSchoolCasterLevel(
        int? bonusLevel = null,
        ModifierDescriptor? descriptor = null,
        SpellSchool? school = null)
    {
      var component = new IncreaseSpellSchoolCasterLevel();
      component.BonusLevel = bonusLevel ?? component.BonusLevel;
      component.Descriptor = descriptor ?? component.Descriptor;
      component.School = school ?? component.School;
      return AddComponent(component);
    }

    /// <summary>
    /// Adds <see cref="IncreaseSpellSchoolDC"/>
    /// </summary>
    ///
    /// <remarks>
    ///
    /// <para>
    /// ComponentName: Increase spell school DC
    /// </para>
    ///
    /// <list type="bullet">
    /// <listheader>Used by</listheader>
    /// <item><term>2THEvocation2DCTransmFeature</term><description>71a08d4b6ebb07a4ab3adb19b25947e6</description></item>
    /// <item><term>KnightsEmblemSunsetShortswordFeature</term><description>277fd4291f558fd458e3c73c9b658f6c</description></item>
    /// <item><term>WhiteroseOystersBuff</term><description>45082bf27cf15e94ca0fae92dc3db992</description></item>
    /// </list>
    /// </remarks>
    ///
    /// <param name="merge">
    /// If mergeBehavior is ComponentMerge.Merge and the component already exists, this expression is called to merge the components.
    /// </param>
    /// <param name="mergeBehavior">
    /// Handling if the component already exists since the component is unique. Defaults to ComponentMerge.Fail.
    /// </param>
    public TBuilder AddIncreaseSpellSchoolDC(
        int? bonusDC = null,
        ModifierDescriptor? descriptor = null,
        Action<BlueprintComponent, BlueprintComponent>? merge = null,
        ComponentMerge mergeBehavior = ComponentMerge.Merge,
        SpellSchool? school = null)
    {
      var component = new IncreaseSpellSchoolDC();
      component.BonusDC = bonusDC ?? component.BonusDC;
      component.Descriptor = descriptor ?? component.Descriptor;
      component.School = school ?? component.School;
      return AddUniqueComponent(component, mergeBehavior, merge);
    }

    /// <summary>
    /// Adds <see cref="IncreaseSpellSchoolDamage"/>
    /// </summary>
    ///
    /// <remarks>
    ///
    /// <para>
    /// ComponentName: Increase spell school damage
    /// </para>
    ///
    /// <list type="bullet">
    /// <listheader>Used by</listheader>
    /// <item><term>AeonPrimordialMagicDamageGazeAllyBuff</term><description>e2f2a4feb62d403bad8b7c0227ec1297</description></item>
    /// <item><term>AeonPrimordialMagicDamageGazeEnemyBuff</term><description>41c84e00028945f3adc79460a5a5b86e</description></item>
    /// <item><term>CourtPoetInsightfulDamageBuff</term><description>3f5f6fa5a1ab4d7091e8cb803574f7fa</description></item>
    /// </list>
    /// </remarks>
    ///
    /// <param name="merge">
    /// If mergeBehavior is ComponentMerge.Merge and the component already exists, this expression is called to merge the components.
    /// </param>
    /// <param name="mergeBehavior">
    /// Handling if the component already exists since the component is unique. Defaults to ComponentMerge.Fail.
    /// </param>
    public TBuilder AddIncreaseSpellSchoolDamage(
        ContextValue? damageBonus = null,
        Action<BlueprintComponent, BlueprintComponent>? merge = null,
        ComponentMerge mergeBehavior = ComponentMerge.Merge,
        SpellSchool? school = null)
    {
      var component = new IncreaseSpellSchoolDamage();
      component.DamageBonus = damageBonus ?? component.DamageBonus;
      if (component.DamageBonus is null)
      {
        component.DamageBonus = ContextValues.Constant(0);
      }
      component.School = school ?? component.School;
      return AddUniqueComponent(component, mergeBehavior, merge);
    }

    /// <summary>
    /// Adds <see cref="IncreaseSpellSpellbookDC"/>
    /// </summary>
    ///
    /// <remarks>
    ///
    /// <para>
    /// ComponentName: Increase spell school DC
    /// </para>
    ///
    /// <list type="bullet">
    /// <listheader>Used by</listheader>
    /// <item><term>ArcanistArcaneReservoirDCBuff</term><description>db4b91a8a297c4247b13cfb6ea228bf3</description></item>
    /// <item><term>BlackenedRagsFeature</term><description>3fc009ca325d70f4dbc3c56d73c4873a</description></item>
    /// <item><term>EldritchFontEldritchSurgeDCBuff</term><description>91b2762997f0d8044baeeef0871eac6f</description></item>
    /// </list>
    /// </remarks>
    ///
    /// <param name="merge">
    /// If mergeBehavior is ComponentMerge.Merge and the component already exists, this expression is called to merge the components.
    /// </param>
    /// <param name="mergeBehavior">
    /// Handling if the component already exists since the component is unique. Defaults to ComponentMerge.Fail.
    /// </param>
    /// <param name="spellbooks">
    /// <para>
    /// Blueprint of type BlueprintSpellbook. You can pass in the blueprint using:
    /// <list type ="bullet">
    ///   <item><term>A blueprint instance</term></item>
    ///   <item><term>A blueprint reference</term></item>
    ///   <item><term>A blueprint id as a string, Guid, or BlueprintGuid</term></item>
    ///   <item><term>A blueprint name registered with <see cref="BlueprintCore.Utils.BlueprintTool">BlueprintTool</see></term></item>
    /// </list>
    /// See <see cref="BlueprintCore.Utils.Blueprint{{T, TRef}}">Blueprint</see> for more details.
    /// </para>
    /// </param>
    public TBuilder AddIncreaseSpellSpellbookDC(
        int? bonusDC = null,
        ModifierDescriptor? descriptor = null,
        Action<BlueprintComponent, BlueprintComponent>? merge = null,
        ComponentMerge mergeBehavior = ComponentMerge.Merge,
        List<Blueprint<BlueprintSpellbook, BlueprintSpellbookReference>>? spellbooks = null)
    {
      var component = new IncreaseSpellSpellbookDC();
      component.BonusDC = bonusDC ?? component.BonusDC;
      component.Descriptor = descriptor ?? component.Descriptor;
      component.m_Spellbooks = spellbooks?.Select(bp => bp.Reference)?.ToArray() ?? component.m_Spellbooks;
      if (component.m_Spellbooks is null)
      {
        component.m_Spellbooks = new BlueprintSpellbookReference[0];
      }
      return AddUniqueComponent(component, mergeBehavior, merge);
    }

    /// <summary>
    /// Adds <see cref="InitiatorCritAutoconfirm"/>
    /// </summary>
    ///
    /// <remarks>
    ///
    /// <para>
    /// ComponentName: Crits against initiated by owner are autoconfirmed
    /// </para>
    ///
    /// <list type="bullet">
    /// <listheader>Used by</listheader>
    /// <item><term>CrimsonBannerBuff</term><description>da6ab933823c406e8bcc869e4d3b156b</description></item>
    /// <item><term>MaskOfAreshkagalBelt_TabulaRasaFeature</term><description>178eb4206921425499d363dbf12ad184</description></item>
    /// </list>
    /// </remarks>
    public TBuilder AddInitiatorCritAutoconfirm()
    {
      return AddComponent(new InitiatorCritAutoconfirm());
    }

    /// <summary>
    /// Adds <see cref="KensaiCriticalPerfection"/>
    /// </summary>
    ///
    /// <remarks>
    ///
    /// <list type="bullet">
    /// <listheader>Used by</listheader>
    /// <item><term>SwordSaintCriticalPerfection</term><description>36837f00fc2f5d043847e37ba6af187c</description></item>
    /// </list>
    /// </remarks>
    ///
    /// <param name="chosenWeaponBlueprint">
    /// <para>
    /// Blueprint of type BlueprintParametrizedFeature. You can pass in the blueprint using:
    /// <list type ="bullet">
    ///   <item><term>A blueprint instance</term></item>
    ///   <item><term>A blueprint reference</term></item>
    ///   <item><term>A blueprint id as a string, Guid, or BlueprintGuid</term></item>
    ///   <item><term>A blueprint name registered with <see cref="BlueprintCore.Utils.BlueprintTool">BlueprintTool</see></term></item>
    /// </list>
    /// See <see cref="BlueprintCore.Utils.Blueprint{{T, TRef}}">Blueprint</see> for more details.
    /// </para>
    /// </param>
    /// <param name="magusBlueprint">
    /// <para>
    /// Blueprint of type BlueprintCharacterClass. You can pass in the blueprint using:
    /// <list type ="bullet">
    ///   <item><term>A blueprint instance</term></item>
    ///   <item><term>A blueprint reference</term></item>
    ///   <item><term>A blueprint id as a string, Guid, or BlueprintGuid</term></item>
    ///   <item><term>A blueprint name registered with <see cref="BlueprintCore.Utils.BlueprintTool">BlueprintTool</see></term></item>
    /// </list>
    /// See <see cref="BlueprintCore.Utils.Blueprint{{T, TRef}}">Blueprint</see> for more details.
    /// </para>
    /// </param>
    /// <param name="merge">
    /// If mergeBehavior is ComponentMerge.Merge and the component already exists, this expression is called to merge the components.
    /// </param>
    /// <param name="mergeBehavior">
    /// Handling if the component already exists since the component is unique. Defaults to ComponentMerge.Fail.
    /// </param>
    public TBuilder AddKensaiCriticalPerfection(
        Blueprint<BlueprintParametrizedFeature, BlueprintParametrizedFeatureReference>? chosenWeaponBlueprint = null,
        Blueprint<BlueprintCharacterClass, BlueprintCharacterClassReference>? magusBlueprint = null,
        Action<BlueprintComponent, BlueprintComponent>? merge = null,
        ComponentMerge mergeBehavior = ComponentMerge.Merge)
    {
      var component = new KensaiCriticalPerfection();
      component.m_ChosenWeaponBlueprint = chosenWeaponBlueprint?.Reference ?? component.m_ChosenWeaponBlueprint;
      if (component.m_ChosenWeaponBlueprint is null)
      {
        component.m_ChosenWeaponBlueprint = BlueprintTool.GetRef<BlueprintParametrizedFeatureReference>(null);
      }
      component.m_MagusBlueprint = magusBlueprint?.Reference ?? component.m_MagusBlueprint;
      if (component.m_MagusBlueprint is null)
      {
        component.m_MagusBlueprint = BlueprintTool.GetRef<BlueprintCharacterClassReference>(null);
      }
      return AddUniqueComponent(component, mergeBehavior, merge);
    }

    /// <summary>
    /// Adds <see cref="KensaiIaijutsuFocus"/>
    /// </summary>
    ///
    /// <remarks>
    ///
    /// <para>
    /// ComponentName: Armor class bonus against alignment
    /// </para>
    ///
    /// <list type="bullet">
    /// <listheader>Used by</listheader>
    /// <item><term>SwordSaintInstantFocus</term><description>5fcdb5b9dd41724439c6c4e4b6d27e81</description></item>
    /// </list>
    /// </remarks>
    ///
    /// <param name="chosenWeaponBlueprint">
    /// <para>
    /// Blueprint of type BlueprintParametrizedFeature. You can pass in the blueprint using:
    /// <list type ="bullet">
    ///   <item><term>A blueprint instance</term></item>
    ///   <item><term>A blueprint reference</term></item>
    ///   <item><term>A blueprint id as a string, Guid, or BlueprintGuid</term></item>
    ///   <item><term>A blueprint name registered with <see cref="BlueprintCore.Utils.BlueprintTool">BlueprintTool</see></term></item>
    /// </list>
    /// See <see cref="BlueprintCore.Utils.Blueprint{{T, TRef}}">Blueprint</see> for more details.
    /// </para>
    /// </param>
    /// <param name="magusBlueprint">
    /// <para>
    /// Blueprint of type BlueprintCharacterClass. You can pass in the blueprint using:
    /// <list type ="bullet">
    ///   <item><term>A blueprint instance</term></item>
    ///   <item><term>A blueprint reference</term></item>
    ///   <item><term>A blueprint id as a string, Guid, or BlueprintGuid</term></item>
    ///   <item><term>A blueprint name registered with <see cref="BlueprintCore.Utils.BlueprintTool">BlueprintTool</see></term></item>
    /// </list>
    /// See <see cref="BlueprintCore.Utils.Blueprint{{T, TRef}}">Blueprint</see> for more details.
    /// </para>
    /// </param>
    /// <param name="merge">
    /// If mergeBehavior is ComponentMerge.Merge and the component already exists, this expression is called to merge the components.
    /// </param>
    /// <param name="mergeBehavior">
    /// Handling if the component already exists since the component is unique. Defaults to ComponentMerge.Fail.
    /// </param>
    public TBuilder AddKensaiIaijutsuFocus(
        Blueprint<BlueprintParametrizedFeature, BlueprintParametrizedFeatureReference>? chosenWeaponBlueprint = null,
        Blueprint<BlueprintCharacterClass, BlueprintCharacterClassReference>? magusBlueprint = null,
        Action<BlueprintComponent, BlueprintComponent>? merge = null,
        ComponentMerge mergeBehavior = ComponentMerge.Merge)
    {
      var component = new KensaiIaijutsuFocus();
      component.m_ChosenWeaponBlueprint = chosenWeaponBlueprint?.Reference ?? component.m_ChosenWeaponBlueprint;
      if (component.m_ChosenWeaponBlueprint is null)
      {
        component.m_ChosenWeaponBlueprint = BlueprintTool.GetRef<BlueprintParametrizedFeatureReference>(null);
      }
      component.m_MagusBlueprint = magusBlueprint?.Reference ?? component.m_MagusBlueprint;
      if (component.m_MagusBlueprint is null)
      {
        component.m_MagusBlueprint = BlueprintTool.GetRef<BlueprintCharacterClassReference>(null);
      }
      return AddUniqueComponent(component, mergeBehavior, merge);
    }

    /// <summary>
    /// Adds <see cref="KensaiPerfectStrike"/>
    /// </summary>
    ///
    /// <remarks>
    ///
    /// <para>
    /// ComponentName: Armor class bonus against alignment
    /// </para>
    ///
    /// <list type="bullet">
    /// <listheader>Used by</listheader>
    /// <item><term>SwordSaintPerfectStrikeBuff</term><description>e194d672b44eabd418e80f4bd2308a5b</description></item>
    /// </list>
    /// </remarks>
    ///
    /// <param name="chosenWeaponBlueprint">
    /// <para>
    /// Blueprint of type BlueprintParametrizedFeature. You can pass in the blueprint using:
    /// <list type ="bullet">
    ///   <item><term>A blueprint instance</term></item>
    ///   <item><term>A blueprint reference</term></item>
    ///   <item><term>A blueprint id as a string, Guid, or BlueprintGuid</term></item>
    ///   <item><term>A blueprint name registered with <see cref="BlueprintCore.Utils.BlueprintTool">BlueprintTool</see></term></item>
    /// </list>
    /// See <see cref="BlueprintCore.Utils.Blueprint{{T, TRef}}">Blueprint</see> for more details.
    /// </para>
    /// </param>
    /// <param name="magusBlueprint">
    /// <para>
    /// Blueprint of type BlueprintCharacterClass. You can pass in the blueprint using:
    /// <list type ="bullet">
    ///   <item><term>A blueprint instance</term></item>
    ///   <item><term>A blueprint reference</term></item>
    ///   <item><term>A blueprint id as a string, Guid, or BlueprintGuid</term></item>
    ///   <item><term>A blueprint name registered with <see cref="BlueprintCore.Utils.BlueprintTool">BlueprintTool</see></term></item>
    /// </list>
    /// See <see cref="BlueprintCore.Utils.Blueprint{{T, TRef}}">Blueprint</see> for more details.
    /// </para>
    /// </param>
    /// <param name="merge">
    /// If mergeBehavior is ComponentMerge.Merge and the component already exists, this expression is called to merge the components.
    /// </param>
    /// <param name="mergeBehavior">
    /// Handling if the component already exists since the component is unique. Defaults to ComponentMerge.Fail.
    /// </param>
    public TBuilder AddKensaiPerfectStrike(
        Blueprint<BlueprintParametrizedFeature, BlueprintParametrizedFeatureReference>? chosenWeaponBlueprint = null,
        Blueprint<BlueprintCharacterClass, BlueprintCharacterClassReference>? magusBlueprint = null,
        Action<BlueprintComponent, BlueprintComponent>? merge = null,
        ComponentMerge mergeBehavior = ComponentMerge.Merge)
    {
      var component = new KensaiPerfectStrike();
      component.m_ChosenWeaponBlueprint = chosenWeaponBlueprint?.Reference ?? component.m_ChosenWeaponBlueprint;
      if (component.m_ChosenWeaponBlueprint is null)
      {
        component.m_ChosenWeaponBlueprint = BlueprintTool.GetRef<BlueprintParametrizedFeatureReference>(null);
      }
      component.m_MagusBlueprint = magusBlueprint?.Reference ?? component.m_MagusBlueprint;
      if (component.m_MagusBlueprint is null)
      {
        component.m_MagusBlueprint = BlueprintTool.GetRef<BlueprintCharacterClassReference>(null);
      }
      return AddUniqueComponent(component, mergeBehavior, merge);
    }

    /// <summary>
    /// Adds <see cref="KensaiPowerfulCrit"/>
    /// </summary>
    ///
    /// <remarks>
    ///
    /// <list type="bullet">
    /// <listheader>Used by</listheader>
    /// <item><term>SwordSaintPerfectStrikeCritBuff</term><description>54deca24695cb0c4fb6fc8e4c1861eef</description></item>
    /// <item><term>SwordSaintWeaponMastery</term><description>5b31af13868166d4c9bb452f19277f19</description></item>
    /// </list>
    /// </remarks>
    ///
    /// <param name="chosenWeaponBlueprint">
    /// <para>
    /// Blueprint of type BlueprintParametrizedFeature. You can pass in the blueprint using:
    /// <list type ="bullet">
    ///   <item><term>A blueprint instance</term></item>
    ///   <item><term>A blueprint reference</term></item>
    ///   <item><term>A blueprint id as a string, Guid, or BlueprintGuid</term></item>
    ///   <item><term>A blueprint name registered with <see cref="BlueprintCore.Utils.BlueprintTool">BlueprintTool</see></term></item>
    /// </list>
    /// See <see cref="BlueprintCore.Utils.Blueprint{{T, TRef}}">Blueprint</see> for more details.
    /// </para>
    /// </param>
    /// <param name="magusBlueprint">
    /// <para>
    /// Blueprint of type BlueprintCharacterClass. You can pass in the blueprint using:
    /// <list type ="bullet">
    ///   <item><term>A blueprint instance</term></item>
    ///   <item><term>A blueprint reference</term></item>
    ///   <item><term>A blueprint id as a string, Guid, or BlueprintGuid</term></item>
    ///   <item><term>A blueprint name registered with <see cref="BlueprintCore.Utils.BlueprintTool">BlueprintTool</see></term></item>
    /// </list>
    /// See <see cref="BlueprintCore.Utils.Blueprint{{T, TRef}}">Blueprint</see> for more details.
    /// </para>
    /// </param>
    /// <param name="merge">
    /// If mergeBehavior is ComponentMerge.Merge and the component already exists, this expression is called to merge the components.
    /// </param>
    /// <param name="mergeBehavior">
    /// Handling if the component already exists since the component is unique. Defaults to ComponentMerge.Fail.
    /// </param>
    public TBuilder AddKensaiPowerfulCrit(
        Blueprint<BlueprintParametrizedFeature, BlueprintParametrizedFeatureReference>? chosenWeaponBlueprint = null,
        Blueprint<BlueprintCharacterClass, BlueprintCharacterClassReference>? magusBlueprint = null,
        Action<BlueprintComponent, BlueprintComponent>? merge = null,
        ComponentMerge mergeBehavior = ComponentMerge.Merge)
    {
      var component = new KensaiPowerfulCrit();
      component.m_ChosenWeaponBlueprint = chosenWeaponBlueprint?.Reference ?? component.m_ChosenWeaponBlueprint;
      if (component.m_ChosenWeaponBlueprint is null)
      {
        component.m_ChosenWeaponBlueprint = BlueprintTool.GetRef<BlueprintParametrizedFeatureReference>(null);
      }
      component.m_MagusBlueprint = magusBlueprint?.Reference ?? component.m_MagusBlueprint;
      if (component.m_MagusBlueprint is null)
      {
        component.m_MagusBlueprint = BlueprintTool.GetRef<BlueprintCharacterClassReference>(null);
      }
      return AddUniqueComponent(component, mergeBehavior, merge);
    }

    /// <summary>
    /// Adds <see cref="KensaiWeaponMastery"/>
    /// </summary>
    ///
    /// <remarks>
    ///
    /// <list type="bullet">
    /// <listheader>Used by</listheader>
    /// <item><term>SwordSaintWeaponMastery</term><description>5b31af13868166d4c9bb452f19277f19</description></item>
    /// </list>
    /// </remarks>
    ///
    /// <param name="chosenWeaponBlueprint">
    /// <para>
    /// Blueprint of type BlueprintParametrizedFeature. You can pass in the blueprint using:
    /// <list type ="bullet">
    ///   <item><term>A blueprint instance</term></item>
    ///   <item><term>A blueprint reference</term></item>
    ///   <item><term>A blueprint id as a string, Guid, or BlueprintGuid</term></item>
    ///   <item><term>A blueprint name registered with <see cref="BlueprintCore.Utils.BlueprintTool">BlueprintTool</see></term></item>
    /// </list>
    /// See <see cref="BlueprintCore.Utils.Blueprint{{T, TRef}}">Blueprint</see> for more details.
    /// </para>
    /// </param>
    /// <param name="magusBlueprint">
    /// <para>
    /// Blueprint of type BlueprintCharacterClass. You can pass in the blueprint using:
    /// <list type ="bullet">
    ///   <item><term>A blueprint instance</term></item>
    ///   <item><term>A blueprint reference</term></item>
    ///   <item><term>A blueprint id as a string, Guid, or BlueprintGuid</term></item>
    ///   <item><term>A blueprint name registered with <see cref="BlueprintCore.Utils.BlueprintTool">BlueprintTool</see></term></item>
    /// </list>
    /// See <see cref="BlueprintCore.Utils.Blueprint{{T, TRef}}">Blueprint</see> for more details.
    /// </para>
    /// </param>
    /// <param name="merge">
    /// If mergeBehavior is ComponentMerge.Merge and the component already exists, this expression is called to merge the components.
    /// </param>
    /// <param name="mergeBehavior">
    /// Handling if the component already exists since the component is unique. Defaults to ComponentMerge.Fail.
    /// </param>
    public TBuilder AddKensaiWeaponMastery(
        Blueprint<BlueprintParametrizedFeature, BlueprintParametrizedFeatureReference>? chosenWeaponBlueprint = null,
        Blueprint<BlueprintCharacterClass, BlueprintCharacterClassReference>? magusBlueprint = null,
        Action<BlueprintComponent, BlueprintComponent>? merge = null,
        ComponentMerge mergeBehavior = ComponentMerge.Merge)
    {
      var component = new KensaiWeaponMastery();
      component.m_ChosenWeaponBlueprint = chosenWeaponBlueprint?.Reference ?? component.m_ChosenWeaponBlueprint;
      if (component.m_ChosenWeaponBlueprint is null)
      {
        component.m_ChosenWeaponBlueprint = BlueprintTool.GetRef<BlueprintParametrizedFeatureReference>(null);
      }
      component.m_MagusBlueprint = magusBlueprint?.Reference ?? component.m_MagusBlueprint;
      if (component.m_MagusBlueprint is null)
      {
        component.m_MagusBlueprint = BlueprintTool.GetRef<BlueprintCharacterClassReference>(null);
      }
      return AddUniqueComponent(component, mergeBehavior, merge);
    }

    /// <summary>
    /// Adds <see cref="MadDogPackTactics"/>
    /// </summary>
    ///
    /// <remarks>
    ///
    /// <list type="bullet">
    /// <listheader>Used by</listheader>
    /// <item><term>MadDogPackTacticsMaster</term><description>7c8f1d83b18fa9a4491596d3e65f965c</description></item>
    /// <item><term>MadDogPackTacticsPet</term><description>222463f6306f5de4b9b2a1603bcebfdb</description></item>
    /// <item><term>MadDogThroatCutterPet</term><description>65a170770daec324d9a5e14c2b9dbcf7</description></item>
    /// </list>
    /// </remarks>
    ///
    /// <param name="merge">
    /// If mergeBehavior is ComponentMerge.Merge and the component already exists, this expression is called to merge the components.
    /// </param>
    /// <param name="mergeBehavior">
    /// Handling if the component already exists since the component is unique. Defaults to ComponentMerge.Fail.
    /// </param>
    public TBuilder AddMadDogPackTactics(
        Action<BlueprintComponent, BlueprintComponent>? merge = null,
        ComponentMerge mergeBehavior = ComponentMerge.Merge)
    {
      var component = new MadDogPackTactics();
      return AddUniqueComponent(component, mergeBehavior, merge);
    }

    /// <summary>
    /// Adds <see cref="ManeuverBonus"/>
    /// </summary>
    ///
    /// <remarks>
    ///
    /// <para>
    /// ComponentName: Maneuver Bonus
    /// </para>
    ///
    /// <list type="bullet">
    /// <listheader>Used by</listheader>
    /// <item><term>AspectOfTheWolfBuff</term><description>98d9d1a761c8ade49964aa97ecd8dc1a</description></item>
    /// <item><term>ImprovedBullRush</term><description>b3614622866fe7046b787a548bbd7f59</description></item>
    /// <item><term>TwoHandedFighterStrongGrip</term><description>ab9d45de98fe56441a4c012f70dad6ee</description></item>
    /// </list>
    /// </remarks>
    ///
    /// <param name="merge">
    /// If mergeBehavior is ComponentMerge.Merge and the component already exists, this expression is called to merge the components.
    /// </param>
    /// <param name="mergeBehavior">
    /// Handling if the component already exists since the component is unique. Defaults to ComponentMerge.Fail.
    /// </param>
    public TBuilder AddManeuverBonus(
        int? bonus = null,
        ModifierDescriptor? descriptor = null,
        Action<BlueprintComponent, BlueprintComponent>? merge = null,
        ComponentMerge mergeBehavior = ComponentMerge.Merge,
        bool? mythic = null,
        CombatManeuver? type = null)
    {
      var component = new ManeuverBonus();
      component.Bonus = bonus ?? component.Bonus;
      component.Descriptor = descriptor ?? component.Descriptor;
      component.Mythic = mythic ?? component.Mythic;
      component.Type = type ?? component.Type;
      return AddUniqueComponent(component, mergeBehavior, merge);
    }

    /// <summary>
    /// Adds <see cref="ManeuverBonusFromStat"/>
    /// </summary>
    ///
    /// <remarks>
    ///
    /// <list type="bullet">
    /// <listheader>Used by</listheader>
    /// <item><term>FurysFall</term><description>0fc1ed8532168f74a9441bd17ad59e66</description></item>
    /// </list>
    /// </remarks>
    public TBuilder AddManeuverBonusFromStat(
        ModifierDescriptor? descriptor = null,
        StatType? stat = null,
        CombatManeuver? type = null)
    {
      var component = new ManeuverBonusFromStat();
      component.Descriptor = descriptor ?? component.Descriptor;
      component.Stat = stat ?? component.Stat;
      component.Type = type ?? component.Type;
      return AddComponent(component);
    }

    /// <summary>
    /// Adds <see cref="ManeuverDefenceBonus"/>
    /// </summary>
    ///
    /// <remarks>
    ///
    /// <para>
    /// ComponentName: Maneuver Defence Bonus
    /// </para>
    ///
    /// <list type="bullet">
    /// <listheader>Used by</listheader>
    /// <item><term>GlovesOfDuelingFeature</term><description>5238b7d5f4c81574ba914d609ac1e692</description></item>
    /// <item><term>ImprovedTrip</term><description>0f15c6f70d8fb2b49aa6cc24239cc5fa</description></item>
    /// <item><term>TwoHandedFighterStrongGrip</term><description>ab9d45de98fe56441a4c012f70dad6ee</description></item>
    /// </list>
    /// </remarks>
    ///
    /// <param name="merge">
    /// If mergeBehavior is ComponentMerge.Merge and the component already exists, this expression is called to merge the components.
    /// </param>
    /// <param name="mergeBehavior">
    /// Handling if the component already exists since the component is unique. Defaults to ComponentMerge.Fail.
    /// </param>
    public TBuilder AddManeuverDefenceBonus(
        int? bonus = null,
        ModifierDescriptor? descriptor = null,
        Action<BlueprintComponent, BlueprintComponent>? merge = null,
        ComponentMerge mergeBehavior = ComponentMerge.Merge,
        CombatManeuver? type = null)
    {
      var component = new ManeuverDefenceBonus();
      component.Bonus = bonus ?? component.Bonus;
      component.Descriptor = descriptor ?? component.Descriptor;
      component.Type = type ?? component.Type;
      return AddUniqueComponent(component, mergeBehavior, merge);
    }

    /// <summary>
    /// Adds <see cref="ManeuverImmunity"/>
    /// </summary>
    ///
    /// <remarks>
    ///
    /// <list type="bullet">
    /// <listheader>Used by</listheader>
    /// <item><term>AmuletOfDeepRootsFeature</term><description>27d0e6894ba6484a939efc0afe2b13fe</description></item>
    /// <item><term>MasteryBullRushImmunityFeature</term><description>783c4048cef012c4382457e37b528e4c</description></item>
    /// <item><term>TripImmunityFeature</term><description>e0ac733ba38f74d46a1712c95b9874f2</description></item>
    /// </list>
    /// </remarks>
    ///
    /// <param name="merge">
    /// If mergeBehavior is ComponentMerge.Merge and the component already exists, this expression is called to merge the components.
    /// </param>
    /// <param name="mergeBehavior">
    /// Handling if the component already exists since the component is unique. Defaults to ComponentMerge.Fail.
    /// </param>
    public TBuilder AddManeuverImmunity(
        Action<BlueprintComponent, BlueprintComponent>? merge = null,
        ComponentMerge mergeBehavior = ComponentMerge.Merge,
        CombatManeuver? type = null)
    {
      var component = new ManeuverImmunity();
      component.Type = type ?? component.Type;
      return AddUniqueComponent(component, mergeBehavior, merge);
    }

    /// <summary>
    /// Adds <see cref="ManeuverIncreaseDuration"/>
    /// </summary>
    ///
    /// <remarks>
    ///
    /// <list type="bullet">
    /// <listheader>Used by</listheader>
    /// <item><term>GreaterDirtyTrick</term><description>52c6b07a68940af41b270b3710682dc7</description></item>
    /// <item><term>GreaterDisarm</term><description>63d8e3a9ab4d72e4081a7862d7246a79</description></item>
    /// <item><term>GreaterSunder</term><description>54d824028117e884a8f9356c7c66149b</description></item>
    /// </list>
    /// </remarks>
    ///
    /// <param name="merge">
    /// If mergeBehavior is ComponentMerge.Merge and the component already exists, this expression is called to merge the components.
    /// </param>
    /// <param name="mergeBehavior">
    /// Handling if the component already exists since the component is unique. Defaults to ComponentMerge.Fail.
    /// </param>
    public TBuilder AddManeuverIncreaseDuration(
        Action<BlueprintComponent, BlueprintComponent>? merge = null,
        ComponentMerge mergeBehavior = ComponentMerge.Merge,
        CombatManeuver? type = null)
    {
      var component = new ManeuverIncreaseDuration();
      component.Type = type ?? component.Type;
      return AddUniqueComponent(component, mergeBehavior, merge);
    }

    /// <summary>
    /// Adds <see cref="ManeuverOnAttack"/>
    /// </summary>
    ///
    /// <remarks>
    ///
    /// <para>
    /// ComponentName: Weapon type attack bonus
    /// </para>
    ///
    /// <list type="bullet">
    /// <listheader>Used by</listheader>
    /// <item><term>CloakOfTheWinterWolfFeature</term><description>8031884b86552ba4fbb0ee4499fb9d3d</description></item>
    /// <item><term>RiftDrakeTailFeature</term><description>ce7093a2b90d5e942b7c19afeb7a8e9e</description></item>
    /// <item><term>TrippingBite</term><description>f957b4444b6fb404e84ae2a5765797bb</description></item>
    /// </list>
    /// </remarks>
    ///
    /// <param name="merge">
    /// If mergeBehavior is ComponentMerge.Merge and the component already exists, this expression is called to merge the components.
    /// </param>
    /// <param name="mergeBehavior">
    /// Handling if the component already exists since the component is unique. Defaults to ComponentMerge.Fail.
    /// </param>
    public TBuilder AddManeuverOnAttack(
        WeaponCategory? category = null,
        CombatManeuver? maneuver = null,
        Action<BlueprintComponent, BlueprintComponent>? merge = null,
        ComponentMerge mergeBehavior = ComponentMerge.Merge)
    {
      var component = new ManeuverOnAttack();
      component.Category = category ?? component.Category;
      component.Maneuver = maneuver ?? component.Maneuver;
      return AddUniqueComponent(component, mergeBehavior, merge);
    }

    /// <summary>
    /// Adds <see cref="ManeuverProvokeAttack"/>
    /// </summary>
    ///
    /// <remarks>
    ///
    /// <list type="bullet">
    /// <listheader>Used by</listheader>
    /// <item><term>GreaterTrip</term><description>4cc71ae82bdd85b40b3cfe6697bb7949</description></item>
    /// <item><term>JumpUp</term><description>9f2d35be63f68614b89c901db84dd750</description></item>
    /// </list>
    /// </remarks>
    ///
    /// <param name="merge">
    /// If mergeBehavior is ComponentMerge.Merge and the component already exists, this expression is called to merge the components.
    /// </param>
    /// <param name="mergeBehavior">
    /// Handling if the component already exists since the component is unique. Defaults to ComponentMerge.Fail.
    /// </param>
    public TBuilder AddManeuverProvokeAttack(
        CombatManeuver? maneuverType = null,
        Action<BlueprintComponent, BlueprintComponent>? merge = null,
        ComponentMerge mergeBehavior = ComponentMerge.Merge)
    {
      var component = new ManeuverProvokeAttack();
      component.ManeuverType = maneuverType ?? component.ManeuverType;
      return AddUniqueComponent(component, mergeBehavior, merge);
    }

    /// <summary>
    /// Adds <see cref="ManeuverTrigger"/>
    /// </summary>
    ///
    /// <remarks>
    ///
    /// <list type="bullet">
    /// <listheader>Used by</listheader>
    /// <item><term>BlightedTreant_Feature_Trample</term><description>a67f4e53dc3aeb04cabc429c224da724</description></item>
    /// <item><term>LabyrinthMinotaur_Feature_SteelShodHooves</term><description>d60e86244a27fcd458e2b0bb9d6db505</description></item>
    /// <item><term>SwordlordDisarmingStrike</term><description>c7ea46f5e1822994ba069c11819844ae</description></item>
    /// </list>
    /// </remarks>
    ///
    /// <param name="merge">
    /// If mergeBehavior is ComponentMerge.Merge and the component already exists, this expression is called to merge the components.
    /// </param>
    /// <param name="mergeBehavior">
    /// Handling if the component already exists since the component is unique. Defaults to ComponentMerge.Fail.
    /// </param>
    public TBuilder AddManeuverTrigger(
        ActionsBuilder? action = null,
        CombatManeuver? maneuverType = null,
        Action<BlueprintComponent, BlueprintComponent>? merge = null,
        ComponentMerge mergeBehavior = ComponentMerge.Merge,
        bool? onlySuccess = null)
    {
      var component = new ManeuverTrigger();
      component.Action = action?.Build() ?? component.Action;
      if (component.Action is null)
      {
        component.Action = Utils.Constants.Empty.Actions;
      }
      component.ManeuverType = maneuverType ?? component.ManeuverType;
      component.OnlySuccess = onlySuccess ?? component.OnlySuccess;
      return AddUniqueComponent(component, mergeBehavior, merge);
    }

    /// <summary>
    /// Adds <see cref="MaxDexBonusIncrease"/>
    /// </summary>
    ///
    /// <remarks>
    ///
    /// <para>
    /// ComponentName: Max Dex bonus increase
    /// </para>
    ///
    /// <list type="bullet">
    /// <listheader>Used by</listheader>
    /// <item><term>ArmorTraining</term><description>3c380607706f209499d951b29d3c44f3</description></item>
    /// <item><term>MaximumDexterityFeature</term><description>8fbf8e89433e5454099972d7811df267</description></item>
    /// <item><term>TowerShieldTraining</term><description>d2dbc71b45efa8749bd9c1924534b2bb</description></item>
    /// </list>
    /// </remarks>
    public TBuilder AddMaxDexBonusIncrease(
        int? bonesPerRank = null,
        int? bonus = null,
        ArmorProficiencyGroup? category = null,
        bool? checkCategory = null)
    {
      var component = new MaxDexBonusIncrease();
      component.BonesPerRank = bonesPerRank ?? component.BonesPerRank;
      component.Bonus = bonus ?? component.Bonus;
      component.Category = category ?? component.Category;
      component.CheckCategory = checkCategory ?? component.CheckCategory;
      return AddComponent(component);
    }

    /// <summary>
    /// Adds <see cref="MeleeWeaponSizeChange"/>
    /// </summary>
    ///
    /// <remarks>
    ///
    /// <para>
    /// ComponentName: Melee weapon size change
    /// </para>
    ///
    /// <list type="bullet">
    /// <listheader>Used by</listheader>
    /// <item><term>LeafBladesBuff</term><description>91f43163db96f8941a41e2b584a97514</description></item>
    /// <item><term>MonsterMythicWeaponSizeFeature</term><description>c0c002a0198b2864685ba1b969cbdb33</description></item>
    /// <item><term>RedcapFeature</term><description>d83423bb7237ce04b83487a46860eb6a</description></item>
    /// </list>
    /// </remarks>
    ///
    /// <param name="merge">
    /// If mergeBehavior is ComponentMerge.Merge and the component already exists, this expression is called to merge the components.
    /// </param>
    /// <param name="mergeBehavior">
    /// Handling if the component already exists since the component is unique. Defaults to ComponentMerge.Fail.
    /// </param>
    public TBuilder AddMeleeWeaponSizeChange(
        Action<BlueprintComponent, BlueprintComponent>? merge = null,
        ComponentMerge mergeBehavior = ComponentMerge.Merge,
        int? sizeCategoryChange = null)
    {
      var component = new MeleeWeaponSizeChange();
      component.SizeCategoryChange = sizeCategoryChange ?? component.SizeCategoryChange;
      return AddUniqueComponent(component, mergeBehavior, merge);
    }

    /// <summary>
    /// Adds <see cref="MinimizeAttacksOfOpportunityCount"/>
    /// </summary>
    ///
    /// <remarks>
    ///
    /// <list type="bullet">
    /// <listheader>Used by</listheader>
    /// <item><term>AeonAoOGazeEnemyHiddenBuff</term><description>8c0cb957952a47e6a284d7954e6d4fe0</description></item>
    /// </list>
    /// </remarks>
    public TBuilder AddMinimizeAttacksOfOpportunityCount()
    {
      return AddComponent(new MinimizeAttacksOfOpportunityCount());
    }

    /// <summary>
    /// Adds <see cref="ModifyD20"/>
    /// </summary>
    ///
    /// <remarks>
    ///
    /// <list type="bullet">
    /// <listheader>Used by</listheader>
    /// <item><term>AeonBaneBuff</term><description>345160619fc2ddc44b8ad98c94dde448</description></item>
    /// <item><term>IronWillMythicFeat</term><description>952147d43befd5b4ba853f24cd1368ee</description></item>
    /// <item><term>WitchHexProtectiveLuckEffectBuff</term><description>ffa995f03d87a214ab9de1dd898497ca</description></item>
    /// </list>
    /// </remarks>
    ///
    /// <param name="chance">
    /// <para>
    /// Tooltip: [0..100]
    /// </para>
    /// </param>
    /// <param name="merge">
    /// If mergeBehavior is ComponentMerge.Merge and the component already exists, this expression is called to merge the components.
    /// </param>
    /// <param name="mergeBehavior">
    /// Handling if the component already exists since the component is unique. Defaults to ComponentMerge.Fail.
    /// </param>
    /// <param name="tandemTripFeature">
    /// <para>
    /// Blueprint of type BlueprintFeature. You can pass in the blueprint using:
    /// <list type ="bullet">
    ///   <item><term>A blueprint instance</term></item>
    ///   <item><term>A blueprint reference</term></item>
    ///   <item><term>A blueprint id as a string, Guid, or BlueprintGuid</term></item>
    ///   <item><term>A blueprint name registered with <see cref="BlueprintCore.Utils.BlueprintTool">BlueprintTool</see></term></item>
    /// </list>
    /// See <see cref="BlueprintCore.Utils.Blueprint{{T, TRef}}">Blueprint</see> for more details.
    /// </para>
    /// </param>
    public TBuilder AddModifyD20(
        bool? addBonus = null,
        bool? addSavingThrowBonus = null,
        bool? againstAlignment = null,
        AlignmentComponent? alignment = null,
        ContextValue? bonus = null,
        ModifierDescriptor? bonusDescriptor = null,
        ContextValue? chance = null,
        RuleDispelMagic.CheckType? dispellMagicCheckType = null,
        bool? dispellOn20 = null,
        bool? dispellOnRerollFinished = null,
        Action<BlueprintComponent, BlueprintComponent>? merge = null,
        ComponentMerge mergeBehavior = ComponentMerge.Merge,
        ModifierDescriptor? modifierDescriptor = null,
        bool? replace = null,
        bool? rerollOnlyIfFailed = null,
        bool? rerollOnlyIfSuccess = null,
        ModifyD20.RollConditionType? rollCondition = null,
        ContextValue? rollResult = null,
        int? rollsAmount = null,
        RuleType? rule = null,
        ModifyD20.InnerSavingThrowType? savingThrowType = null,
        StatType[]? skill = null,
        bool? specificDescriptor = null,
        bool? specificSkill = null,
        SpellDescriptorWrapper? spellDescriptor = null,
        bool? takeBest = null,
        bool? tandemTrip = null,
        Blueprint<BlueprintFeature, BlueprintFeatureReference>? tandemTripFeature = null,
        bool? targetAlignment = null,
        ContextValue? value = null,
        ContextValue? valueToCompareRoll = null,
        bool? withChance = null)
    {
      var component = new ModifyD20();
      component.AddBonus = addBonus ?? component.AddBonus;
      component.AddSavingThrowBonus = addSavingThrowBonus ?? component.AddSavingThrowBonus;
      component.AgainstAlignment = againstAlignment ?? component.AgainstAlignment;
      component.Alignment = alignment ?? component.Alignment;
      component.Bonus = bonus ?? component.Bonus;
      if (component.Bonus is null)
      {
        component.Bonus = ContextValues.Constant(0);
      }
      component.BonusDescriptor = bonusDescriptor ?? component.BonusDescriptor;
      component.Chance = chance ?? component.Chance;
      if (component.Chance is null)
      {
        component.Chance = ContextValues.Constant(0);
      }
      component.DispellMagicCheckType = dispellMagicCheckType ?? component.DispellMagicCheckType;
      component.DispellOn20 = dispellOn20 ?? component.DispellOn20;
      component.DispellOnRerollFinished = dispellOnRerollFinished ?? component.DispellOnRerollFinished;
      component.ModifierDescriptor = modifierDescriptor ?? component.ModifierDescriptor;
      component.Replace = replace ?? component.Replace;
      component.RerollOnlyIfFailed = rerollOnlyIfFailed ?? component.RerollOnlyIfFailed;
      component.RerollOnlyIfSuccess = rerollOnlyIfSuccess ?? component.RerollOnlyIfSuccess;
      component.RollCondition = rollCondition ?? component.RollCondition;
      component.RollResult = rollResult ?? component.RollResult;
      if (component.RollResult is null)
      {
        component.RollResult = ContextValues.Constant(0);
      }
      component.RollsAmount = rollsAmount ?? component.RollsAmount;
      component.Rule = rule ?? component.Rule;
      component.m_SavingThrowType = savingThrowType ?? component.m_SavingThrowType;
      component.Skill = skill ?? component.Skill;
      if (component.Skill is null)
      {
        component.Skill = new StatType[0];
      }
      component.SpecificDescriptor = specificDescriptor ?? component.SpecificDescriptor;
      component.SpecificSkill = specificSkill ?? component.SpecificSkill;
      component.SpellDescriptor = spellDescriptor ?? component.SpellDescriptor;
      component.TakeBest = takeBest ?? component.TakeBest;
      component.TandemTrip = tandemTrip ?? component.TandemTrip;
      component.m_TandemTripFeature = tandemTripFeature?.Reference ?? component.m_TandemTripFeature;
      if (component.m_TandemTripFeature is null)
      {
        component.m_TandemTripFeature = BlueprintTool.GetRef<BlueprintFeatureReference>(null);
      }
      component.TargetAlignment = targetAlignment ?? component.TargetAlignment;
      component.Value = value ?? component.Value;
      if (component.Value is null)
      {
        component.Value = ContextValues.Constant(0);
      }
      component.ValueToCompareRoll = valueToCompareRoll ?? component.ValueToCompareRoll;
      if (component.ValueToCompareRoll is null)
      {
        component.ValueToCompareRoll = ContextValues.Constant(0);
      }
      component.WithChance = withChance ?? component.WithChance;
      return AddUniqueComponent(component, mergeBehavior, merge);
    }

    /// <summary>
    /// Adds <see cref="MonkReplaceAbilityDC"/>
    /// </summary>
    ///
    /// <remarks>
    ///
    /// <list type="bullet">
    /// <listheader>Used by</listheader>
    /// <item><term>DragonRoarFeature</term><description>3fca938ad6a5b8348a8523794127c5bc</description></item>
    /// <item><term>StunningFist</term><description>a29a582c3daa4c24bb0e991c596ccb28</description></item>
    /// </list>
    /// </remarks>
    ///
    /// <param name="ability">
    /// <para>
    /// Blueprint of type BlueprintAbility. You can pass in the blueprint using:
    /// <list type ="bullet">
    ///   <item><term>A blueprint instance</term></item>
    ///   <item><term>A blueprint reference</term></item>
    ///   <item><term>A blueprint id as a string, Guid, or BlueprintGuid</term></item>
    ///   <item><term>A blueprint name registered with <see cref="BlueprintCore.Utils.BlueprintTool">BlueprintTool</see></term></item>
    /// </list>
    /// See <see cref="BlueprintCore.Utils.Blueprint{{T, TRef}}">Blueprint</see> for more details.
    /// </para>
    /// </param>
    /// <param name="merge">
    /// If mergeBehavior is ComponentMerge.Merge and the component already exists, this expression is called to merge the components.
    /// </param>
    /// <param name="mergeBehavior">
    /// Handling if the component already exists since the component is unique. Defaults to ComponentMerge.Fail.
    /// </param>
    /// <param name="monk">
    /// <para>
    /// Blueprint of type BlueprintCharacterClass. You can pass in the blueprint using:
    /// <list type ="bullet">
    ///   <item><term>A blueprint instance</term></item>
    ///   <item><term>A blueprint reference</term></item>
    ///   <item><term>A blueprint id as a string, Guid, or BlueprintGuid</term></item>
    ///   <item><term>A blueprint name registered with <see cref="BlueprintCore.Utils.BlueprintTool">BlueprintTool</see></term></item>
    /// </list>
    /// See <see cref="BlueprintCore.Utils.Blueprint{{T, TRef}}">Blueprint</see> for more details.
    /// </para>
    /// </param>
    /// <param name="scaledFist">
    /// <para>
    /// Blueprint of type BlueprintArchetype. You can pass in the blueprint using:
    /// <list type ="bullet">
    ///   <item><term>A blueprint instance</term></item>
    ///   <item><term>A blueprint reference</term></item>
    ///   <item><term>A blueprint id as a string, Guid, or BlueprintGuid</term></item>
    ///   <item><term>A blueprint name registered with <see cref="BlueprintCore.Utils.BlueprintTool">BlueprintTool</see></term></item>
    /// </list>
    /// See <see cref="BlueprintCore.Utils.Blueprint{{T, TRef}}">Blueprint</see> for more details.
    /// </para>
    /// </param>
    public TBuilder AddMonkReplaceAbilityDC(
        Blueprint<BlueprintAbility, BlueprintAbilityReference>? ability = null,
        Action<BlueprintComponent, BlueprintComponent>? merge = null,
        ComponentMerge mergeBehavior = ComponentMerge.Merge,
        Blueprint<BlueprintCharacterClass, BlueprintCharacterClassReference>? monk = null,
        Blueprint<BlueprintArchetype, BlueprintArchetypeReference>? scaledFist = null)
    {
      var component = new MonkReplaceAbilityDC();
      component.m_Ability = ability?.Reference ?? component.m_Ability;
      if (component.m_Ability is null)
      {
        component.m_Ability = BlueprintTool.GetRef<BlueprintAbilityReference>(null);
      }
      component.m_Monk = monk?.Reference ?? component.m_Monk;
      if (component.m_Monk is null)
      {
        component.m_Monk = BlueprintTool.GetRef<BlueprintCharacterClassReference>(null);
      }
      component.m_ScaledFist = scaledFist?.Reference ?? component.m_ScaledFist;
      if (component.m_ScaledFist is null)
      {
        component.m_ScaledFist = BlueprintTool.GetRef<BlueprintArchetypeReference>(null);
      }
      return AddUniqueComponent(component, mergeBehavior, merge);
    }

    /// <summary>
    /// Adds <see cref="MythicUnarmedStrike"/>
    /// </summary>
    ///
    /// <remarks>
    ///
    /// <para>
    /// ComponentName: Weapon type damage bonus
    /// </para>
    ///
    /// <list type="bullet">
    /// <listheader>Used by</listheader>
    /// <item><term>ImprovedUnarmedStrikeMythicFeat</term><description>e086a07dae105244291fb11e05d0715f</description></item>
    /// </list>
    /// </remarks>
    ///
    /// <param name="merge">
    /// If mergeBehavior is ComponentMerge.Merge and the component already exists, this expression is called to merge the components.
    /// </param>
    /// <param name="mergeBehavior">
    /// Handling if the component already exists since the component is unique. Defaults to ComponentMerge.Fail.
    /// </param>
    public TBuilder AddMythicUnarmedStrike(
        Action<BlueprintComponent, BlueprintComponent>? merge = null,
        ComponentMerge mergeBehavior = ComponentMerge.Merge)
    {
      var component = new MythicUnarmedStrike();
      return AddUniqueComponent(component, mergeBehavior, merge);
    }

    /// <summary>
    /// Adds <see cref="NewRoundTrigger"/>
    /// </summary>
    ///
    /// <remarks>
    ///
    /// <list type="bullet">
    /// <listheader>Used by</listheader>
    /// <item><term>ArmyLocust4GhlaunderPlagueBuff</term><description>d5c2f709e1b842e3aa2a8355cfcdf098</description></item>
    /// <item><term>ShatterConfidenceBuffCaster</term><description>8b41f9f3e8350a84aa3126bf543e273c</description></item>
    /// <item><term>VoicesOfHollowBuff</term><description>29c2a73eef47cfb4f90014df452716fe</description></item>
    /// </list>
    /// </remarks>
    public TBuilder AddNewRoundTrigger(
        ActionsBuilder? newRoundActions = null)
    {
      var component = new NewRoundTrigger();
      component.NewRoundActions = newRoundActions?.Build() ?? component.NewRoundActions;
      if (component.NewRoundActions is null)
      {
        component.NewRoundActions = Utils.Constants.Empty.Actions;
      }
      return AddComponent(component);
    }

    /// <summary>
    /// Adds <see cref="OnSpawnBuff"/>
    /// </summary>
    ///
    /// <remarks>
    ///
    /// <para>
    /// ComponentName: Buff on spawned unit
    /// </para>
    ///
    /// <list type="bullet">
    /// <listheader>Used by</listheader>
    /// <item><term>AeonImprovedBaneFeature</term><description>bbf227fe76f1eaa418a95e6095145ce8</description></item>
    /// <item><term>DLC1_Marhevok_Welcome</term><description>4f3073fefbd7459f8420b7a698bbc4ab</description></item>
    /// <item><term>WoljifKid</term><description>4c1bb837077dc4441af989d22e142ea0</description></item>
    /// </list>
    /// </remarks>
    ///
    /// <param name="buff">
    /// <para>
    /// Blueprint of type BlueprintBuff. You can pass in the blueprint using:
    /// <list type ="bullet">
    ///   <item><term>A blueprint instance</term></item>
    ///   <item><term>A blueprint reference</term></item>
    ///   <item><term>A blueprint id as a string, Guid, or BlueprintGuid</term></item>
    ///   <item><term>A blueprint name registered with <see cref="BlueprintCore.Utils.BlueprintTool">BlueprintTool</see></term></item>
    /// </list>
    /// See <see cref="BlueprintCore.Utils.Blueprint{{T, TRef}}">Blueprint</see> for more details.
    /// </para>
    /// </param>
    /// <param name="ifHaveFact">
    /// <para>
    /// InfoBox: Caster's Fact
    /// </para>
    /// <para>
    /// Blueprint of type BlueprintFeature. You can pass in the blueprint using:
    /// <list type ="bullet">
    ///   <item><term>A blueprint instance</term></item>
    ///   <item><term>A blueprint reference</term></item>
    ///   <item><term>A blueprint id as a string, Guid, or BlueprintGuid</term></item>
    ///   <item><term>A blueprint name registered with <see cref="BlueprintCore.Utils.BlueprintTool">BlueprintTool</see></term></item>
    /// </list>
    /// See <see cref="BlueprintCore.Utils.Blueprint{{T, TRef}}">Blueprint</see> for more details.
    /// </para>
    /// </param>
    /// <param name="ifSummonHaveFact">
    /// <para>
    /// Blueprint of type BlueprintFeature. You can pass in the blueprint using:
    /// <list type ="bullet">
    ///   <item><term>A blueprint instance</term></item>
    ///   <item><term>A blueprint reference</term></item>
    ///   <item><term>A blueprint id as a string, Guid, or BlueprintGuid</term></item>
    ///   <item><term>A blueprint name registered with <see cref="BlueprintCore.Utils.BlueprintTool">BlueprintTool</see></term></item>
    /// </list>
    /// See <see cref="BlueprintCore.Utils.Blueprint{{T, TRef}}">Blueprint</see> for more details.
    /// </para>
    /// </param>
    /// <param name="merge">
    /// If mergeBehavior is ComponentMerge.Merge and the component already exists, this expression is called to merge the components.
    /// </param>
    /// <param name="mergeBehavior">
    /// Handling if the component already exists since the component is unique. Defaults to ComponentMerge.Fail.
    /// </param>
    public TBuilder AddOnSpawnBuff(
        Blueprint<BlueprintBuff, BlueprintBuffReference>? buff = null,
        bool? checkDescriptor = null,
        bool? checkSummonedUnitAlignment = null,
        bool? checkSummonedUnitFact = null,
        Rounds? duration = null,
        Blueprint<BlueprintFeature, BlueprintFeatureReference>? ifHaveFact = null,
        Blueprint<BlueprintFeature, BlueprintFeatureReference>? ifSummonHaveFact = null,
        bool? isInfinity = null,
        Action<BlueprintComponent, BlueprintComponent>? merge = null,
        ComponentMerge mergeBehavior = ComponentMerge.Merge,
        SpellDescriptorWrapper? spellDescriptor = null,
        AlignmentComponent? summonedAlignment = null)
    {
      var component = new OnSpawnBuff();
      component.m_buff = buff?.Reference ?? component.m_buff;
      if (component.m_buff is null)
      {
        component.m_buff = BlueprintTool.GetRef<BlueprintBuffReference>(null);
      }
      component.CheckDescriptor = checkDescriptor ?? component.CheckDescriptor;
      component.CheckSummonedUnitAlignment = checkSummonedUnitAlignment ?? component.CheckSummonedUnitAlignment;
      component.CheckSummonedUnitFact = checkSummonedUnitFact ?? component.CheckSummonedUnitFact;
      component.duration = duration ?? component.duration;
      component.m_IfHaveFact = ifHaveFact?.Reference ?? component.m_IfHaveFact;
      if (component.m_IfHaveFact is null)
      {
        component.m_IfHaveFact = BlueprintTool.GetRef<BlueprintFeatureReference>(null);
      }
      component.m_IfSummonHaveFact = ifSummonHaveFact?.Reference ?? component.m_IfSummonHaveFact;
      if (component.m_IfSummonHaveFact is null)
      {
        component.m_IfSummonHaveFact = BlueprintTool.GetRef<BlueprintFeatureReference>(null);
      }
      component.IsInfinity = isInfinity ?? component.IsInfinity;
      component.SpellDescriptor = spellDescriptor ?? component.SpellDescriptor;
      component.SummonedAlignment = summonedAlignment ?? component.SummonedAlignment;
      return AddUniqueComponent(component, mergeBehavior, merge);
    }

    /// <summary>
    /// Adds <see cref="Opportunist"/>
    /// </summary>
    ///
    /// <remarks>
    ///
    /// <list type="bullet">
    /// <listheader>Used by</listheader>
    /// <item><term>Opportunist</term><description>5bb6dc5ce00550441880a6ff8ad4c968</description></item>
    /// </list>
    /// </remarks>
    ///
    /// <param name="merge">
    /// If mergeBehavior is ComponentMerge.Merge and the component already exists, this expression is called to merge the components.
    /// </param>
    /// <param name="mergeBehavior">
    /// Handling if the component already exists since the component is unique. Defaults to ComponentMerge.Fail.
    /// </param>
    public TBuilder AddOpportunist(
        Action<BlueprintComponent, BlueprintComponent>? merge = null,
        ComponentMerge mergeBehavior = ComponentMerge.Merge)
    {
      var component = new Opportunist();
      return AddUniqueComponent(component, mergeBehavior, merge);
    }

    /// <summary>
    /// Adds <see cref="OutflankAttackBonus"/>
    /// </summary>
    ///
    /// <remarks>
    ///
    /// <list type="bullet">
    /// <listheader>Used by</listheader>
    /// <item><term>ArmyOutflankFeature</term><description>73aff838bd3b49d491793d08f7e8c1e5</description></item>
    /// <item><term>Outflank</term><description>422dab7309e1ad343935f33a4d6e9f11</description></item>
    /// <item><term>TeamworkFeature</term><description>bf416f1805710104cad270bd81727274</description></item>
    /// </list>
    /// </remarks>
    ///
    /// <param name="merge">
    /// If mergeBehavior is ComponentMerge.Merge and the component already exists, this expression is called to merge the components.
    /// </param>
    /// <param name="mergeBehavior">
    /// Handling if the component already exists since the component is unique. Defaults to ComponentMerge.Fail.
    /// </param>
    /// <param name="outflankFact">
    /// <para>
    /// Blueprint of type BlueprintUnitFact. You can pass in the blueprint using:
    /// <list type ="bullet">
    ///   <item><term>A blueprint instance</term></item>
    ///   <item><term>A blueprint reference</term></item>
    ///   <item><term>A blueprint id as a string, Guid, or BlueprintGuid</term></item>
    ///   <item><term>A blueprint name registered with <see cref="BlueprintCore.Utils.BlueprintTool">BlueprintTool</see></term></item>
    /// </list>
    /// See <see cref="BlueprintCore.Utils.Blueprint{{T, TRef}}">Blueprint</see> for more details.
    /// </para>
    /// </param>
    public TBuilder AddOutflankAttackBonus(
        int? attackBonus = null,
        ModifierDescriptor? descriptor = null,
        Action<BlueprintComponent, BlueprintComponent>? merge = null,
        ComponentMerge mergeBehavior = ComponentMerge.Merge,
        Blueprint<BlueprintUnitFact, BlueprintUnitFactReference>? outflankFact = null)
    {
      var component = new OutflankAttackBonus();
      component.AttackBonus = attackBonus ?? component.AttackBonus;
      component.Descriptor = descriptor ?? component.Descriptor;
      component.m_OutflankFact = outflankFact?.Reference ?? component.m_OutflankFact;
      if (component.m_OutflankFact is null)
      {
        component.m_OutflankFact = BlueprintTool.GetRef<BlueprintUnitFactReference>(null);
      }
      return AddUniqueComponent(component, mergeBehavior, merge);
    }

    /// <summary>
    /// Adds <see cref="OutflankDamageBonus"/>
    /// </summary>
    ///
    /// <remarks>
    ///
    /// <list type="bullet">
    /// <listheader>Used by</listheader>
    /// <item><term>Azata1SongOfThePeopleBuff</term><description>87b23796bb1b49ca96c0da8a7b298ebf</description></item>
    /// <item><term>ChainmailOfComraderyFeature</term><description>b0d0ed812d973224ca2ba1cbb22c94c6</description></item>
    /// </list>
    /// </remarks>
    ///
    /// <param name="merge">
    /// If mergeBehavior is ComponentMerge.Merge and the component already exists, this expression is called to merge the components.
    /// </param>
    /// <param name="mergeBehavior">
    /// Handling if the component already exists since the component is unique. Defaults to ComponentMerge.Fail.
    /// </param>
    /// <param name="outflankFact">
    /// <para>
    /// Blueprint of type BlueprintUnitFact. You can pass in the blueprint using:
    /// <list type ="bullet">
    ///   <item><term>A blueprint instance</term></item>
    ///   <item><term>A blueprint reference</term></item>
    ///   <item><term>A blueprint id as a string, Guid, or BlueprintGuid</term></item>
    ///   <item><term>A blueprint name registered with <see cref="BlueprintCore.Utils.BlueprintTool">BlueprintTool</see></term></item>
    /// </list>
    /// See <see cref="BlueprintCore.Utils.Blueprint{{T, TRef}}">Blueprint</see> for more details.
    /// </para>
    /// </param>
    public TBuilder AddOutflankDamageBonus(
        int? damageBonus = null,
        int? increasedDamageBonus = null,
        Action<BlueprintComponent, BlueprintComponent>? merge = null,
        ComponentMerge mergeBehavior = ComponentMerge.Merge,
        Blueprint<BlueprintUnitFact, BlueprintUnitFactReference>? outflankFact = null)
    {
      var component = new OutflankDamageBonus();
      component.DamageBonus = damageBonus ?? component.DamageBonus;
      component.IncreasedDamageBonus = increasedDamageBonus ?? component.IncreasedDamageBonus;
      component.m_OutflankFact = outflankFact?.Reference ?? component.m_OutflankFact;
      if (component.m_OutflankFact is null)
      {
        component.m_OutflankFact = BlueprintTool.GetRef<BlueprintUnitFactReference>(null);
      }
      return AddUniqueComponent(component, mergeBehavior, merge);
    }

    /// <summary>
    /// Adds <see cref="OutflankProvokeAttack"/>
    /// </summary>
    ///
    /// <remarks>
    ///
    /// <list type="bullet">
    /// <listheader>Used by</listheader>
    /// <item><term>Outflank</term><description>422dab7309e1ad343935f33a4d6e9f11</description></item>
    /// </list>
    /// </remarks>
    ///
    /// <param name="merge">
    /// If mergeBehavior is ComponentMerge.Merge and the component already exists, this expression is called to merge the components.
    /// </param>
    /// <param name="mergeBehavior">
    /// Handling if the component already exists since the component is unique. Defaults to ComponentMerge.Fail.
    /// </param>
    /// <param name="outflankFact">
    /// <para>
    /// Blueprint of type BlueprintUnitFact. You can pass in the blueprint using:
    /// <list type ="bullet">
    ///   <item><term>A blueprint instance</term></item>
    ///   <item><term>A blueprint reference</term></item>
    ///   <item><term>A blueprint id as a string, Guid, or BlueprintGuid</term></item>
    ///   <item><term>A blueprint name registered with <see cref="BlueprintCore.Utils.BlueprintTool">BlueprintTool</see></term></item>
    /// </list>
    /// See <see cref="BlueprintCore.Utils.Blueprint{{T, TRef}}">Blueprint</see> for more details.
    /// </para>
    /// </param>
    public TBuilder AddOutflankProvokeAttack(
        Action<BlueprintComponent, BlueprintComponent>? merge = null,
        ComponentMerge mergeBehavior = ComponentMerge.Merge,
        Blueprint<BlueprintUnitFact, BlueprintUnitFactReference>? outflankFact = null)
    {
      var component = new OutflankProvokeAttack();
      component.m_OutflankFact = outflankFact?.Reference ?? component.m_OutflankFact;
      if (component.m_OutflankFact is null)
      {
        component.m_OutflankFact = BlueprintTool.GetRef<BlueprintUnitFactReference>(null);
      }
      return AddUniqueComponent(component, mergeBehavior, merge);
    }

    /// <summary>
    /// Adds <see cref="PartialDRIgnore"/>
    /// </summary>
    ///
    /// <remarks>
    ///
    /// <list type="bullet">
    /// <listheader>Used by</listheader>
    /// <item><term>ArmyArcaneStrikeFeature</term><description>89108b1d7c7d42589ef495ddf33c5b35</description></item>
    /// <item><term>RitualTrueStrikeBuff</term><description>0a870bd3199049eca81d27f2e4cd3fa8</description></item>
    /// </list>
    /// </remarks>
    public TBuilder AddPartialDRIgnore(
        int? reductionReduction = null)
    {
      var component = new PartialDRIgnore();
      component.ReductionReduction = reductionReduction ?? component.ReductionReduction;
      return AddComponent(component);
    }

    /// <summary>
    /// Adds <see cref="PenetratingStrike"/>
    /// </summary>
    ///
    /// <remarks>
    ///
    /// <para>
    /// ComponentName: Reduces DR against weapons with Focus
    /// </para>
    ///
    /// <list type="bullet">
    /// <listheader>Used by</listheader>
    /// <item><term>GreaterPenetratingStrike</term><description>eb6eb946c68ef094f89c7633f5bfdc9b</description></item>
    /// <item><term>PenetratingStrike</term><description>308cd7dc4f10efd428f531bbf4f2823d</description></item>
    /// </list>
    /// </remarks>
    public TBuilder AddPenetratingStrike(
        int? reductionReduction = null)
    {
      var component = new PenetratingStrike();
      component.ReductionReduction = reductionReduction ?? component.ReductionReduction;
      return AddComponent(component);
    }

    /// <summary>
    /// Adds <see cref="PetManeuverProvokeAttack"/>
    /// </summary>
    ///
    /// <remarks>
    ///
    /// <list type="bullet">
    /// <listheader>Used by</listheader>
    /// <item><term>MadDogThroatCutterPet</term><description>65a170770daec324d9a5e14c2b9dbcf7</description></item>
    /// </list>
    /// </remarks>
    ///
    /// <param name="merge">
    /// If mergeBehavior is ComponentMerge.Merge and the component already exists, this expression is called to merge the components.
    /// </param>
    /// <param name="mergeBehavior">
    /// Handling if the component already exists since the component is unique. Defaults to ComponentMerge.Fail.
    /// </param>
    public TBuilder AddPetManeuverProvokeAttack(
        CombatManeuver[]? maneuver = null,
        Action<BlueprintComponent, BlueprintComponent>? merge = null,
        ComponentMerge mergeBehavior = ComponentMerge.Merge)
    {
      var component = new PetManeuverProvokeAttack();
      component.Maneuver = maneuver ?? component.Maneuver;
      if (component.Maneuver is null)
      {
        component.Maneuver = new CombatManeuver[0];
      }
      return AddUniqueComponent(component, mergeBehavior, merge);
    }

    /// <summary>
    /// Adds <see cref="PointBlankMaster"/>
    /// </summary>
    ///
    /// <remarks>
    ///
    /// <list type="bullet">
    /// <listheader>Used by</listheader>
    /// <item><term>AirBlessingMinorBuff</term><description>0152e0ba776ada84c9bbb1d447819c06</description></item>
    /// <item><term>PointBlankMasterBomb</term><description>44faeffbb7463e140bbda6c61e595d16</description></item>
    /// <item><term>TaintedRetrieverEyeRaysNoAoO</term><description>3f2d87d09359412abb6c00943183991d</description></item>
    /// </list>
    /// </remarks>
    ///
    /// <param name="merge">
    /// If mergeBehavior is ComponentMerge.Merge and the component already exists, this expression is called to merge the components.
    /// </param>
    /// <param name="mergeBehavior">
    /// Handling if the component already exists since the component is unique. Defaults to ComponentMerge.Fail.
    /// </param>
    public TBuilder AddPointBlankMaster(
        WeaponCategory? category = null,
        Action<BlueprintComponent, BlueprintComponent>? merge = null,
        ComponentMerge mergeBehavior = ComponentMerge.Merge)
    {
      var component = new PointBlankMaster();
      component.Category = category ?? component.Category;
      return AddUniqueComponent(component, mergeBehavior, merge);
    }

    /// <summary>
    /// Adds <see cref="PointBlankMasterParametrized"/>
    /// </summary>
    ///
    /// <remarks>
    ///
    /// <list type="bullet">
    /// <listheader>Used by</listheader>
    /// <item><term>PointBlankMaster</term><description>05a3b543b0a0a0346a5061e90f293f0b</description></item>
    /// </list>
    /// </remarks>
    ///
    /// <param name="merge">
    /// If mergeBehavior is ComponentMerge.Merge and the component already exists, this expression is called to merge the components.
    /// </param>
    /// <param name="mergeBehavior">
    /// Handling if the component already exists since the component is unique. Defaults to ComponentMerge.Fail.
    /// </param>
    public TBuilder AddPointBlankMasterParametrized(
        Action<BlueprintComponent, BlueprintComponent>? merge = null,
        ComponentMerge mergeBehavior = ComponentMerge.Merge)
    {
      var component = new PointBlankMasterParametrized();
      return AddUniqueComponent(component, mergeBehavior, merge);
    }

    /// <summary>
    /// Adds <see cref="PowerAttackWatcher"/>
    /// </summary>
    ///
    /// <remarks>
    ///
    /// <para>
    /// ComponentName: Weapon type attack bonus
    /// </para>
    ///
    /// <list type="bullet">
    /// <listheader>Used by</listheader>
    /// <item><term>DeadlyAimFeature</term><description>f47df34d53f8c904f9981a3ee8e84892</description></item>
    /// <item><term>PowerAttackFeature</term><description>9972f33f977fc724c838e59641b2fca5</description></item>
    /// </list>
    /// </remarks>
    ///
    /// <param name="merge">
    /// If mergeBehavior is ComponentMerge.Merge and the component already exists, this expression is called to merge the components.
    /// </param>
    /// <param name="mergeBehavior">
    /// Handling if the component already exists since the component is unique. Defaults to ComponentMerge.Fail.
    /// </param>
    /// <param name="powerAttackBlueprint">
    /// <para>
    /// Blueprint of type BlueprintActivatableAbility. You can pass in the blueprint using:
    /// <list type ="bullet">
    ///   <item><term>A blueprint instance</term></item>
    ///   <item><term>A blueprint reference</term></item>
    ///   <item><term>A blueprint id as a string, Guid, or BlueprintGuid</term></item>
    ///   <item><term>A blueprint name registered with <see cref="BlueprintCore.Utils.BlueprintTool">BlueprintTool</see></term></item>
    /// </list>
    /// See <see cref="BlueprintCore.Utils.Blueprint{{T, TRef}}">Blueprint</see> for more details.
    /// </para>
    /// </param>
    public TBuilder AddPowerAttackWatcher(
        Action<BlueprintComponent, BlueprintComponent>? merge = null,
        ComponentMerge mergeBehavior = ComponentMerge.Merge,
        Blueprint<BlueprintActivatableAbility, BlueprintActivatableAbilityReference>? powerAttackBlueprint = null)
    {
      var component = new PowerAttackWatcher();
      component.m_PowerAttackBlueprint = powerAttackBlueprint?.Reference ?? component.m_PowerAttackBlueprint;
      if (component.m_PowerAttackBlueprint is null)
      {
        component.m_PowerAttackBlueprint = BlueprintTool.GetRef<BlueprintActivatableAbilityReference>(null);
      }
      return AddUniqueComponent(component, mergeBehavior, merge);
    }

    /// <summary>
    /// Adds <see cref="PreciseShot"/>
    /// </summary>
    ///
    /// <remarks>
    ///
    /// <para>
    /// ComponentName: Ignore penalty to ranged attack in combat
    /// </para>
    ///
    /// <list type="bullet">
    /// <listheader>Used by</listheader>
    /// <item><term>PreciseShot</term><description>8f3d1e6b4be006f4d896081f2f889665</description></item>
    /// <item><term>RingOfSharpStrikeFeature</term><description>80509af6a726dbd4aaccbda7096d9253</description></item>
    /// </list>
    /// </remarks>
    public TBuilder AddPreciseShot()
    {
      return AddComponent(new PreciseShot());
    }

    /// <summary>
    /// Adds <see cref="PreciseShotDivineHunterTarget"/>
    /// </summary>
    ///
    /// <remarks>
    ///
    /// <list type="bullet">
    /// <listheader>Used by</listheader>
    /// <item><term>SharedPrecisionTargetBuff</term><description>d5960c0203ad9ee48b8e4420a252273d</description></item>
    /// <item><term>VolleyFireCooldownBuff</term><description>0d02b41741498e8478695d77ab527b03</description></item>
    /// </list>
    /// </remarks>
    ///
    /// <param name="buff">
    /// <para>
    /// Blueprint of type BlueprintBuff. You can pass in the blueprint using:
    /// <list type ="bullet">
    ///   <item><term>A blueprint instance</term></item>
    ///   <item><term>A blueprint reference</term></item>
    ///   <item><term>A blueprint id as a string, Guid, or BlueprintGuid</term></item>
    ///   <item><term>A blueprint name registered with <see cref="BlueprintCore.Utils.BlueprintTool">BlueprintTool</see></term></item>
    /// </list>
    /// See <see cref="BlueprintCore.Utils.Blueprint{{T, TRef}}">Blueprint</see> for more details.
    /// </para>
    /// </param>
    public TBuilder AddPreciseShotDivineHunterTarget(
        Blueprint<BlueprintBuff, BlueprintBuffReference>? buff = null)
    {
      var component = new PreciseShotDivineHunterTarget();
      component.m_Buff = buff?.Reference ?? component.m_Buff;
      if (component.m_Buff is null)
      {
        component.m_Buff = BlueprintTool.GetRef<BlueprintBuffReference>(null);
      }
      return AddComponent(component);
    }

    /// <summary>
    /// Adds <see cref="PreciseStrike"/>
    /// </summary>
    ///
    /// <remarks>
    ///
    /// <list type="bullet">
    /// <listheader>Used by</listheader>
    /// <item><term>PreciseStrike</term><description>5662d1b793db90c4b9ba68037fd2a768</description></item>
    /// </list>
    /// </remarks>
    ///
    /// <param name="merge">
    /// If mergeBehavior is ComponentMerge.Merge and the component already exists, this expression is called to merge the components.
    /// </param>
    /// <param name="mergeBehavior">
    /// Handling if the component already exists since the component is unique. Defaults to ComponentMerge.Fail.
    /// </param>
    /// <param name="preciseStrikeFact">
    /// <para>
    /// Blueprint of type BlueprintUnitFact. You can pass in the blueprint using:
    /// <list type ="bullet">
    ///   <item><term>A blueprint instance</term></item>
    ///   <item><term>A blueprint reference</term></item>
    ///   <item><term>A blueprint id as a string, Guid, or BlueprintGuid</term></item>
    ///   <item><term>A blueprint name registered with <see cref="BlueprintCore.Utils.BlueprintTool">BlueprintTool</see></term></item>
    /// </list>
    /// See <see cref="BlueprintCore.Utils.Blueprint{{T, TRef}}">Blueprint</see> for more details.
    /// </para>
    /// </param>
    public TBuilder AddPreciseStrike(
        DamageDescription? damage = null,
        Action<BlueprintComponent, BlueprintComponent>? merge = null,
        ComponentMerge mergeBehavior = ComponentMerge.Merge,
        Blueprint<BlueprintUnitFact, BlueprintUnitFactReference>? preciseStrikeFact = null)
    {
      var component = new PreciseStrike();
      Validate(damage);
      component.Damage = damage ?? component.Damage;
      component.m_PreciseStrikeFact = preciseStrikeFact?.Reference ?? component.m_PreciseStrikeFact;
      if (component.m_PreciseStrikeFact is null)
      {
        component.m_PreciseStrikeFact = BlueprintTool.GetRef<BlueprintUnitFactReference>(null);
      }
      return AddUniqueComponent(component, mergeBehavior, merge);
    }

    /// <summary>
    /// Adds <see cref="RangedWeaponSizeChange"/>
    /// </summary>
    ///
    /// <remarks>
    ///
    /// <para>
    /// ComponentName: Ranged weapon size change
    /// </para>
    ///
    /// <list type="bullet">
    /// <listheader>Used by</listheader>
    /// <item><term>Erastil_Buff</term><description>4c14b60a38c448fbbf4670594fe61659</description></item>
    /// <item><term>HurricaneBowBuff</term><description>002c51d933574824c8ef2b04c9d09ff5</description></item>
    /// <item><term>MonsterMythicWeaponSizeFeature</term><description>c0c002a0198b2864685ba1b969cbdb33</description></item>
    /// </list>
    /// </remarks>
    ///
    /// <param name="merge">
    /// If mergeBehavior is ComponentMerge.Merge and the component already exists, this expression is called to merge the components.
    /// </param>
    /// <param name="mergeBehavior">
    /// Handling if the component already exists since the component is unique. Defaults to ComponentMerge.Fail.
    /// </param>
    /// <param name="weaponTypes">
    /// <para>
    /// Blueprint of type BlueprintWeaponType. You can pass in the blueprint using:
    /// <list type ="bullet">
    ///   <item><term>A blueprint instance</term></item>
    ///   <item><term>A blueprint reference</term></item>
    ///   <item><term>A blueprint id as a string, Guid, or BlueprintGuid</term></item>
    ///   <item><term>A blueprint name registered with <see cref="BlueprintCore.Utils.BlueprintTool">BlueprintTool</see></term></item>
    /// </list>
    /// See <see cref="BlueprintCore.Utils.Blueprint{{T, TRef}}">Blueprint</see> for more details.
    /// </para>
    /// </param>
    public TBuilder AddRangedWeaponSizeChange(
        Action<BlueprintComponent, BlueprintComponent>? merge = null,
        ComponentMerge mergeBehavior = ComponentMerge.Merge,
        int? sizeCategoryChange = null,
        List<Blueprint<BlueprintWeaponType, BlueprintWeaponTypeReference>>? weaponTypes = null)
    {
      var component = new RangedWeaponSizeChange();
      component.SizeCategoryChange = sizeCategoryChange ?? component.SizeCategoryChange;
      component.WeaponTypes = weaponTypes?.Select(bp => bp.Reference)?.ToList() ?? component.WeaponTypes;
      if (component.WeaponTypes is null)
      {
        component.WeaponTypes = new();
      }
      return AddUniqueComponent(component, mergeBehavior, merge);
    }

    /// <summary>
    /// Adds <see cref="RecalculateConcealment"/>
    /// </summary>
    ///
    /// <remarks>
    ///
    /// <para>
    /// ComponentName: Change concealment mechanics
    /// </para>
    ///
    /// <list type="bullet">
    /// <listheader>Used by</listheader>
    /// <item><term>BlindFightGreater</term><description>80a50d9744a40ac4c96e2cc6451a6703</description></item>
    /// <item><term>BlindFightImproved</term><description>4f1a78b02ac71bd4fa7d6e011d6f8ce0</description></item>
    /// </list>
    /// </remarks>
    public TBuilder AddRecalculateConcealment(
        bool? ignorePartial = null,
        bool? treatTotalAsPartial = null)
    {
      var component = new RecalculateConcealment();
      component.IgnorePartial = ignorePartial ?? component.IgnorePartial;
      component.TreatTotalAsPartial = treatTotalAsPartial ?? component.TreatTotalAsPartial;
      return AddComponent(component);
    }

    /// <summary>
    /// Adds <see cref="RecalculateOnFactsChange"/>
    /// </summary>
    ///
    /// <remarks>
    ///
    /// <list type="bullet">
    /// <listheader>Used by</listheader>
    /// <item><term>BloodragerDraconicBreathExtraResource</term><description>285920dfe2858164589229c4bf1bf774</description></item>
    /// <item><term>ShroudOfWaterArmorEffectFeature</term><description>1ff803cb49f63ea4185490fae2c43ca7</description></item>
    /// <item><term>UnrelentingAssaultEffectBuff</term><description>5845818248b44e98b4c0589aaf9c214b</description></item>
    /// </list>
    /// </remarks>
    ///
    /// <param name="checkedFacts">
    /// <para>
    /// Blueprint of type BlueprintUnitFact. You can pass in the blueprint using:
    /// <list type ="bullet">
    ///   <item><term>A blueprint instance</term></item>
    ///   <item><term>A blueprint reference</term></item>
    ///   <item><term>A blueprint id as a string, Guid, or BlueprintGuid</term></item>
    ///   <item><term>A blueprint name registered with <see cref="BlueprintCore.Utils.BlueprintTool">BlueprintTool</see></term></item>
    /// </list>
    /// See <see cref="BlueprintCore.Utils.Blueprint{{T, TRef}}">Blueprint</see> for more details.
    /// </para>
    /// </param>
    /// <param name="merge">
    /// If mergeBehavior is ComponentMerge.Merge and the component already exists, this expression is called to merge the components.
    /// </param>
    /// <param name="mergeBehavior">
    /// Handling if the component already exists since the component is unique. Defaults to ComponentMerge.Fail.
    /// </param>
    public TBuilder AddRecalculateOnFactsChange(
        List<Blueprint<BlueprintUnitFact, BlueprintUnitFactReference>>? checkedFacts = null,
        Action<BlueprintComponent, BlueprintComponent>? merge = null,
        ComponentMerge mergeBehavior = ComponentMerge.Merge)
    {
      var component = new RecalculateOnFactsChange();
      component.m_CheckedFacts = checkedFacts?.Select(bp => bp.Reference)?.ToArray() ?? component.m_CheckedFacts;
      if (component.m_CheckedFacts is null)
      {
        component.m_CheckedFacts = new BlueprintUnitFactReference[0];
      }
      return AddUniqueComponent(component, mergeBehavior, merge);
    }

    /// <summary>
    /// Adds <see cref="RecalculateOnLocustSwarmChange"/>
    /// </summary>
    ///
    /// <remarks>
    ///
    /// <list type="bullet">
    /// <listheader>Used by</listheader>
    /// <item><term>LocustClone</term><description>05d0463375e9dbb479b31a13964a9b91</description></item>
    /// <item><term>LocustCloneLevel09Feature</term><description>a4217bf42d8b41429f83663ef4d44a10</description></item>
    /// <item><term>LocustCloneLevel10Feature</term><description>1e648f7a98d84d71bb28cb4bf7dc0865</description></item>
    /// </list>
    /// </remarks>
    public TBuilder AddRecalculateOnLocustSwarmChange()
    {
      return AddComponent(new RecalculateOnLocustSwarmChange());
    }

    /// <summary>
    /// Adds <see cref="RecalculateOnStatChange"/>
    /// </summary>
    ///
    /// <remarks>
    ///
    /// <list type="bullet">
    /// <listheader>Used by</listheader>
    /// <item><term>AirElementalGreaterWhirlwindAbility</term><description>70c9e5dc39dc3934097767d927ac1c04</description></item>
    /// <item><term>DragonLevel2MaxAbilityWisdomFeature</term><description>27d78acec5ba4c089a87d658cf4594ca</description></item>
    /// <item><term>WyvernPoisonFeature</term><description>60d7f6df26e483d42aec1bfca4619cb0</description></item>
    /// </list>
    /// </remarks>
    public TBuilder AddRecalculateOnStatChange(
        StatType? stat = null,
        bool? useKineticistMainStat = null)
    {
      var component = new RecalculateOnStatChange();
      component.Stat = stat ?? component.Stat;
      component.UseKineticistMainStat = useKineticistMainStat ?? component.UseKineticistMainStat;
      return AddComponent(component);
    }

    /// <summary>
    /// Adds <see cref="RecommendedClass"/>
    /// </summary>
    ///
    /// <remarks>
    ///
    /// <para>
    /// ComponentName: Add favorite class for level up
    /// </para>
    ///
    /// <list type="bullet">
    /// <listheader>Used by</listheader>
    /// <item><term>Camouflage</term><description>ff1b5aa8dcc7d7d4d9aa85e1cb3f9e88</description></item>
    /// <item><term>RecommendedDuelist</term><description>41457a3a3f0451742b03bd62dcc4b3ee</description></item>
    /// <item><term>RecommendedWizard</term><description>2eee1ed3fa724ff41a163a5ae256ca65</description></item>
    /// </list>
    /// </remarks>
    ///
    /// <param name="favoriteClass">
    /// <para>
    /// Blueprint of type BlueprintCharacterClass. You can pass in the blueprint using:
    /// <list type ="bullet">
    ///   <item><term>A blueprint instance</term></item>
    ///   <item><term>A blueprint reference</term></item>
    ///   <item><term>A blueprint id as a string, Guid, or BlueprintGuid</term></item>
    ///   <item><term>A blueprint name registered with <see cref="BlueprintCore.Utils.BlueprintTool">BlueprintTool</see></term></item>
    /// </list>
    /// See <see cref="BlueprintCore.Utils.Blueprint{{T, TRef}}">Blueprint</see> for more details.
    /// </para>
    /// </param>
    public TBuilder AddRecommendedClass(
        Blueprint<BlueprintCharacterClass, BlueprintCharacterClassReference>? favoriteClass = null)
    {
      var component = new RecommendedClass();
      component.m_FavoriteClass = favoriteClass?.Reference ?? component.m_FavoriteClass;
      if (component.m_FavoriteClass is null)
      {
        component.m_FavoriteClass = BlueprintTool.GetRef<BlueprintCharacterClassReference>(null);
      }
      return AddComponent(component);
    }

    /// <summary>
    /// Adds <see cref="RemoveBuffOnAttack"/>
    /// </summary>
    ///
    /// <remarks>
    ///
    /// <para>
    /// ComponentName: Remove buff on event did trigger
    /// </para>
    ///
    /// <list type="bullet">
    /// <listheader>Used by</listheader>
    /// <item><term>KiTrueStrikeBuff</term><description>294e43af05aba134a8a24b05113cf472</description></item>
    /// <item><term>OathOfPeaceBuff</term><description>6f0a0557b90132347b7ca186cfb923dc</description></item>
    /// <item><term>TrueStrikeBuff</term><description>a3ce3b226c1817846b0419fa182e6ea0</description></item>
    /// </list>
    /// </remarks>
    public TBuilder AddRemoveBuffOnAttack()
    {
      return AddComponent(new RemoveBuffOnAttack());
    }

    /// <summary>
    /// Adds <see cref="RemoveFeatureOnApply"/>
    /// </summary>
    ///
    /// <remarks>
    ///
    /// <list type="bullet">
    /// <listheader>Used by</listheader>
    /// <item><term>AeonSummonFeatureTier3</term><description>6c999087fd82ca9499cee45f107e9831</description></item>
    /// <item><term>HumanRaisedHalfOrc</term><description>289d95c2c26f4e638c1f26d5ea7c594b</description></item>
    /// <item><term>VitalStrikeFeatureImproved</term><description>52913092cd018da47845f36e6fbe240f</description></item>
    /// </list>
    /// </remarks>
    ///
    /// <param name="feature">
    /// <para>
    /// Blueprint of type BlueprintUnitFact. You can pass in the blueprint using:
    /// <list type ="bullet">
    ///   <item><term>A blueprint instance</term></item>
    ///   <item><term>A blueprint reference</term></item>
    ///   <item><term>A blueprint id as a string, Guid, or BlueprintGuid</term></item>
    ///   <item><term>A blueprint name registered with <see cref="BlueprintCore.Utils.BlueprintTool">BlueprintTool</see></term></item>
    /// </list>
    /// See <see cref="BlueprintCore.Utils.Blueprint{{T, TRef}}">Blueprint</see> for more details.
    /// </para>
    /// </param>
    /// <param name="merge">
    /// If mergeBehavior is ComponentMerge.Merge and the component already exists, this expression is called to merge the components.
    /// </param>
    /// <param name="mergeBehavior">
    /// Handling if the component already exists since the component is unique. Defaults to ComponentMerge.Fail.
    /// </param>
    public TBuilder AddRemoveFeatureOnApply(
        Blueprint<BlueprintUnitFact, BlueprintUnitFactReference>? feature = null,
        Action<BlueprintComponent, BlueprintComponent>? merge = null,
        ComponentMerge mergeBehavior = ComponentMerge.Merge)
    {
      var component = new RemoveFeatureOnApply();
      component.m_Feature = feature?.Reference ?? component.m_Feature;
      if (component.m_Feature is null)
      {
        component.m_Feature = BlueprintTool.GetRef<BlueprintUnitFactReference>(null);
      }
      return AddUniqueComponent(component, mergeBehavior, merge);
    }

    /// <summary>
    /// Adds <see cref="RendFeature"/>
    /// </summary>
    ///
    /// <remarks>
    ///
    /// <list type="bullet">
    /// <listheader>Used by</listheader>
    /// <item><term>AnimalCompanionUpgradeBear</term><description>abda5a76b8a5901478495ffdc5450c9e</description></item>
    /// <item><term>Devastator_Rend</term><description>caff573054faac34cada3894d230f986</description></item>
    /// <item><term>GlabrezuRend</term><description>b555e9c8da67a7344ae0bba48b706f53</description></item>
    /// </list>
    /// </remarks>
    public TBuilder AddRendFeature(
        DiceFormula? rendDamage = null,
        DamageTypeDescription? rendType = null)
    {
      var component = new RendFeature();
      component.RendDamage = rendDamage ?? component.RendDamage;
      Validate(rendType);
      component.RendType = rendType ?? component.RendType;
      return AddComponent(component);
    }

    /// <summary>
    /// Adds <see cref="ReplaceAbilitiesStat"/>
    /// </summary>
    ///
    /// <remarks>
    ///
    /// <para>
    /// ComponentName: Replace stat for Ability DC
    /// </para>
    ///
    /// <list type="bullet">
    /// <listheader>Used by</listheader>
    /// <item><term>AirDomainBaseFeature</term><description>39b0c7db785560041b436b558c9df2bb</description></item>
    /// <item><term>FeatureScaledFistWhiteBreathWeapon</term><description>d88d9faea279e8142adbda357bcc8377</description></item>
    /// <item><term>WeatherDomainGreaterFeature</term><description>8e44306af595c8d44aad2f1260fd7be2</description></item>
    /// </list>
    /// </remarks>
    ///
    /// <param name="ability">
    /// <para>
    /// Blueprint of type BlueprintAbility. You can pass in the blueprint using:
    /// <list type ="bullet">
    ///   <item><term>A blueprint instance</term></item>
    ///   <item><term>A blueprint reference</term></item>
    ///   <item><term>A blueprint id as a string, Guid, or BlueprintGuid</term></item>
    ///   <item><term>A blueprint name registered with <see cref="BlueprintCore.Utils.BlueprintTool">BlueprintTool</see></term></item>
    /// </list>
    /// See <see cref="BlueprintCore.Utils.Blueprint{{T, TRef}}">Blueprint</see> for more details.
    /// </para>
    /// </param>
    public TBuilder AddReplaceAbilitiesStat(
        List<Blueprint<BlueprintAbility, BlueprintAbilityReference>>? ability = null,
        StatType? stat = null)
    {
      var component = new ReplaceAbilitiesStat();
      component.m_Ability = ability?.Select(bp => bp.Reference)?.ToArray() ?? component.m_Ability;
      if (component.m_Ability is null)
      {
        component.m_Ability = new BlueprintAbilityReference[0];
      }
      component.Stat = stat ?? component.Stat;
      return AddComponent(component);
    }

    /// <summary>
    /// Adds <see cref="ReplaceAbilityDC"/>
    /// </summary>
    ///
    /// <remarks>
    ///
    /// <para>
    /// ComponentName: Replace stat for Ability DC
    /// </para>
    ///
    /// <list type="bullet">
    /// <listheader>Used by</listheader>
    /// <item><term>BloodlineSerpentineScaledSoulBuff</term><description>fece5844ef1290944b02213d5a94d1d2</description></item>
    /// <item><term>ScaledFistStunningFistFatigueFeature</term><description>abcf396b95e3dbc4686c8547783a719c</description></item>
    /// <item><term>StunningFistSickenedFeature</term><description>d256ab3837538cc489d4b571e3a813eb</description></item>
    /// </list>
    /// </remarks>
    ///
    /// <param name="ability">
    /// <para>
    /// Blueprint of type BlueprintAbility. You can pass in the blueprint using:
    /// <list type ="bullet">
    ///   <item><term>A blueprint instance</term></item>
    ///   <item><term>A blueprint reference</term></item>
    ///   <item><term>A blueprint id as a string, Guid, or BlueprintGuid</term></item>
    ///   <item><term>A blueprint name registered with <see cref="BlueprintCore.Utils.BlueprintTool">BlueprintTool</see></term></item>
    /// </list>
    /// See <see cref="BlueprintCore.Utils.Blueprint{{T, TRef}}">Blueprint</see> for more details.
    /// </para>
    /// </param>
    /// <param name="merge">
    /// If mergeBehavior is ComponentMerge.Merge and the component already exists, this expression is called to merge the components.
    /// </param>
    /// <param name="mergeBehavior">
    /// Handling if the component already exists since the component is unique. Defaults to ComponentMerge.Fail.
    /// </param>
    public TBuilder AddReplaceAbilityDC(
        Blueprint<BlueprintAbility, BlueprintAbilityReference>? ability = null,
        Action<BlueprintComponent, BlueprintComponent>? merge = null,
        ComponentMerge mergeBehavior = ComponentMerge.Merge,
        StatType? stat = null)
    {
      var component = new ReplaceAbilityDC();
      component.m_Ability = ability?.Reference ?? component.m_Ability;
      if (component.m_Ability is null)
      {
        component.m_Ability = BlueprintTool.GetRef<BlueprintAbilityReference>(null);
      }
      component.Stat = stat ?? component.Stat;
      return AddUniqueComponent(component, mergeBehavior, merge);
    }

    /// <summary>
    /// Adds <see cref="ReplaceAbilityParamsWithContext"/>
    /// </summary>
    ///
    /// <remarks>
    ///
    /// <list type="bullet">
    /// <listheader>Used by</listheader>
    /// <item><term>AspectOfTheWolfBuff</term><description>98d9d1a761c8ade49964aa97ecd8dc1a</description></item>
    /// <item><term>FormOfTheDragonIIIWhiteBuff</term><description>8dae421e48035a044a4b1a7b9208c5db</description></item>
    /// <item><term>VeilOfHeavenBuff</term><description>f5d3311a675a7174dad7ffa99a81ad56</description></item>
    /// </list>
    /// </remarks>
    ///
    /// <param name="ability">
    /// <para>
    /// Blueprint of type BlueprintAbility. You can pass in the blueprint using:
    /// <list type ="bullet">
    ///   <item><term>A blueprint instance</term></item>
    ///   <item><term>A blueprint reference</term></item>
    ///   <item><term>A blueprint id as a string, Guid, or BlueprintGuid</term></item>
    ///   <item><term>A blueprint name registered with <see cref="BlueprintCore.Utils.BlueprintTool">BlueprintTool</see></term></item>
    /// </list>
    /// See <see cref="BlueprintCore.Utils.Blueprint{{T, TRef}}">Blueprint</see> for more details.
    /// </para>
    /// </param>
    /// <param name="merge">
    /// If mergeBehavior is ComponentMerge.Merge and the component already exists, this expression is called to merge the components.
    /// </param>
    /// <param name="mergeBehavior">
    /// Handling if the component already exists since the component is unique. Defaults to ComponentMerge.Fail.
    /// </param>
    public TBuilder AddReplaceAbilityParamsWithContext(
        Blueprint<BlueprintAbility, BlueprintAbilityReference>? ability = null,
        Action<BlueprintComponent, BlueprintComponent>? merge = null,
        ComponentMerge mergeBehavior = ComponentMerge.Merge)
    {
      var component = new ReplaceAbilityParamsWithContext();
      component.m_Ability = ability?.Reference ?? component.m_Ability;
      if (component.m_Ability is null)
      {
        component.m_Ability = BlueprintTool.GetRef<BlueprintAbilityReference>(null);
      }
      return AddUniqueComponent(component, mergeBehavior, merge);
    }

    /// <summary>
    /// Adds <see cref="ReplaceCMDDexterityStat"/>
    /// </summary>
    ///
    /// <remarks>
    ///
    /// <para>
    /// ComponentName: CMD Dexterity Change
    /// </para>
    ///
    /// <list type="bullet">
    /// <listheader>Used by</listheader>
    /// <item><term>OracleRevelationNatureWhispers</term><description>3d2cd23869f0d98458169b88738f3c32</description></item>
    /// </list>
    /// </remarks>
    public TBuilder AddReplaceCMDDexterityStat(
        StatType? newStat = null)
    {
      var component = new ReplaceCMDDexterityStat();
      component.NewStat = newStat ?? component.NewStat;
      return AddComponent(component);
    }

    /// <summary>
    /// Adds <see cref="ReplaceCastSource"/>
    /// </summary>
    ///
    /// <remarks>
    ///
    /// <list type="bullet">
    /// <listheader>Used by</listheader>
    /// <item><term>AberrationType</term><description>3bec99efd9a363242a6c8d9957b75e91</description></item>
    /// <item><term>FormOfTheDragonIIIBlueBuff</term><description>a4993affb4c4ad6429eca6daeb7b86a8</description></item>
    /// <item><term>WitchHexAnimalSkinBuff</term><description>adf61123d3dcce14baf1dd6ffe0b2062</description></item>
    /// </list>
    /// </remarks>
    public TBuilder AddReplaceCastSource(
        CastSource? castSource = null)
    {
      var component = new ReplaceCastSource();
      component.CastSource = castSource ?? component.CastSource;
      return AddComponent(component);
    }

    /// <summary>
    /// Adds <see cref="ReplaceCasterLevelOfAbility"/>
    /// </summary>
    ///
    /// <remarks>
    ///
    /// <list type="bullet">
    /// <listheader>Used by</listheader>
    /// <item><term>BloodlineDraconicBlackBreathWeaponFeature</term><description>73939e14b956b884688a6e1dccf9c043</description></item>
    /// <item><term>DivineGuardianHandsFeature</term><description>ba9fa17a17e5a494a93cd181b5615198</description></item>
    /// <item><term>TrueJudgmentFeature</term><description>f069b6557a2013544ac3636219186632</description></item>
    /// </list>
    /// </remarks>
    ///
    /// <param name="additionalClasses">
    /// <para>
    /// Blueprint of type BlueprintCharacterClass. You can pass in the blueprint using:
    /// <list type ="bullet">
    ///   <item><term>A blueprint instance</term></item>
    ///   <item><term>A blueprint reference</term></item>
    ///   <item><term>A blueprint id as a string, Guid, or BlueprintGuid</term></item>
    ///   <item><term>A blueprint name registered with <see cref="BlueprintCore.Utils.BlueprintTool">BlueprintTool</see></term></item>
    /// </list>
    /// See <see cref="BlueprintCore.Utils.Blueprint{{T, TRef}}">Blueprint</see> for more details.
    /// </para>
    /// </param>
    /// <param name="archetypes">
    /// <para>
    /// Blueprint of type BlueprintArchetype. You can pass in the blueprint using:
    /// <list type ="bullet">
    ///   <item><term>A blueprint instance</term></item>
    ///   <item><term>A blueprint reference</term></item>
    ///   <item><term>A blueprint id as a string, Guid, or BlueprintGuid</term></item>
    ///   <item><term>A blueprint name registered with <see cref="BlueprintCore.Utils.BlueprintTool">BlueprintTool</see></term></item>
    /// </list>
    /// See <see cref="BlueprintCore.Utils.Blueprint{{T, TRef}}">Blueprint</see> for more details.
    /// </para>
    /// </param>
    /// <param name="clazz">
    /// <para>
    /// Blueprint of type BlueprintCharacterClass. You can pass in the blueprint using:
    /// <list type ="bullet">
    ///   <item><term>A blueprint instance</term></item>
    ///   <item><term>A blueprint reference</term></item>
    ///   <item><term>A blueprint id as a string, Guid, or BlueprintGuid</term></item>
    ///   <item><term>A blueprint name registered with <see cref="BlueprintCore.Utils.BlueprintTool">BlueprintTool</see></term></item>
    /// </list>
    /// See <see cref="BlueprintCore.Utils.Blueprint{{T, TRef}}">Blueprint</see> for more details.
    /// </para>
    /// </param>
    /// <param name="merge">
    /// If mergeBehavior is ComponentMerge.Merge and the component already exists, this expression is called to merge the components.
    /// </param>
    /// <param name="mergeBehavior">
    /// Handling if the component already exists since the component is unique. Defaults to ComponentMerge.Fail.
    /// </param>
    /// <param name="spell">
    /// <para>
    /// Blueprint of type BlueprintAbility. You can pass in the blueprint using:
    /// <list type ="bullet">
    ///   <item><term>A blueprint instance</term></item>
    ///   <item><term>A blueprint reference</term></item>
    ///   <item><term>A blueprint id as a string, Guid, or BlueprintGuid</term></item>
    ///   <item><term>A blueprint name registered with <see cref="BlueprintCore.Utils.BlueprintTool">BlueprintTool</see></term></item>
    /// </list>
    /// See <see cref="BlueprintCore.Utils.Blueprint{{T, TRef}}">Blueprint</see> for more details.
    /// </para>
    /// </param>
    public TBuilder AddReplaceCasterLevelOfAbility(
        List<Blueprint<BlueprintCharacterClass, BlueprintCharacterClassReference>>? additionalClasses = null,
        List<Blueprint<BlueprintArchetype, BlueprintArchetypeReference>>? archetypes = null,
        Blueprint<BlueprintCharacterClass, BlueprintCharacterClassReference>? clazz = null,
        Action<BlueprintComponent, BlueprintComponent>? merge = null,
        ComponentMerge mergeBehavior = ComponentMerge.Merge,
        Blueprint<BlueprintAbility, BlueprintAbilityReference>? spell = null)
    {
      var component = new ReplaceCasterLevelOfAbility();
      component.m_AdditionalClasses = additionalClasses?.Select(bp => bp.Reference)?.ToArray() ?? component.m_AdditionalClasses;
      if (component.m_AdditionalClasses is null)
      {
        component.m_AdditionalClasses = new BlueprintCharacterClassReference[0];
      }
      component.m_Archetypes = archetypes?.Select(bp => bp.Reference)?.ToArray() ?? component.m_Archetypes;
      if (component.m_Archetypes is null)
      {
        component.m_Archetypes = new BlueprintArchetypeReference[0];
      }
      component.m_Class = clazz?.Reference ?? component.m_Class;
      if (component.m_Class is null)
      {
        component.m_Class = BlueprintTool.GetRef<BlueprintCharacterClassReference>(null);
      }
      component.m_Spell = spell?.Reference ?? component.m_Spell;
      if (component.m_Spell is null)
      {
        component.m_Spell = BlueprintTool.GetRef<BlueprintAbilityReference>(null);
      }
      return AddUniqueComponent(component, mergeBehavior, merge);
    }

    /// <summary>
    /// Adds <see cref="ReplaceCombatManeuverStat"/>
    /// </summary>
    ///
    /// <remarks>
    ///
    /// <list type="bullet">
    /// <listheader>Used by</listheader>
    /// <item><term>AgileManeuvers</term><description>197306972c98bb843af738dc7529a7ac</description></item>
    /// <item><term>Incorporeal</term><description>c4a7f98d743bc784c9d4cf2105852c39</description></item>
    /// <item><term>SenseiInsightfulStrike</term><description>f4a3f9ede5a57c142b30a9dfbb8efa90</description></item>
    /// </list>
    /// </remarks>
    public TBuilder AddReplaceCombatManeuverStat(
        StatType? statType = null)
    {
      var component = new ReplaceCombatManeuverStat();
      component.StatType = statType ?? component.StatType;
      return AddComponent(component);
    }

    /// <summary>
    /// Adds <see cref="ReplaceSingleCombatManeuverStat"/>
    /// </summary>
    ///
    /// <remarks>
    ///
    /// <list type="bullet">
    /// <listheader>Used by</listheader>
    /// <item><term>WeaponSnatcher</term><description>ffced614e1f95e34d99df77debbc4207</description></item>
    /// </list>
    /// </remarks>
    public TBuilder AddReplaceSingleCombatManeuverStat(
        StatType? statType = null,
        CombatManeuver? type = null)
    {
      var component = new ReplaceSingleCombatManeuverStat();
      component.StatType = statType ?? component.StatType;
      component.Type = type ?? component.Type;
      return AddComponent(component);
    }

    /// <summary>
    /// Adds <see cref="ReplaceSourceBone"/>
    /// </summary>
    ///
    /// <remarks>
    ///
    /// <list type="bullet">
    /// <listheader>Used by</listheader>
    /// <item><term>AberrationType</term><description>3bec99efd9a363242a6c8d9957b75e91</description></item>
    /// <item><term>FormOfTheDragonIIIBlueBuff</term><description>a4993affb4c4ad6429eca6daeb7b86a8</description></item>
    /// <item><term>WitchHexAnimalSkinBuff</term><description>adf61123d3dcce14baf1dd6ffe0b2062</description></item>
    /// </list>
    /// </remarks>
    ///
    /// <param name="merge">
    /// If mergeBehavior is ComponentMerge.Merge and the component already exists, this expression is called to merge the components.
    /// </param>
    /// <param name="mergeBehavior">
    /// Handling if the component already exists since the component is unique. Defaults to ComponentMerge.Fail.
    /// </param>
    public TBuilder AddReplaceSourceBone(
        Action<BlueprintComponent, BlueprintComponent>? merge = null,
        ComponentMerge mergeBehavior = ComponentMerge.Merge,
        string? sourceBone = null)
    {
      var component = new ReplaceSourceBone();
      component.SourceBone = sourceBone ?? component.SourceBone;
      return AddUniqueComponent(component, mergeBehavior, merge);
    }

    /// <summary>
    /// Adds <see cref="ReplaceStatForPrerequisites"/>
    /// </summary>
    ///
    /// <remarks>
    ///
    /// <para>
    /// ComponentName: Add ability resources
    /// </para>
    ///
    /// <list type="bullet">
    /// <listheader>Used by</listheader>
    /// <item><term>KineticWarriorFeature</term><description>ff14cb2bfab1c0547be66d8aaa7e4ada</description></item>
    /// <item><term>SwordSaintCriticalPerfection</term><description>36837f00fc2f5d043847e37ba6af187c</description></item>
    /// <item><term>WarpriestClassAsBABFeature</term><description>2e134d80fef14a44aae9c087215c15af</description></item>
    /// </list>
    /// </remarks>
    ///
    /// <param name="characterClass">
    /// <para>
    /// Blueprint of type BlueprintCharacterClass. You can pass in the blueprint using:
    /// <list type ="bullet">
    ///   <item><term>A blueprint instance</term></item>
    ///   <item><term>A blueprint reference</term></item>
    ///   <item><term>A blueprint id as a string, Guid, or BlueprintGuid</term></item>
    ///   <item><term>A blueprint name registered with <see cref="BlueprintCore.Utils.BlueprintTool">BlueprintTool</see></term></item>
    /// </list>
    /// See <see cref="BlueprintCore.Utils.Blueprint{{T, TRef}}">Blueprint</see> for more details.
    /// </para>
    /// </param>
    /// <param name="merge">
    /// If mergeBehavior is ComponentMerge.Merge and the component already exists, this expression is called to merge the components.
    /// </param>
    /// <param name="mergeBehavior">
    /// Handling if the component already exists since the component is unique. Defaults to ComponentMerge.Fail.
    /// </param>
    public TBuilder AddReplaceStatForPrerequisites(
        Blueprint<BlueprintCharacterClass, BlueprintCharacterClassReference>? characterClass = null,
        Action<BlueprintComponent, BlueprintComponent>? merge = null,
        ComponentMerge mergeBehavior = ComponentMerge.Merge,
        StatType? newStat = null,
        StatType? oldStat = null,
        ReplaceStatForPrerequisites.StatReplacementPolicy? policy = null,
        int? specificNumber = null)
    {
      var component = new ReplaceStatForPrerequisites();
      component.m_CharacterClass = characterClass?.Reference ?? component.m_CharacterClass;
      if (component.m_CharacterClass is null)
      {
        component.m_CharacterClass = BlueprintTool.GetRef<BlueprintCharacterClassReference>(null);
      }
      component.NewStat = newStat ?? component.NewStat;
      component.OldStat = oldStat ?? component.OldStat;
      component.Policy = policy ?? component.Policy;
      component.SpecificNumber = specificNumber ?? component.SpecificNumber;
      return AddUniqueComponent(component, mergeBehavior, merge);
    }

    /// <summary>
    /// Adds <see cref="RerollConcealment"/>
    /// </summary>
    ///
    /// <remarks>
    ///
    /// <para>
    /// ComponentName: Reroll Concealment Checks
    /// </para>
    ///
    /// <list type="bullet">
    /// <listheader>Used by</listheader>
    /// <item><term>BlindFight</term><description>4e219f5894ad0ea4daa0699e28c37b1d</description></item>
    /// <item><term>BlindFightGreater</term><description>80a50d9744a40ac4c96e2cc6451a6703</description></item>
    /// <item><term>BlindFightImproved</term><description>4f1a78b02ac71bd4fa7d6e011d6f8ce0</description></item>
    /// </list>
    /// </remarks>
    public TBuilder AddRerollConcealment()
    {
      return AddComponent(new RerollConcealment());
    }

    /// <summary>
    /// Adds <see cref="RideAnimalCompanion"/>
    /// </summary>
    ///
    /// <remarks>
    ///
    /// <list type="bullet">
    /// <listheader>Used by</listheader>
    /// <item><term>Azata_Gnome_male_FieldOfWanders</term><description>e08f35a5a86f6b84db7a874ae6913965</description></item>
    /// <item><term>MountedCombatTest</term><description>9c8220a1aea311243b5d8905ad0d0157</description></item>
    /// <item><term>RideAnimalCompanionFeature</term><description>89dd53e531f94067945b836f103778eb</description></item>
    /// </list>
    /// </remarks>
    public TBuilder AddRideAnimalCompanion()
    {
      return AddComponent(new RideAnimalCompanion());
    }

    /// <summary>
    /// Adds <see cref="SavesFixedRecalculateThievery"/>
    /// </summary>
    ///
    /// <remarks>
    ///
    /// <list type="bullet">
    /// <listheader>Used by</listheader>
    /// <item><term>CoupDeGraceFeature</term><description>3fbd5466fcc609d40bb2dfc3e502f4c4</description></item>
    /// </list>
    /// </remarks>
    public TBuilder AddSavesFixedRecalculateThievery()
    {
      return AddComponent(new SavesFixedRecalculateThievery());
    }

    /// <summary>
    /// Adds <see cref="SavesFixerFactReplacer"/>
    /// </summary>
    ///
    /// <remarks>
    ///
    /// <list type="bullet">
    /// <listheader>Used by</listheader>
    /// <item><term>MadnessDomainBaseAbility</term><description>9246020fe13095346946ff3101d9f60d</description></item>
    /// <item><term>ShroudOfWater</term><description>29ec36fa2a5b8b94ebce170bd369083a</description></item>
    /// <item><term>TreantCreatureDestructive</term><description>95163ae3f1b8c174c8f78be781254ccb</description></item>
    /// </list>
    /// </remarks>
    ///
    /// <param name="merge">
    /// If mergeBehavior is ComponentMerge.Merge and the component already exists, this expression is called to merge the components.
    /// </param>
    /// <param name="mergeBehavior">
    /// Handling if the component already exists since the component is unique. Defaults to ComponentMerge.Fail.
    /// </param>
    /// <param name="newFacts">
    /// <para>
    /// Blueprint of type BlueprintUnitFact. You can pass in the blueprint using:
    /// <list type ="bullet">
    ///   <item><term>A blueprint instance</term></item>
    ///   <item><term>A blueprint reference</term></item>
    ///   <item><term>A blueprint id as a string, Guid, or BlueprintGuid</term></item>
    ///   <item><term>A blueprint name registered with <see cref="BlueprintCore.Utils.BlueprintTool">BlueprintTool</see></term></item>
    /// </list>
    /// See <see cref="BlueprintCore.Utils.Blueprint{{T, TRef}}">Blueprint</see> for more details.
    /// </para>
    /// </param>
    /// <param name="oldFacts">
    /// <para>
    /// Blueprint of type BlueprintUnitFact. You can pass in the blueprint using:
    /// <list type ="bullet">
    ///   <item><term>A blueprint instance</term></item>
    ///   <item><term>A blueprint reference</term></item>
    ///   <item><term>A blueprint id as a string, Guid, or BlueprintGuid</term></item>
    ///   <item><term>A blueprint name registered with <see cref="BlueprintCore.Utils.BlueprintTool">BlueprintTool</see></term></item>
    /// </list>
    /// See <see cref="BlueprintCore.Utils.Blueprint{{T, TRef}}">Blueprint</see> for more details.
    /// </para>
    /// </param>
    public TBuilder AddSavesFixerFactReplacer(
        Action<BlueprintComponent, BlueprintComponent>? merge = null,
        ComponentMerge mergeBehavior = ComponentMerge.Merge,
        List<Blueprint<BlueprintUnitFact, BlueprintUnitFactReference>>? newFacts = null,
        List<Blueprint<BlueprintUnitFact, BlueprintUnitFactReference>>? oldFacts = null)
    {
      var component = new SavesFixerFactReplacer();
      component.m_NewFacts = newFacts?.Select(bp => bp.Reference)?.ToArray() ?? component.m_NewFacts;
      if (component.m_NewFacts is null)
      {
        component.m_NewFacts = new BlueprintUnitFactReference[0];
      }
      component.m_OldFacts = oldFacts?.Select(bp => bp.Reference)?.ToArray() ?? component.m_OldFacts;
      if (component.m_OldFacts is null)
      {
        component.m_OldFacts = new BlueprintUnitFactReference[0];
      }
      return AddUniqueComponent(component, mergeBehavior, merge);
    }

    /// <summary>
    /// Adds <see cref="SavesFixerReplaceInProgression"/>
    /// </summary>
    ///
    /// <remarks>
    ///
    /// <list type="bullet">
    /// <listheader>Used by</listheader>
    /// <item><term>ScaledFistACBonusUnlock</term><description>2a8922e28b3eba54fa7a244f7b05bd9e</description></item>
    /// </list>
    /// </remarks>
    ///
    /// <param name="merge">
    /// If mergeBehavior is ComponentMerge.Merge and the component already exists, this expression is called to merge the components.
    /// </param>
    /// <param name="mergeBehavior">
    /// Handling if the component already exists since the component is unique. Defaults to ComponentMerge.Fail.
    /// </param>
    /// <param name="newFeature">
    /// <para>
    /// Blueprint of type BlueprintFeature. You can pass in the blueprint using:
    /// <list type ="bullet">
    ///   <item><term>A blueprint instance</term></item>
    ///   <item><term>A blueprint reference</term></item>
    ///   <item><term>A blueprint id as a string, Guid, or BlueprintGuid</term></item>
    ///   <item><term>A blueprint name registered with <see cref="BlueprintCore.Utils.BlueprintTool">BlueprintTool</see></term></item>
    /// </list>
    /// See <see cref="BlueprintCore.Utils.Blueprint{{T, TRef}}">Blueprint</see> for more details.
    /// </para>
    /// </param>
    /// <param name="oldFeature">
    /// <para>
    /// Blueprint of type BlueprintFeature. You can pass in the blueprint using:
    /// <list type ="bullet">
    ///   <item><term>A blueprint instance</term></item>
    ///   <item><term>A blueprint reference</term></item>
    ///   <item><term>A blueprint id as a string, Guid, or BlueprintGuid</term></item>
    ///   <item><term>A blueprint name registered with <see cref="BlueprintCore.Utils.BlueprintTool">BlueprintTool</see></term></item>
    /// </list>
    /// See <see cref="BlueprintCore.Utils.Blueprint{{T, TRef}}">Blueprint</see> for more details.
    /// </para>
    /// </param>
    public TBuilder AddSavesFixerReplaceInProgression(
        Action<BlueprintComponent, BlueprintComponent>? merge = null,
        ComponentMerge mergeBehavior = ComponentMerge.Merge,
        Blueprint<BlueprintFeature, BlueprintFeatureReference>? newFeature = null,
        Blueprint<BlueprintFeature, BlueprintFeatureReference>? oldFeature = null)
    {
      var component = new SavesFixerReplaceInProgression();
      component.m_NewFeature = newFeature?.Reference ?? component.m_NewFeature;
      if (component.m_NewFeature is null)
      {
        component.m_NewFeature = BlueprintTool.GetRef<BlueprintFeatureReference>(null);
      }
      component.m_OldFeature = oldFeature?.Reference ?? component.m_OldFeature;
      if (component.m_OldFeature is null)
      {
        component.m_OldFeature = BlueprintTool.GetRef<BlueprintFeatureReference>(null);
      }
      return AddUniqueComponent(component, mergeBehavior, merge);
    }

    /// <summary>
    /// Adds <see cref="SavingSlash"/>
    /// </summary>
    ///
    /// <remarks>
    ///
    /// <list type="bullet">
    /// <listheader>Used by</listheader>
    /// <item><term>SavingSlash</term><description>eee7abd42ef7bac4ea117b2f41f85ec3</description></item>
    /// <item><term>SavingSlashGreater</term><description>732ad7ec6b1cd1f4885370924d492e87</description></item>
    /// </list>
    /// </remarks>
    public TBuilder AddSavingSlash(
        int? bonus = null,
        bool? useContextValue = null,
        ContextValue? value = null,
        WeaponCategory? weapon = null)
    {
      var component = new SavingSlash();
      component.Bonus = bonus ?? component.Bonus;
      component.UseContextValue = useContextValue ?? component.UseContextValue;
      component.Value = value ?? component.Value;
      if (component.Value is null)
      {
        component.Value = ContextValues.Constant(0);
      }
      component.Weapon = weapon ?? component.Weapon;
      return AddComponent(component);
    }

    /// <summary>
    /// Adds <see cref="SavingThrowBonusAgainstAbilityType"/>
    /// </summary>
    ///
    /// <remarks>
    ///
    /// <list type="bullet">
    /// <listheader>Used by</listheader>
    /// <item><term>DuergarImmunities</term><description>df39e25d887a89042a1b4810eac902d0</description></item>
    /// <item><term>DweomerEvocationCreature</term><description>14881ff97e00cb44082b29396ddc40c3</description></item>
    /// <item><term>ProtectionFromSpellsBuffSpellLike</term><description>4f0064bea5b14554f809f5e075a0070d</description></item>
    /// </list>
    /// </remarks>
    ///
    /// <param name="merge">
    /// If mergeBehavior is ComponentMerge.Merge and the component already exists, this expression is called to merge the components.
    /// </param>
    /// <param name="mergeBehavior">
    /// Handling if the component already exists since the component is unique. Defaults to ComponentMerge.Fail.
    /// </param>
    public TBuilder AddSavingThrowBonusAgainstAbilityType(
        AbilityType? abilityType = null,
        ContextValue? bonus = null,
        Action<BlueprintComponent, BlueprintComponent>? merge = null,
        ComponentMerge mergeBehavior = ComponentMerge.Merge,
        ModifierDescriptor? modifierDescriptor = null,
        bool? onlyPositiveValue = null,
        int? value = null)
    {
      var component = new SavingThrowBonusAgainstAbilityType();
      component.AbilityType = abilityType ?? component.AbilityType;
      component.Bonus = bonus ?? component.Bonus;
      if (component.Bonus is null)
      {
        component.Bonus = ContextValues.Constant(0);
      }
      component.ModifierDescriptor = modifierDescriptor ?? component.ModifierDescriptor;
      component.OnlyPositiveValue = onlyPositiveValue ?? component.OnlyPositiveValue;
      component.Value = value ?? component.Value;
      return AddUniqueComponent(component, mergeBehavior, merge);
    }

    /// <summary>
    /// Adds <see cref="SavingThrowBonusAgainstAlignment"/>
    /// </summary>
    ///
    /// <remarks>
    ///
    /// <para>
    /// ComponentName: Saving throw bonus against alignment
    /// </para>
    ///
    /// <list type="bullet">
    /// <listheader>Used by</listheader>
    /// <item><term>AeonThirdLevelImmunities</term><description>2be3d3d82e6ced345ac3c5e0c0fa3e50</description></item>
    /// <item><term>IncorruptibleHeartShieldFeature</term><description>bc096e4b32580084e95108bcced09fdd</description></item>
    /// <item><term>Valmallos_Feature_Immunities</term><description>cb539d689d9d47858b96715a29363820</description></item>
    /// </list>
    /// </remarks>
    public TBuilder AddSavingThrowBonusAgainstAlignment(
        AlignmentComponent? alignment = null,
        ContextValue? bonus = null,
        ModifierDescriptor? descriptor = null,
        int? value = null)
    {
      var component = new SavingThrowBonusAgainstAlignment();
      component.Alignment = alignment ?? component.Alignment;
      component.Bonus = bonus ?? component.Bonus;
      if (component.Bonus is null)
      {
        component.Bonus = ContextValues.Constant(0);
      }
      component.Descriptor = descriptor ?? component.Descriptor;
      component.Value = value ?? component.Value;
      return AddComponent(component);
    }

    /// <summary>
    /// Adds <see cref="SavingThrowBonusAgainstAlignmentDifference"/>
    /// </summary>
    ///
    /// <remarks>
    ///
    /// <para>
    /// ComponentName: Saving throw bonus against alignment difference
    /// </para>
    ///
    /// <list type="bullet">
    /// <listheader>Used by</listheader>
    /// <item><term>DeterminedZealBuff</term><description>044bcc34d9326e647a7b9866b0dd8887</description></item>
    /// </list>
    /// </remarks>
    ///
    /// <param name="merge">
    /// If mergeBehavior is ComponentMerge.Merge and the component already exists, this expression is called to merge the components.
    /// </param>
    /// <param name="mergeBehavior">
    /// Handling if the component already exists since the component is unique. Defaults to ComponentMerge.Fail.
    /// </param>
    public TBuilder AddSavingThrowBonusAgainstAlignmentDifference(
        int? alignmentDifference = null,
        ModifierDescriptor? descriptor = null,
        Action<BlueprintComponent, BlueprintComponent>? merge = null,
        ComponentMerge mergeBehavior = ComponentMerge.Merge,
        SavingThrowType? savingThrow = null,
        int? value = null)
    {
      var component = new SavingThrowBonusAgainstAlignmentDifference();
      component.AlignmentDifference = alignmentDifference ?? component.AlignmentDifference;
      component.Descriptor = descriptor ?? component.Descriptor;
      component.SavingThrow = savingThrow ?? component.SavingThrow;
      component.Value = value ?? component.Value;
      return AddUniqueComponent(component, mergeBehavior, merge);
    }

    /// <summary>
    /// Adds <see cref="SavingThrowBonusAgainstAllies"/>
    /// </summary>
    ///
    /// <remarks>
    ///
    /// <list type="bullet">
    /// <listheader>Used by</listheader>
    /// <item><term>BloodragerBloodSanctuary</term><description>70d9d54bd349a63448032b5ac2e5c47d</description></item>
    /// </list>
    /// </remarks>
    ///
    /// <param name="disablingFeature">
    /// <para>
    /// Blueprint of type BlueprintUnitFact. You can pass in the blueprint using:
    /// <list type ="bullet">
    ///   <item><term>A blueprint instance</term></item>
    ///   <item><term>A blueprint reference</term></item>
    ///   <item><term>A blueprint id as a string, Guid, or BlueprintGuid</term></item>
    ///   <item><term>A blueprint name registered with <see cref="BlueprintCore.Utils.BlueprintTool">BlueprintTool</see></term></item>
    /// </list>
    /// See <see cref="BlueprintCore.Utils.Blueprint{{T, TRef}}">Blueprint</see> for more details.
    /// </para>
    /// </param>
    /// <param name="merge">
    /// If mergeBehavior is ComponentMerge.Merge and the component already exists, this expression is called to merge the components.
    /// </param>
    /// <param name="mergeBehavior">
    /// Handling if the component already exists since the component is unique. Defaults to ComponentMerge.Fail.
    /// </param>
    public TBuilder AddSavingThrowBonusAgainstAllies(
        ContextValue? bonus = null,
        Blueprint<BlueprintUnitFact, BlueprintUnitFactReference>? disablingFeature = null,
        Action<BlueprintComponent, BlueprintComponent>? merge = null,
        ComponentMerge mergeBehavior = ComponentMerge.Merge,
        ModifierDescriptor? modifierDescriptor = null,
        bool? onlyPositiveValue = null,
        int? value = null)
    {
      var component = new SavingThrowBonusAgainstAllies();
      component.Bonus = bonus ?? component.Bonus;
      if (component.Bonus is null)
      {
        component.Bonus = ContextValues.Constant(0);
      }
      component.m_DisablingFeature = disablingFeature?.Reference ?? component.m_DisablingFeature;
      if (component.m_DisablingFeature is null)
      {
        component.m_DisablingFeature = BlueprintTool.GetRef<BlueprintUnitFactReference>(null);
      }
      component.ModifierDescriptor = modifierDescriptor ?? component.ModifierDescriptor;
      component.OnlyPositiveValue = onlyPositiveValue ?? component.OnlyPositiveValue;
      component.Value = value ?? component.Value;
      return AddUniqueComponent(component, mergeBehavior, merge);
    }

    /// <summary>
    /// Adds <see cref="SavingThrowBonusAgainstDescriptor"/>
    /// </summary>
    ///
    /// <remarks>
    ///
    /// <list type="bullet">
    /// <listheader>Used by</listheader>
    /// <item><term>2THAgainstDazeShakenFeature</term><description>fa18b85fe1496a943b39d91f5433de7a</description></item>
    /// <item><term>ForceOfWillFearFeature</term><description>9b0d5d82f10b73e4da3a579919f235db</description></item>
    /// <item><term>Xanthir_notesFeature</term><description>f5de9974738e40389bc7cf09d4504912</description></item>
    /// </list>
    /// </remarks>
    ///
    /// <param name="disablingFeature">
    /// <para>
    /// Blueprint of type BlueprintUnitFact. You can pass in the blueprint using:
    /// <list type ="bullet">
    ///   <item><term>A blueprint instance</term></item>
    ///   <item><term>A blueprint reference</term></item>
    ///   <item><term>A blueprint id as a string, Guid, or BlueprintGuid</term></item>
    ///   <item><term>A blueprint name registered with <see cref="BlueprintCore.Utils.BlueprintTool">BlueprintTool</see></term></item>
    /// </list>
    /// See <see cref="BlueprintCore.Utils.Blueprint{{T, TRef}}">Blueprint</see> for more details.
    /// </para>
    /// </param>
    /// <param name="merge">
    /// If mergeBehavior is ComponentMerge.Merge and the component already exists, this expression is called to merge the components.
    /// </param>
    /// <param name="mergeBehavior">
    /// Handling if the component already exists since the component is unique. Defaults to ComponentMerge.Fail.
    /// </param>
    public TBuilder AddSavingThrowBonusAgainstDescriptor(
        ContextValue? bonus = null,
        Blueprint<BlueprintUnitFact, BlueprintUnitFactReference>? disablingFeature = null,
        Action<BlueprintComponent, BlueprintComponent>? merge = null,
        ComponentMerge mergeBehavior = ComponentMerge.Merge,
        ModifierDescriptor? modifierDescriptor = null,
        bool? onlyPositiveValue = null,
        SpellDescriptorWrapper? spellDescriptor = null,
        int? value = null)
    {
      var component = new SavingThrowBonusAgainstDescriptor();
      component.Bonus = bonus ?? component.Bonus;
      if (component.Bonus is null)
      {
        component.Bonus = ContextValues.Constant(0);
      }
      component.m_DisablingFeature = disablingFeature?.Reference ?? component.m_DisablingFeature;
      if (component.m_DisablingFeature is null)
      {
        component.m_DisablingFeature = BlueprintTool.GetRef<BlueprintUnitFactReference>(null);
      }
      component.ModifierDescriptor = modifierDescriptor ?? component.ModifierDescriptor;
      component.OnlyPositiveValue = onlyPositiveValue ?? component.OnlyPositiveValue;
      component.SpellDescriptor = spellDescriptor ?? component.SpellDescriptor;
      component.Value = value ?? component.Value;
      return AddUniqueComponent(component, mergeBehavior, merge);
    }

    /// <summary>
    /// Adds <see cref="SavingThrowBonusAgainstFact"/>
    /// </summary>
    ///
    /// <remarks>
    ///
    /// <para>
    /// ComponentName: Saving throw bonus against fact
    /// </para>
    ///
    /// <list type="bullet">
    /// <listheader>Used by</listheader>
    /// <item><term>AboutIzyagnaFeature</term><description>c40878ae14b343778c68972ff4980671</description></item>
    /// <item><term>DispelSynergyBuff</term><description>5eb779547b384624a5a1d02669b32d8b</description></item>
    /// <item><term>VeilOfPositiveEnergyBuff</term><description>d72cc6b3a65d31247b37faf600a17977</description></item>
    /// </list>
    /// </remarks>
    ///
    /// <param name="checkedFact">
    /// <para>
    /// Blueprint of type BlueprintFeature. You can pass in the blueprint using:
    /// <list type ="bullet">
    ///   <item><term>A blueprint instance</term></item>
    ///   <item><term>A blueprint reference</term></item>
    ///   <item><term>A blueprint id as a string, Guid, or BlueprintGuid</term></item>
    ///   <item><term>A blueprint name registered with <see cref="BlueprintCore.Utils.BlueprintTool">BlueprintTool</see></term></item>
    /// </list>
    /// See <see cref="BlueprintCore.Utils.Blueprint{{T, TRef}}">Blueprint</see> for more details.
    /// </para>
    /// </param>
    /// <param name="merge">
    /// If mergeBehavior is ComponentMerge.Merge and the component already exists, this expression is called to merge the components.
    /// </param>
    /// <param name="mergeBehavior">
    /// Handling if the component already exists since the component is unique. Defaults to ComponentMerge.Fail.
    /// </param>
    public TBuilder AddSavingThrowBonusAgainstFact(
        AlignmentComponent? alignment = null,
        Blueprint<BlueprintFeature, BlueprintFeatureReference>? checkedFact = null,
        ModifierDescriptor? descriptor = null,
        Action<BlueprintComponent, BlueprintComponent>? merge = null,
        ComponentMerge mergeBehavior = ComponentMerge.Merge,
        int? value = null)
    {
      var component = new SavingThrowBonusAgainstFact();
      component.Alignment = alignment ?? component.Alignment;
      component.m_CheckedFact = checkedFact?.Reference ?? component.m_CheckedFact;
      if (component.m_CheckedFact is null)
      {
        component.m_CheckedFact = BlueprintTool.GetRef<BlueprintFeatureReference>(null);
      }
      component.Descriptor = descriptor ?? component.Descriptor;
      component.Value = value ?? component.Value;
      return AddUniqueComponent(component, mergeBehavior, merge);
    }

    /// <summary>
    /// Adds <see cref="SavingThrowBonusAgainstFactMultiple"/>
    /// </summary>
    ///
    /// <remarks>
    ///
    /// <para>
    /// ComponentName: Saving throw bonus against fact
    /// </para>
    ///
    /// <list type="bullet">
    /// <listheader>Used by</listheader>
    /// <item><term>DemonslayerFavoriteEnemy</term><description>f7b7c69d80dd12c40920803a8efb2306</description></item>
    /// <item><term>ProtectorOfUnjustArmorFeatureSecond</term><description>4b8ef852cc70c064cb9ec72951284b7b</description></item>
    /// <item><term>VeilOfHeavenBuff</term><description>f5d3311a675a7174dad7ffa99a81ad56</description></item>
    /// </list>
    /// </remarks>
    ///
    /// <param name="facts">
    /// <para>
    /// Blueprint of type BlueprintUnitFact. You can pass in the blueprint using:
    /// <list type ="bullet">
    ///   <item><term>A blueprint instance</term></item>
    ///   <item><term>A blueprint reference</term></item>
    ///   <item><term>A blueprint id as a string, Guid, or BlueprintGuid</term></item>
    ///   <item><term>A blueprint name registered with <see cref="BlueprintCore.Utils.BlueprintTool">BlueprintTool</see></term></item>
    /// </list>
    /// See <see cref="BlueprintCore.Utils.Blueprint{{T, TRef}}">Blueprint</see> for more details.
    /// </para>
    /// </param>
    public TBuilder AddSavingThrowBonusAgainstFactMultiple(
        AlignmentComponent? alignment = null,
        ModifierDescriptor? descriptor = null,
        List<Blueprint<BlueprintUnitFact, BlueprintUnitFactReference>>? facts = null,
        int? value = null)
    {
      var component = new SavingThrowBonusAgainstFactMultiple();
      component.Alignment = alignment ?? component.Alignment;
      component.Descriptor = descriptor ?? component.Descriptor;
      component.m_Facts = facts?.Select(bp => bp.Reference)?.ToArray() ?? component.m_Facts;
      if (component.m_Facts is null)
      {
        component.m_Facts = new BlueprintUnitFactReference[0];
      }
      component.Value = value ?? component.Value;
      return AddComponent(component);
    }

    /// <summary>
    /// Adds <see cref="SavingThrowBonusAgainstSchool"/>
    /// </summary>
    ///
    /// <remarks>
    ///
    /// <list type="bullet">
    /// <listheader>Used by</listheader>
    /// <item><term>2DCagainstNecroticPlus2Feature</term><description>215124551c2eec44a8e573b7810af630</description></item>
    /// <item><term>ExterminatorFeature</term><description>7a472f4c0f7d36b4c8f52d3b17e7b292</description></item>
    /// <item><term>UnveilerFeature</term><description>fb3175e49fa347cdb2faffc81e1efc60</description></item>
    /// </list>
    /// </remarks>
    public TBuilder AddSavingThrowBonusAgainstSchool(
        ModifierDescriptor? modifierDescriptor = null,
        SpellSchool? school = null,
        int? value = null)
    {
      var component = new SavingThrowBonusAgainstSchool();
      component.ModifierDescriptor = modifierDescriptor ?? component.ModifierDescriptor;
      component.School = school ?? component.School;
      component.Value = value ?? component.Value;
      return AddComponent(component);
    }

    /// <summary>
    /// Adds <see cref="SavingThrowBonusAgainstSchoolAbilityValue"/>
    /// </summary>
    ///
    /// <remarks>
    ///
    /// <list type="bullet">
    /// <listheader>Used by</listheader>
    /// <item><term>EnchantmentSchoolBaseFeature</term><description>9e4c4799735ae9c45964e9113107ef02</description></item>
    /// </list>
    /// </remarks>
    ///
    /// <param name="merge">
    /// If mergeBehavior is ComponentMerge.Merge and the component already exists, this expression is called to merge the components.
    /// </param>
    /// <param name="mergeBehavior">
    /// Handling if the component already exists since the component is unique. Defaults to ComponentMerge.Fail.
    /// </param>
    public TBuilder AddSavingThrowBonusAgainstSchoolAbilityValue(
        ContextValue? bonus = null,
        Action<BlueprintComponent, BlueprintComponent>? merge = null,
        ComponentMerge mergeBehavior = ComponentMerge.Merge,
        ModifierDescriptor? modifierDescriptor = null,
        SpellSchool? school = null,
        int? value = null)
    {
      var component = new SavingThrowBonusAgainstSchoolAbilityValue();
      component.Bonus = bonus ?? component.Bonus;
      if (component.Bonus is null)
      {
        component.Bonus = ContextValues.Constant(0);
      }
      component.ModifierDescriptor = modifierDescriptor ?? component.ModifierDescriptor;
      component.School = school ?? component.School;
      component.Value = value ?? component.Value;
      return AddUniqueComponent(component, mergeBehavior, merge);
    }

    /// <summary>
    /// Adds <see cref="SavingThrowBonusAgainstSpecificSpells"/>
    /// </summary>
    ///
    /// <remarks>
    ///
    /// <list type="bullet">
    /// <listheader>Used by</listheader>
    /// <item><term>ChannelResistance1</term><description>39c50ffb1e9b55545b3286677bc82016</description></item>
    /// <item><term>OracleRevelationDeathsTouchBuff</term><description>9e800c4aebc76774c9d8cdf543bd7aca</description></item>
    /// <item><term>ZeorisDaggerHeadband_BetrayalBuff</term><description>e4ca6e99afa143fc8c48c79336e77dd4</description></item>
    /// </list>
    /// </remarks>
    ///
    /// <param name="bypassFeatures">
    /// <para>
    /// Blueprint of type BlueprintUnitFact. You can pass in the blueprint using:
    /// <list type ="bullet">
    ///   <item><term>A blueprint instance</term></item>
    ///   <item><term>A blueprint reference</term></item>
    ///   <item><term>A blueprint id as a string, Guid, or BlueprintGuid</term></item>
    ///   <item><term>A blueprint name registered with <see cref="BlueprintCore.Utils.BlueprintTool">BlueprintTool</see></term></item>
    /// </list>
    /// See <see cref="BlueprintCore.Utils.Blueprint{{T, TRef}}">Blueprint</see> for more details.
    /// </para>
    /// </param>
    /// <param name="spells">
    /// <para>
    /// Blueprint of type BlueprintAbility. You can pass in the blueprint using:
    /// <list type ="bullet">
    ///   <item><term>A blueprint instance</term></item>
    ///   <item><term>A blueprint reference</term></item>
    ///   <item><term>A blueprint id as a string, Guid, or BlueprintGuid</term></item>
    ///   <item><term>A blueprint name registered with <see cref="BlueprintCore.Utils.BlueprintTool">BlueprintTool</see></term></item>
    /// </list>
    /// See <see cref="BlueprintCore.Utils.Blueprint{{T, TRef}}">Blueprint</see> for more details.
    /// </para>
    /// </param>
    public TBuilder AddSavingThrowBonusAgainstSpecificSpells(
        List<Blueprint<BlueprintUnitFact, BlueprintUnitFactReference>>? bypassFeatures = null,
        ModifierDescriptor? modifierDescriptor = null,
        List<Blueprint<BlueprintAbility, BlueprintAbilityReference>>? spells = null,
        int? value = null)
    {
      var component = new SavingThrowBonusAgainstSpecificSpells();
      component.m_BypassFeatures = bypassFeatures?.Select(bp => bp.Reference)?.ToArray() ?? component.m_BypassFeatures;
      if (component.m_BypassFeatures is null)
      {
        component.m_BypassFeatures = new BlueprintUnitFactReference[0];
      }
      component.ModifierDescriptor = modifierDescriptor ?? component.ModifierDescriptor;
      component.m_Spells = spells?.Select(bp => bp.Reference)?.ToArray() ?? component.m_Spells;
      if (component.m_Spells is null)
      {
        component.m_Spells = new BlueprintAbilityReference[0];
      }
      component.Value = value ?? component.Value;
      return AddComponent(component);
    }

    /// <summary>
    /// Adds <see cref="SavingThrowBonusAgainstSpellType"/>
    /// </summary>
    ///
    /// <remarks>
    ///
    /// <list type="bullet">
    /// <listheader>Used by</listheader>
    /// <item><term>BackgroundRahadoumFaithless</term><description>f99465e6886253744aaef25d9b7c90c1</description></item>
    /// <item><term>FaithHereticalSoulFeature</term><description>e3c8ac9397ad72940b034a8795401f15</description></item>
    /// </list>
    /// </remarks>
    ///
    /// <param name="merge">
    /// If mergeBehavior is ComponentMerge.Merge and the component already exists, this expression is called to merge the components.
    /// </param>
    /// <param name="mergeBehavior">
    /// Handling if the component already exists since the component is unique. Defaults to ComponentMerge.Fail.
    /// </param>
    public TBuilder AddSavingThrowBonusAgainstSpellType(
        bool? againstArcaneSpells = null,
        ContextValue? bonus = null,
        Action<BlueprintComponent, BlueprintComponent>? merge = null,
        ComponentMerge mergeBehavior = ComponentMerge.Merge,
        ModifierDescriptor? modifierDescriptor = null,
        bool? onlyPositiveValue = null,
        int? value = null)
    {
      var component = new SavingThrowBonusAgainstSpellType();
      component.AgainstArcaneSpells = againstArcaneSpells ?? component.AgainstArcaneSpells;
      component.Bonus = bonus ?? component.Bonus;
      if (component.Bonus is null)
      {
        component.Bonus = ContextValues.Constant(0);
      }
      component.ModifierDescriptor = modifierDescriptor ?? component.ModifierDescriptor;
      component.OnlyPositiveValue = onlyPositiveValue ?? component.OnlyPositiveValue;
      component.Value = value ?? component.Value;
      return AddUniqueComponent(component, mergeBehavior, merge);
    }

    /// <summary>
    /// Adds <see cref="SavingThrowBonusUnlessFactMultiple"/>
    /// </summary>
    ///
    /// <remarks>
    ///
    /// <para>
    /// ComponentName: Saving throw bonus unless fact
    /// </para>
    ///
    /// <list type="bullet">
    /// <listheader>Used by</listheader>
    /// <item><term>SeamantleBuff</term><description>1c05dd3a1c78b0e4e9f7438a43e7a9fd</description></item>
    /// </list>
    /// </remarks>
    ///
    /// <param name="facts">
    /// <para>
    /// Blueprint of type BlueprintUnitFact. You can pass in the blueprint using:
    /// <list type ="bullet">
    ///   <item><term>A blueprint instance</term></item>
    ///   <item><term>A blueprint reference</term></item>
    ///   <item><term>A blueprint id as a string, Guid, or BlueprintGuid</term></item>
    ///   <item><term>A blueprint name registered with <see cref="BlueprintCore.Utils.BlueprintTool">BlueprintTool</see></term></item>
    /// </list>
    /// See <see cref="BlueprintCore.Utils.Blueprint{{T, TRef}}">Blueprint</see> for more details.
    /// </para>
    /// </param>
    public TBuilder AddSavingThrowBonusUnlessFactMultiple(
        AlignmentComponent? alignment = null,
        ModifierDescriptor? descriptor = null,
        List<Blueprint<BlueprintUnitFact, BlueprintUnitFactReference>>? facts = null,
        SavingThrowType? type = null,
        int? value = null)
    {
      var component = new SavingThrowBonusUnlessFactMultiple();
      component.Alignment = alignment ?? component.Alignment;
      component.Descriptor = descriptor ?? component.Descriptor;
      component.m_Facts = facts?.Select(bp => bp.Reference)?.ToArray() ?? component.m_Facts;
      if (component.m_Facts is null)
      {
        component.m_Facts = new BlueprintUnitFactReference[0];
      }
      component.Type = type ?? component.Type;
      component.Value = value ?? component.Value;
      return AddComponent(component);
    }

    /// <summary>
    /// Adds <see cref="SavingThrowContextBonusAgainstDescriptor"/>
    /// </summary>
    ///
    /// <remarks>
    ///
    /// <list type="bullet">
    /// <listheader>Used by</listheader>
    /// <item><term>ArmyUnitsHardenedMindFeature</term><description>135c0007c57644f898bf63c0b2a708c1</description></item>
    /// <item><term>GeniekindEfreetiBuff</term><description>d47f45f29c4cfc0469f3734d02545e0b</description></item>
    /// <item><term>OracleRevelationBloodOfHeroesBuff</term><description>ab88d55181c294a40aea8745f1fd6419</description></item>
    /// </list>
    /// </remarks>
    ///
    /// <param name="merge">
    /// If mergeBehavior is ComponentMerge.Merge and the component already exists, this expression is called to merge the components.
    /// </param>
    /// <param name="mergeBehavior">
    /// Handling if the component already exists since the component is unique. Defaults to ComponentMerge.Fail.
    /// </param>
    public TBuilder AddSavingThrowContextBonusAgainstDescriptor(
        Action<BlueprintComponent, BlueprintComponent>? merge = null,
        ComponentMerge mergeBehavior = ComponentMerge.Merge,
        ModifierDescriptor? modifierDescriptor = null,
        SpellDescriptorWrapper? spellDescriptor = null,
        ContextValue? value = null)
    {
      var component = new SavingThrowContextBonusAgainstDescriptor();
      component.ModifierDescriptor = modifierDescriptor ?? component.ModifierDescriptor;
      component.SpellDescriptor = spellDescriptor ?? component.SpellDescriptor;
      component.Value = value ?? component.Value;
      if (component.Value is null)
      {
        component.Value = ContextValues.Constant(0);
      }
      return AddUniqueComponent(component, mergeBehavior, merge);
    }

    /// <summary>
    /// Adds <see cref="ShakeItOff"/>
    /// </summary>
    ///
    /// <remarks>
    ///
    /// <list type="bullet">
    /// <listheader>Used by</listheader>
    /// <item><term>ShakeItOff</term><description>6337b37f2a7c11b4ab0831d6780bce2a</description></item>
    /// </list>
    /// </remarks>
    ///
    /// <param name="merge">
    /// If mergeBehavior is ComponentMerge.Merge and the component already exists, this expression is called to merge the components.
    /// </param>
    /// <param name="mergeBehavior">
    /// Handling if the component already exists since the component is unique. Defaults to ComponentMerge.Fail.
    /// </param>
    /// <param name="shakeItOffFact">
    /// <para>
    /// Blueprint of type BlueprintUnitFact. You can pass in the blueprint using:
    /// <list type ="bullet">
    ///   <item><term>A blueprint instance</term></item>
    ///   <item><term>A blueprint reference</term></item>
    ///   <item><term>A blueprint id as a string, Guid, or BlueprintGuid</term></item>
    ///   <item><term>A blueprint name registered with <see cref="BlueprintCore.Utils.BlueprintTool">BlueprintTool</see></term></item>
    /// </list>
    /// See <see cref="BlueprintCore.Utils.Blueprint{{T, TRef}}">Blueprint</see> for more details.
    /// </para>
    /// </param>
    public TBuilder AddShakeItOff(
        Action<BlueprintComponent, BlueprintComponent>? merge = null,
        ComponentMerge mergeBehavior = ComponentMerge.Merge,
        int? radius = null,
        Blueprint<BlueprintUnitFact, BlueprintUnitFactReference>? shakeItOffFact = null)
    {
      var component = new ShakeItOff();
      component.Radius = radius ?? component.Radius;
      component.m_ShakeItOffFact = shakeItOffFact?.Reference ?? component.m_ShakeItOffFact;
      if (component.m_ShakeItOffFact is null)
      {
        component.m_ShakeItOffFact = BlueprintTool.GetRef<BlueprintUnitFactReference>(null);
      }
      return AddUniqueComponent(component, mergeBehavior, merge);
    }

    /// <summary>
    /// Adds <see cref="ShareBuffsWithPet"/>
    /// </summary>
    ///
    /// <remarks>
    ///
    /// <list type="bullet">
    /// <listheader>Used by</listheader>
    /// <item><term>DivineHoundCompanionJudgmentBuff</term><description>afb25823212c4d6ab763c50e0267cd29</description></item>
    /// </list>
    /// </remarks>
    ///
    /// <param name="buffs">
    /// <para>
    /// Blueprint of type BlueprintBuff. You can pass in the blueprint using:
    /// <list type ="bullet">
    ///   <item><term>A blueprint instance</term></item>
    ///   <item><term>A blueprint reference</term></item>
    ///   <item><term>A blueprint id as a string, Guid, or BlueprintGuid</term></item>
    ///   <item><term>A blueprint name registered with <see cref="BlueprintCore.Utils.BlueprintTool">BlueprintTool</see></term></item>
    /// </list>
    /// See <see cref="BlueprintCore.Utils.Blueprint{{T, TRef}}">Blueprint</see> for more details.
    /// </para>
    /// </param>
    public TBuilder AddShareBuffsWithPet(
        List<Blueprint<BlueprintBuff, BlueprintBuffReference>>? buffs = null,
        PetType? type = null)
    {
      var component = new ShareBuffsWithPet();
      component.m_Buffs = buffs?.Select(bp => bp.Reference)?.ToArray() ?? component.m_Buffs;
      if (component.m_Buffs is null)
      {
        component.m_Buffs = new BlueprintBuffReference[0];
      }
      component.Type = type ?? component.Type;
      return AddComponent(component);
    }

    /// <summary>
    /// Adds <see cref="ShareFavoredEnemies"/>
    /// </summary>
    ///
    /// <remarks>
    ///
    /// <list type="bullet">
    /// <listheader>Used by</listheader>
    /// <item><term>AnimalCompanionShareFavoredEnemies</term><description>8a91da7c9e074fb2b4ffe7dba209e67e</description></item>
    /// <item><term>HuntersBondBuff</term><description>2f93cad6b132aac4e80728d7fa03a8aa</description></item>
    /// <item><term>ShareFavoredEnemyPet</term><description>cd7b831693c0f3947b019321c0510915</description></item>
    /// </list>
    /// </remarks>
    public TBuilder AddShareFavoredEnemies(
        bool? half = null,
        bool? toPet = null)
    {
      var component = new ShareFavoredEnemies();
      component.Half = half ?? component.Half;
      component.ToPet = toPet ?? component.ToPet;
      return AddComponent(component);
    }

    /// <summary>
    /// Adds <see cref="ShareFeaturesWithPet"/>
    /// </summary>
    ///
    /// <remarks>
    ///
    /// <list type="bullet">
    /// <listheader>Used by</listheader>
    /// <item><term>FrightfulFerocity</term><description>28914b9467f58e047a494cbb30f46937</description></item>
    /// <item><term>MountedBuff</term><description>b2d13e8f3bb0f1d4c891d71b4d983cf7</description></item>
    /// <item><term>UrbanHunterCaptor</term><description>6a7183b066616464b838b10e92cf7146</description></item>
    /// </list>
    /// </remarks>
    ///
    /// <param name="features">
    /// <para>
    /// Blueprint of type BlueprintFeature. You can pass in the blueprint using:
    /// <list type ="bullet">
    ///   <item><term>A blueprint instance</term></item>
    ///   <item><term>A blueprint reference</term></item>
    ///   <item><term>A blueprint id as a string, Guid, or BlueprintGuid</term></item>
    ///   <item><term>A blueprint name registered with <see cref="BlueprintCore.Utils.BlueprintTool">BlueprintTool</see></term></item>
    /// </list>
    /// See <see cref="BlueprintCore.Utils.Blueprint{{T, TRef}}">Blueprint</see> for more details.
    /// </para>
    /// </param>
    public TBuilder AddShareFeaturesWithPet(
        List<Blueprint<BlueprintFeature, BlueprintFeatureReference>>? features = null,
        PetType? type = null)
    {
      var component = new ShareFeaturesWithPet();
      component.m_Features = features?.Select(bp => bp.Reference)?.ToArray() ?? component.m_Features;
      if (component.m_Features is null)
      {
        component.m_Features = new BlueprintFeatureReference[0];
      }
      component.Type = type ?? component.Type;
      return AddComponent(component);
    }

    /// <summary>
    /// Adds <see cref="ShatterConfidence"/>
    /// </summary>
    ///
    /// <remarks>
    ///
    /// <list type="bullet">
    /// <listheader>Used by</listheader>
    /// <item><term>ShatterConfidenceBuff</term><description>14225a2e4561bfd46874c9a4a97e7133</description></item>
    /// </list>
    /// </remarks>
    ///
    /// <param name="confoundingDuelistFeature">
    /// <para>
    /// Blueprint of type BlueprintFeature. You can pass in the blueprint using:
    /// <list type ="bullet">
    ///   <item><term>A blueprint instance</term></item>
    ///   <item><term>A blueprint reference</term></item>
    ///   <item><term>A blueprint id as a string, Guid, or BlueprintGuid</term></item>
    ///   <item><term>A blueprint name registered with <see cref="BlueprintCore.Utils.BlueprintTool">BlueprintTool</see></term></item>
    /// </list>
    /// See <see cref="BlueprintCore.Utils.Blueprint{{T, TRef}}">Blueprint</see> for more details.
    /// </para>
    /// </param>
    public TBuilder AddShatterConfidence(
        Blueprint<BlueprintFeature, BlueprintFeatureReference>? confoundingDuelistFeature = null)
    {
      var component = new ShatterConfidence();
      component.m_ConfoundingDuelistFeature = confoundingDuelistFeature?.Reference ?? component.m_ConfoundingDuelistFeature;
      if (component.m_ConfoundingDuelistFeature is null)
      {
        component.m_ConfoundingDuelistFeature = BlueprintTool.GetRef<BlueprintFeatureReference>(null);
      }
      return AddComponent(component);
    }

    /// <summary>
    /// Adds <see cref="ShieldWall"/>
    /// </summary>
    ///
    /// <remarks>
    ///
    /// <list type="bullet">
    /// <listheader>Used by</listheader>
    /// <item><term>ShieldWall</term><description>8976de442862f82488a4b138a0a89907</description></item>
    /// </list>
    /// </remarks>
    ///
    /// <param name="merge">
    /// If mergeBehavior is ComponentMerge.Merge and the component already exists, this expression is called to merge the components.
    /// </param>
    /// <param name="mergeBehavior">
    /// Handling if the component already exists since the component is unique. Defaults to ComponentMerge.Fail.
    /// </param>
    /// <param name="shieldWallFact">
    /// <para>
    /// Blueprint of type BlueprintUnitFact. You can pass in the blueprint using:
    /// <list type ="bullet">
    ///   <item><term>A blueprint instance</term></item>
    ///   <item><term>A blueprint reference</term></item>
    ///   <item><term>A blueprint id as a string, Guid, or BlueprintGuid</term></item>
    ///   <item><term>A blueprint name registered with <see cref="BlueprintCore.Utils.BlueprintTool">BlueprintTool</see></term></item>
    /// </list>
    /// See <see cref="BlueprintCore.Utils.Blueprint{{T, TRef}}">Blueprint</see> for more details.
    /// </para>
    /// </param>
    public TBuilder AddShieldWall(
        Action<BlueprintComponent, BlueprintComponent>? merge = null,
        ComponentMerge mergeBehavior = ComponentMerge.Merge,
        int? radius = null,
        Blueprint<BlueprintUnitFact, BlueprintUnitFactReference>? shieldWallFact = null)
    {
      var component = new ShieldWall();
      component.Radius = radius ?? component.Radius;
      component.m_ShieldWallFact = shieldWallFact?.Reference ?? component.m_ShieldWallFact;
      if (component.m_ShieldWallFact is null)
      {
        component.m_ShieldWallFact = BlueprintTool.GetRef<BlueprintUnitFactReference>(null);
      }
      return AddUniqueComponent(component, mergeBehavior, merge);
    }

    /// <summary>
    /// Adds <see cref="ShieldedCaster"/>
    /// </summary>
    ///
    /// <remarks>
    ///
    /// <list type="bullet">
    /// <listheader>Used by</listheader>
    /// <item><term>ShieldedCaster</term><description>0b707584fc2ea724aa72c396c2230dc7</description></item>
    /// </list>
    /// </remarks>
    ///
    /// <param name="merge">
    /// If mergeBehavior is ComponentMerge.Merge and the component already exists, this expression is called to merge the components.
    /// </param>
    /// <param name="mergeBehavior">
    /// Handling if the component already exists since the component is unique. Defaults to ComponentMerge.Fail.
    /// </param>
    /// <param name="shieldedCasterFact">
    /// <para>
    /// Blueprint of type BlueprintUnitFact. You can pass in the blueprint using:
    /// <list type ="bullet">
    ///   <item><term>A blueprint instance</term></item>
    ///   <item><term>A blueprint reference</term></item>
    ///   <item><term>A blueprint id as a string, Guid, or BlueprintGuid</term></item>
    ///   <item><term>A blueprint name registered with <see cref="BlueprintCore.Utils.BlueprintTool">BlueprintTool</see></term></item>
    /// </list>
    /// See <see cref="BlueprintCore.Utils.Blueprint{{T, TRef}}">Blueprint</see> for more details.
    /// </para>
    /// </param>
    public TBuilder AddShieldedCaster(
        Action<BlueprintComponent, BlueprintComponent>? merge = null,
        ComponentMerge mergeBehavior = ComponentMerge.Merge,
        int? radius = null,
        Blueprint<BlueprintUnitFact, BlueprintUnitFactReference>? shieldedCasterFact = null)
    {
      var component = new ShieldedCaster();
      component.Radius = radius ?? component.Radius;
      component.m_ShieldedCasterFact = shieldedCasterFact?.Reference ?? component.m_ShieldedCasterFact;
      if (component.m_ShieldedCasterFact is null)
      {
        component.m_ShieldedCasterFact = BlueprintTool.GetRef<BlueprintUnitFactReference>(null);
      }
      return AddUniqueComponent(component, mergeBehavior, merge);
    }

    /// <summary>
    /// Adds <see cref="SiezeTheMoment"/>
    /// </summary>
    ///
    /// <remarks>
    ///
    /// <list type="bullet">
    /// <listheader>Used by</listheader>
    /// <item><term>SiezeTheMoment</term><description>1191ef3065e6f8e4f9fbe1b7e3c0f760</description></item>
    /// </list>
    /// </remarks>
    ///
    /// <param name="merge">
    /// If mergeBehavior is ComponentMerge.Merge and the component already exists, this expression is called to merge the components.
    /// </param>
    /// <param name="mergeBehavior">
    /// Handling if the component already exists since the component is unique. Defaults to ComponentMerge.Fail.
    /// </param>
    /// <param name="siezeTheMomentFact">
    /// <para>
    /// Blueprint of type BlueprintUnitFact. You can pass in the blueprint using:
    /// <list type ="bullet">
    ///   <item><term>A blueprint instance</term></item>
    ///   <item><term>A blueprint reference</term></item>
    ///   <item><term>A blueprint id as a string, Guid, or BlueprintGuid</term></item>
    ///   <item><term>A blueprint name registered with <see cref="BlueprintCore.Utils.BlueprintTool">BlueprintTool</see></term></item>
    /// </list>
    /// See <see cref="BlueprintCore.Utils.Blueprint{{T, TRef}}">Blueprint</see> for more details.
    /// </para>
    /// </param>
    public TBuilder AddSiezeTheMoment(
        Action<BlueprintComponent, BlueprintComponent>? merge = null,
        ComponentMerge mergeBehavior = ComponentMerge.Merge,
        Blueprint<BlueprintUnitFact, BlueprintUnitFactReference>? siezeTheMomentFact = null)
    {
      var component = new SiezeTheMoment();
      component.m_SiezeTheMomentFact = siezeTheMomentFact?.Reference ?? component.m_SiezeTheMomentFact;
      if (component.m_SiezeTheMomentFact is null)
      {
        component.m_SiezeTheMomentFact = BlueprintTool.GetRef<BlueprintUnitFactReference>(null);
      }
      return AddUniqueComponent(component, mergeBehavior, merge);
    }

    /// <summary>
    /// Adds <see cref="SpellFixedDC"/>
    /// </summary>
    ///
    /// <remarks>
    ///
    /// <para>
    /// ComponentName: Scale caster level by rank of feature
    /// </para>
    ///
    /// <list type="bullet">
    /// <listheader>Used by</listheader>
    /// <item><term>BloodlineSerpentineScaledSoulBuff</term><description>fece5844ef1290944b02213d5a94d1d2</description></item>
    /// <item><term>NereidAbilityDC</term><description>78ddae0c38b428e40a708c73a3022cad</description></item>
    /// <item><term>StoneGolemAbilitiesDC</term><description>fdbda0f8bb89b6342b62b09ecc518860</description></item>
    /// </list>
    /// </remarks>
    ///
    /// <param name="ability">
    /// <para>
    /// Blueprint of type BlueprintAbility. You can pass in the blueprint using:
    /// <list type ="bullet">
    ///   <item><term>A blueprint instance</term></item>
    ///   <item><term>A blueprint reference</term></item>
    ///   <item><term>A blueprint id as a string, Guid, or BlueprintGuid</term></item>
    ///   <item><term>A blueprint name registered with <see cref="BlueprintCore.Utils.BlueprintTool">BlueprintTool</see></term></item>
    /// </list>
    /// See <see cref="BlueprintCore.Utils.Blueprint{{T, TRef}}">Blueprint</see> for more details.
    /// </para>
    /// </param>
    /// <param name="merge">
    /// If mergeBehavior is ComponentMerge.Merge and the component already exists, this expression is called to merge the components.
    /// </param>
    /// <param name="mergeBehavior">
    /// Handling if the component already exists since the component is unique. Defaults to ComponentMerge.Fail.
    /// </param>
    public TBuilder AddSpellFixedDC(
        Blueprint<BlueprintAbility, BlueprintAbilityReference>? ability = null,
        int? dC = null,
        Action<BlueprintComponent, BlueprintComponent>? merge = null,
        ComponentMerge mergeBehavior = ComponentMerge.Merge)
    {
      var component = new SpellFixedDC();
      component.m_Ability = ability?.Reference ?? component.m_Ability;
      if (component.m_Ability is null)
      {
        component.m_Ability = BlueprintTool.GetRef<BlueprintAbilityReference>(null);
      }
      component.DC = dC ?? component.DC;
      return AddUniqueComponent(component, mergeBehavior, merge);
    }

    /// <summary>
    /// Adds <see cref="SpellLevelByClassLevel"/>
    /// </summary>
    ///
    /// <remarks>
    ///
    /// <para>
    /// ComponentName: Replace caster level with class level
    /// </para>
    ///
    /// <list type="bullet">
    /// <listheader>Used by</listheader>
    /// <item><term>CognatogenFeature</term><description>e3f460ea61fcc504183c7d6818bbbf7a</description></item>
    /// <item><term>GrandCognatogenFeature</term><description>af4a320648eb5724889d6ff6255090b2</description></item>
    /// <item><term>GreaterCognatogenFeature</term><description>18eb29676492e844eb5a55d1c855ce69</description></item>
    /// </list>
    /// </remarks>
    ///
    /// <param name="ability">
    /// <para>
    /// Blueprint of type BlueprintAbility. You can pass in the blueprint using:
    /// <list type ="bullet">
    ///   <item><term>A blueprint instance</term></item>
    ///   <item><term>A blueprint reference</term></item>
    ///   <item><term>A blueprint id as a string, Guid, or BlueprintGuid</term></item>
    ///   <item><term>A blueprint name registered with <see cref="BlueprintCore.Utils.BlueprintTool">BlueprintTool</see></term></item>
    /// </list>
    /// See <see cref="BlueprintCore.Utils.Blueprint{{T, TRef}}">Blueprint</see> for more details.
    /// </para>
    /// </param>
    /// <param name="clazz">
    /// <para>
    /// Blueprint of type BlueprintCharacterClass. You can pass in the blueprint using:
    /// <list type ="bullet">
    ///   <item><term>A blueprint instance</term></item>
    ///   <item><term>A blueprint reference</term></item>
    ///   <item><term>A blueprint id as a string, Guid, or BlueprintGuid</term></item>
    ///   <item><term>A blueprint name registered with <see cref="BlueprintCore.Utils.BlueprintTool">BlueprintTool</see></term></item>
    /// </list>
    /// See <see cref="BlueprintCore.Utils.Blueprint{{T, TRef}}">Blueprint</see> for more details.
    /// </para>
    /// </param>
    /// <param name="merge">
    /// If mergeBehavior is ComponentMerge.Merge and the component already exists, this expression is called to merge the components.
    /// </param>
    /// <param name="mergeBehavior">
    /// Handling if the component already exists since the component is unique. Defaults to ComponentMerge.Fail.
    /// </param>
    public TBuilder AddSpellLevelByClassLevel(
        Blueprint<BlueprintAbility, BlueprintAbilityReference>? ability = null,
        Blueprint<BlueprintCharacterClass, BlueprintCharacterClassReference>? clazz = null,
        Action<BlueprintComponent, BlueprintComponent>? merge = null,
        ComponentMerge mergeBehavior = ComponentMerge.Merge)
    {
      var component = new SpellLevelByClassLevel();
      component.m_Ability = ability?.Reference ?? component.m_Ability;
      if (component.m_Ability is null)
      {
        component.m_Ability = BlueprintTool.GetRef<BlueprintAbilityReference>(null);
      }
      component.m_Class = clazz?.Reference ?? component.m_Class;
      if (component.m_Class is null)
      {
        component.m_Class = BlueprintTool.GetRef<BlueprintCharacterClassReference>(null);
      }
      return AddUniqueComponent(component, mergeBehavior, merge);
    }

    /// <summary>
    /// Adds <see cref="SpellPenetrationBonus"/>
    /// </summary>
    ///
    /// <remarks>
    ///
    /// <list type="bullet">
    /// <listheader>Used by</listheader>
    /// <item><term>AngelHolyHymnBuff</term><description>f865b385586fe0a4996e081a96de4f0f</description></item>
    /// <item><term>MaskOfNethysFeature</term><description>911c34da3d8677145affe00a32b8b2b0</description></item>
    /// <item><term>WhiteroseOystersBuff</term><description>45082bf27cf15e94ca0fae92dc3db992</description></item>
    /// </list>
    /// </remarks>
    ///
    /// <param name="requiredFact">
    /// <para>
    /// Blueprint of type BlueprintUnitFact. You can pass in the blueprint using:
    /// <list type ="bullet">
    ///   <item><term>A blueprint instance</term></item>
    ///   <item><term>A blueprint reference</term></item>
    ///   <item><term>A blueprint id as a string, Guid, or BlueprintGuid</term></item>
    ///   <item><term>A blueprint name registered with <see cref="BlueprintCore.Utils.BlueprintTool">BlueprintTool</see></term></item>
    /// </list>
    /// See <see cref="BlueprintCore.Utils.Blueprint{{T, TRef}}">Blueprint</see> for more details.
    /// </para>
    /// </param>
    public TBuilder AddSpellPenetrationBonus(
        bool? checkFact = null,
        ModifierDescriptor? descriptor = null,
        Blueprint<BlueprintUnitFact, BlueprintUnitFactReference>? requiredFact = null,
        ContextValue? value = null)
    {
      var component = new SpellPenetrationBonus();
      component.CheckFact = checkFact ?? component.CheckFact;
      component.Descriptor = descriptor ?? component.Descriptor;
      component.m_RequiredFact = requiredFact?.Reference ?? component.m_RequiredFact;
      if (component.m_RequiredFact is null)
      {
        component.m_RequiredFact = BlueprintTool.GetRef<BlueprintUnitFactReference>(null);
      }
      component.Value = value ?? component.Value;
      if (component.Value is null)
      {
        component.Value = ContextValues.Constant(0);
      }
      return AddComponent(component);
    }

    /// <summary>
    /// Adds <see cref="SpellPenetrationMythicBonus"/>
    /// </summary>
    ///
    /// <remarks>
    ///
    /// <list type="bullet">
    /// <listheader>Used by</listheader>
    /// <item><term>SpellPenetrationMythicFeat</term><description>51b6b22ff184eef46a675449e837365d</description></item>
    /// </list>
    /// </remarks>
    ///
    /// <param name="greater">
    /// <para>
    /// Blueprint of type BlueprintUnitFact. You can pass in the blueprint using:
    /// <list type ="bullet">
    ///   <item><term>A blueprint instance</term></item>
    ///   <item><term>A blueprint reference</term></item>
    ///   <item><term>A blueprint id as a string, Guid, or BlueprintGuid</term></item>
    ///   <item><term>A blueprint name registered with <see cref="BlueprintCore.Utils.BlueprintTool">BlueprintTool</see></term></item>
    /// </list>
    /// See <see cref="BlueprintCore.Utils.Blueprint{{T, TRef}}">Blueprint</see> for more details.
    /// </para>
    /// </param>
    public TBuilder AddSpellPenetrationMythicBonus(
        Blueprint<BlueprintUnitFact, BlueprintUnitFactReference>? greater = null)
    {
      var component = new SpellPenetrationMythicBonus();
      component.m_Greater = greater?.Reference ?? component.m_Greater;
      if (component.m_Greater is null)
      {
        component.m_Greater = BlueprintTool.GetRef<BlueprintUnitFactReference>(null);
      }
      return AddComponent(component);
    }

    /// <summary>
    /// Adds <see cref="SurpriseSpells"/>
    /// </summary>
    ///
    /// <remarks>
    ///
    /// <list type="bullet">
    /// <listheader>Used by</listheader>
    /// <item><term>SurpriseSpells</term><description>de5cb97a702699841abd3fc66c69fbcf</description></item>
    /// </list>
    /// </remarks>
    public TBuilder AddSurpriseSpells()
    {
      return AddComponent(new SurpriseSpells());
    }

    /// <summary>
    /// Adds <see cref="Take10ForSuccess"/>
    /// </summary>
    ///
    /// <remarks>
    ///
    /// <list type="bullet">
    /// <listheader>Used by</listheader>
    /// <item><term>ScrollFocus</term><description>51245c2b92a5b4247acf754156798fea</description></item>
    /// <item><term>SkillFocusLoreReligionMythicBuff</term><description>6df797d88f3c6684db48c2f1c36c2987</description></item>
    /// <item><term>SkillFocusUseMagicDeviceMythicBuff</term><description>2b0bd56d9ca82d343ba82b2773e0ec05</description></item>
    /// </list>
    /// </remarks>
    ///
    /// <param name="merge">
    /// If mergeBehavior is ComponentMerge.Merge and the component already exists, this expression is called to merge the components.
    /// </param>
    /// <param name="mergeBehavior">
    /// Handling if the component already exists since the component is unique. Defaults to ComponentMerge.Fail.
    /// </param>
    public TBuilder AddTake10ForSuccess(
        bool? anyType = null,
        UsableItemType? magicDeviceType = null,
        Action<BlueprintComponent, BlueprintComponent>? merge = null,
        ComponentMerge mergeBehavior = ComponentMerge.Merge,
        StatType? skill = null)
    {
      var component = new Take10ForSuccess();
      component.AnyType = anyType ?? component.AnyType;
      component.MagicDeviceType = magicDeviceType ?? component.MagicDeviceType;
      component.Skill = skill ?? component.Skill;
      return AddUniqueComponent(component, mergeBehavior, merge);
    }

    /// <summary>
    /// Adds <see cref="TargetChangedDuringRound"/>
    /// </summary>
    ///
    /// <remarks>
    ///
    /// <list type="bullet">
    /// <listheader>Used by</listheader>
    /// <item><term>DemonicConquestBuff</term><description>169bc1bb918da194ba0ae53e44320a8a</description></item>
    /// </list>
    /// </remarks>
    public TBuilder AddTargetChangedDuringRound(
        ActionsBuilder? actions = null)
    {
      var component = new TargetChangedDuringRound();
      component.Actions = actions?.Build() ?? component.Actions;
      if (component.Actions is null)
      {
        component.Actions = Utils.Constants.Empty.Actions;
      }
      return AddComponent(component);
    }

    /// <summary>
    /// Adds <see cref="TargetCritAutoconfirm"/>
    /// </summary>
    ///
    /// <remarks>
    ///
    /// <para>
    /// ComponentName: Crits against target are autoconfirmed
    /// </para>
    ///
    /// <list type="bullet">
    /// <listheader>Used by</listheader>
    /// <item><term>CrimsonBannerBuff</term><description>da6ab933823c406e8bcc869e4d3b156b</description></item>
    /// <item><term>DestructionDomainGreaterEffect</term><description>f9de414e53a9c23419fa3cfc0daabde7</description></item>
    /// </list>
    /// </remarks>
    public TBuilder AddTargetCritAutoconfirm()
    {
      return AddComponent(new TargetCritAutoconfirm());
    }

    /// <summary>
    /// Adds <see cref="TargetCritAutoconfirmFromCaster"/>
    /// </summary>
    ///
    /// <remarks>
    ///
    /// <para>
    /// ComponentName: Crits against target are autoconfirmed
    /// </para>
    ///
    /// <list type="bullet">
    /// <listheader>Used by</listheader>
    /// <item><term>FiendishQuarryBuffEnemy</term><description>63d1f3d04959a554eab3d9b9a5f583f3</description></item>
    /// <item><term>Kerz_QuarryBuff</term><description>93be45d19a0140d0afe2f3c9c6acffa0</description></item>
    /// <item><term>QuarryBuff</term><description>b44184c7ca33c6a41bc11cc5ed07addb</description></item>
    /// </list>
    /// </remarks>
    public TBuilder AddTargetCritAutoconfirmFromCaster()
    {
      return AddComponent(new TargetCritAutoconfirmFromCaster());
    }

    /// <summary>
    /// Adds <see cref="TellingBlow"/>
    /// </summary>
    ///
    /// <remarks>
    ///
    /// <para>
    /// ComponentName: Reduces DR against weapons with Focus
    /// </para>
    ///
    /// <list type="bullet">
    /// <listheader>Used by</listheader>
    /// <item><term>StudentOfWarTellingBlow</term><description>1cd672da802093d47a1473ff985acc63</description></item>
    /// </list>
    /// </remarks>
    ///
    /// <param name="buff">
    /// <para>
    /// Blueprint of type BlueprintBuff. You can pass in the blueprint using:
    /// <list type ="bullet">
    ///   <item><term>A blueprint instance</term></item>
    ///   <item><term>A blueprint reference</term></item>
    ///   <item><term>A blueprint id as a string, Guid, or BlueprintGuid</term></item>
    ///   <item><term>A blueprint name registered with <see cref="BlueprintCore.Utils.BlueprintTool">BlueprintTool</see></term></item>
    /// </list>
    /// See <see cref="BlueprintCore.Utils.Blueprint{{T, TRef}}">Blueprint</see> for more details.
    /// </para>
    /// </param>
    /// <param name="immunityFact">
    /// <para>
    /// Blueprint of type BlueprintUnitFact. You can pass in the blueprint using:
    /// <list type ="bullet">
    ///   <item><term>A blueprint instance</term></item>
    ///   <item><term>A blueprint reference</term></item>
    ///   <item><term>A blueprint id as a string, Guid, or BlueprintGuid</term></item>
    ///   <item><term>A blueprint name registered with <see cref="BlueprintCore.Utils.BlueprintTool">BlueprintTool</see></term></item>
    /// </list>
    /// See <see cref="BlueprintCore.Utils.Blueprint{{T, TRef}}">Blueprint</see> for more details.
    /// </para>
    /// </param>
    public TBuilder AddTellingBlow(
        Blueprint<BlueprintBuff, BlueprintBuffReference>? buff = null,
        Blueprint<BlueprintUnitFact, BlueprintUnitFactReference>? immunityFact = null,
        int? reductionReduction = null)
    {
      var component = new TellingBlow();
      component.m_Buff = buff?.Reference ?? component.m_Buff;
      if (component.m_Buff is null)
      {
        component.m_Buff = BlueprintTool.GetRef<BlueprintBuffReference>(null);
      }
      component.m_ImmunityFact = immunityFact?.Reference ?? component.m_ImmunityFact;
      if (component.m_ImmunityFact is null)
      {
        component.m_ImmunityFact = BlueprintTool.GetRef<BlueprintUnitFactReference>(null);
      }
      component.ReductionReduction = reductionReduction ?? component.ReductionReduction;
      return AddComponent(component);
    }

    /// <summary>
    /// Adds <see cref="ToughnessLogic"/>
    /// </summary>
    ///
    /// <remarks>
    ///
    /// <para>
    /// ComponentName: Add calculated hit points
    /// </para>
    ///
    /// <list type="bullet">
    /// <listheader>Used by</listheader>
    /// <item><term>MythicResolveMythicFeat</term><description>3ae0668ab9c707440b6b26d591f15147</description></item>
    /// <item><term>Toughness</term><description>d09b20029e9abfe4480b356c92095623</description></item>
    /// <item><term>ToughnessMythicFeat</term><description>d8df8f8ad7149824e8e60dd3453557d2</description></item>
    /// </list>
    /// </remarks>
    public TBuilder AddToughnessLogic(
        bool? checkMythicLevel = null)
    {
      var component = new ToughnessLogic();
      component.CheckMythicLevel = checkMythicLevel ?? component.CheckMythicLevel;
      return AddComponent(component);
    }

    /// <summary>
    /// Adds <see cref="TransferDescriptorBonusToSavingThrow"/>
    /// </summary>
    ///
    /// <remarks>
    ///
    /// <list type="bullet">
    /// <listheader>Used by</listheader>
    /// <item><term>KnightOfTheWallSoulShield</term><description>896040a4ae977124bb68ddeca398fcac</description></item>
    /// </list>
    /// </remarks>
    ///
    /// <param name="merge">
    /// If mergeBehavior is ComponentMerge.Merge and the component already exists, this expression is called to merge the components.
    /// </param>
    /// <param name="mergeBehavior">
    /// Handling if the component already exists since the component is unique. Defaults to ComponentMerge.Fail.
    /// </param>
    public TBuilder AddTransferDescriptorBonusToSavingThrow(
        ArmorProficiencyGroup? category = null,
        bool? checkArmorCategory = null,
        ModifierDescriptor? descriptor = null,
        int? maxBonus = null,
        Action<BlueprintComponent, BlueprintComponent>? merge = null,
        ComponentMerge mergeBehavior = ComponentMerge.Merge,
        SavingThrowType? type = null)
    {
      var component = new TransferDescriptorBonusToSavingThrow();
      component.Category = category ?? component.Category;
      component.CheckArmorCategory = checkArmorCategory ?? component.CheckArmorCategory;
      component.Descriptor = descriptor ?? component.Descriptor;
      component.MaxBonus = maxBonus ?? component.MaxBonus;
      component.Type = type ?? component.Type;
      return AddUniqueComponent(component, mergeBehavior, merge);
    }

    /// <summary>
    /// Adds <see cref="TransferDescriptorBonusToTouchAC"/>
    /// </summary>
    ///
    /// <remarks>
    ///
    /// <list type="bullet">
    /// <listheader>Used by</listheader>
    /// <item><term>KnightOfTheWallDeflectiveShield</term><description>f22ba62eb96de4546b9b2d0829744a4e</description></item>
    /// <item><term>ShieldFocusMythicFeat</term><description>502434c044c16304a92901a0b25d5216</description></item>
    /// <item><term>TowerShieldSpecialistTouchShield</term><description>68666566c506d344bad1e30bc3194fed</description></item>
    /// </list>
    /// </remarks>
    public TBuilder AddTransferDescriptorBonusToTouchAC(
        ArmorProficiencyGroup? category = null,
        bool? checkArmorCategory = null,
        ModifierDescriptor? descriptor = null,
        int? maxBonus = null)
    {
      var component = new TransferDescriptorBonusToTouchAC();
      component.Category = category ?? component.Category;
      component.CheckArmorCategory = checkArmorCategory ?? component.CheckArmorCategory;
      component.Descriptor = descriptor ?? component.Descriptor;
      component.MaxBonus = maxBonus ?? component.MaxBonus;
      return AddComponent(component);
    }

    /// <summary>
    /// Adds <see cref="TrapPerceptionBonus"/>
    /// </summary>
    ///
    /// <remarks>
    ///
    /// <para>
    /// ComponentName: Buff on spawned unit
    /// </para>
    ///
    /// <list type="bullet">
    /// <listheader>Used by</listheader>
    /// <item><term>FindTrapsBuff</term><description>d00eba7ecdf5278428cc6b837d9aa52b</description></item>
    /// <item><term>TemporaryFindTrapsBuff</term><description>f8bde76b227949e4893e483373f50c77</description></item>
    /// </list>
    /// </remarks>
    public TBuilder AddTrapPerceptionBonus(
        ModifierDescriptor? descriptor = null,
        ContextValue? value = null)
    {
      var component = new TrapPerceptionBonus();
      component.Descriptor = descriptor ?? component.Descriptor;
      component.Value = value ?? component.Value;
      if (component.Value is null)
      {
        component.Value = ContextValues.Constant(0);
      }
      return AddComponent(component);
    }

    /// <summary>
    /// Adds <see cref="TricksterArcanaAdditionalEnchantments"/>
    /// </summary>
    ///
    /// <remarks>
    ///
    /// <para>
    /// ComponentName: Add ability resources
    /// </para>
    ///
    /// <list type="bullet">
    /// <listheader>Used by</listheader>
    /// <item><term>TricksterKnowledgeArcanaTier2Feature</term><description>7bbd9f681440a294382b527a554e419d</description></item>
    /// <item><term>TricksterKnowledgeArcanaTier3Feature</term><description>5e26c673173e423881e318d2f0ae84f0</description></item>
    /// </list>
    /// </remarks>
    ///
    /// <param name="armorEnchantments">
    /// <para>
    /// Blueprint of type BlueprintArmorEnchantment. You can pass in the blueprint using:
    /// <list type ="bullet">
    ///   <item><term>A blueprint instance</term></item>
    ///   <item><term>A blueprint reference</term></item>
    ///   <item><term>A blueprint id as a string, Guid, or BlueprintGuid</term></item>
    ///   <item><term>A blueprint name registered with <see cref="BlueprintCore.Utils.BlueprintTool">BlueprintTool</see></term></item>
    /// </list>
    /// See <see cref="BlueprintCore.Utils.Blueprint{{T, TRef}}">Blueprint</see> for more details.
    /// </para>
    /// </param>
    /// <param name="commonEnchantments">
    /// <para>
    /// Blueprint of type BlueprintItemEnchantment. You can pass in the blueprint using:
    /// <list type ="bullet">
    ///   <item><term>A blueprint instance</term></item>
    ///   <item><term>A blueprint reference</term></item>
    ///   <item><term>A blueprint id as a string, Guid, or BlueprintGuid</term></item>
    ///   <item><term>A blueprint name registered with <see cref="BlueprintCore.Utils.BlueprintTool">BlueprintTool</see></term></item>
    /// </list>
    /// See <see cref="BlueprintCore.Utils.Blueprint{{T, TRef}}">Blueprint</see> for more details.
    /// </para>
    /// </param>
    /// <param name="merge">
    /// If mergeBehavior is ComponentMerge.Merge and the component already exists, this expression is called to merge the components.
    /// </param>
    /// <param name="mergeBehavior">
    /// Handling if the component already exists since the component is unique. Defaults to ComponentMerge.Fail.
    /// </param>
    /// <param name="weaponEnchantments">
    /// <para>
    /// Blueprint of type BlueprintWeaponEnchantment. You can pass in the blueprint using:
    /// <list type ="bullet">
    ///   <item><term>A blueprint instance</term></item>
    ///   <item><term>A blueprint reference</term></item>
    ///   <item><term>A blueprint id as a string, Guid, or BlueprintGuid</term></item>
    ///   <item><term>A blueprint name registered with <see cref="BlueprintCore.Utils.BlueprintTool">BlueprintTool</see></term></item>
    /// </list>
    /// See <see cref="BlueprintCore.Utils.Blueprint{{T, TRef}}">Blueprint</see> for more details.
    /// </para>
    /// </param>
    public TBuilder AddTricksterArcanaAdditionalEnchantments(
        List<Blueprint<BlueprintArmorEnchantment, BlueprintArmorEnchantmentReference>>? armorEnchantments = null,
        List<Blueprint<BlueprintItemEnchantment, BlueprintItemEnchantmentReference>>? commonEnchantments = null,
        Action<BlueprintComponent, BlueprintComponent>? merge = null,
        ComponentMerge mergeBehavior = ComponentMerge.Merge,
        bool? onlyWeaponsShieldsAndArmor = null,
        List<Blueprint<BlueprintWeaponEnchantment, BlueprintWeaponEnchantmentReference>>? weaponEnchantments = null)
    {
      var component = new TricksterArcanaAdditionalEnchantments();
      component.ArmorEnchantments = armorEnchantments?.Select(bp => bp.Reference)?.ToArray() ?? component.ArmorEnchantments;
      if (component.ArmorEnchantments is null)
      {
        component.ArmorEnchantments = new BlueprintArmorEnchantmentReference[0];
      }
      component.CommonEnchantments = commonEnchantments?.Select(bp => bp.Reference)?.ToArray() ?? component.CommonEnchantments;
      if (component.CommonEnchantments is null)
      {
        component.CommonEnchantments = new BlueprintItemEnchantmentReference[0];
      }
      component.OnlyWeaponsShieldsAndArmor = onlyWeaponsShieldsAndArmor ?? component.OnlyWeaponsShieldsAndArmor;
      component.WeaponEnchantments = weaponEnchantments?.Select(bp => bp.Reference)?.ToArray() ?? component.WeaponEnchantments;
      if (component.WeaponEnchantments is null)
      {
        component.WeaponEnchantments = new BlueprintWeaponEnchantmentReference[0];
      }
      return AddUniqueComponent(component, mergeBehavior, merge);
    }

    /// <summary>
    /// Adds <see cref="TricksterArcanaBetterEnhancements"/>
    /// </summary>
    ///
    /// <remarks>
    ///
    /// <para>
    /// ComponentName: Add ability resources
    /// </para>
    ///
    /// <list type="bullet">
    /// <listheader>Used by</listheader>
    /// <item><term>TricksterKnowledgeArcanaTier1Feature</term><description>c7bb946de7454df4380c489a8350ba38</description></item>
    /// </list>
    /// </remarks>
    ///
    /// <param name="bestEnchantments">
    /// <para>
    /// Blueprint of type BlueprintItemEnchantment. You can pass in the blueprint using:
    /// <list type ="bullet">
    ///   <item><term>A blueprint instance</term></item>
    ///   <item><term>A blueprint reference</term></item>
    ///   <item><term>A blueprint id as a string, Guid, or BlueprintGuid</term></item>
    ///   <item><term>A blueprint name registered with <see cref="BlueprintCore.Utils.BlueprintTool">BlueprintTool</see></term></item>
    /// </list>
    /// See <see cref="BlueprintCore.Utils.Blueprint{{T, TRef}}">Blueprint</see> for more details.
    /// </para>
    /// </param>
    /// <param name="enhancementEnchantments">
    /// <para>
    /// Blueprint of type BlueprintItemEnchantment. You can pass in the blueprint using:
    /// <list type ="bullet">
    ///   <item><term>A blueprint instance</term></item>
    ///   <item><term>A blueprint reference</term></item>
    ///   <item><term>A blueprint id as a string, Guid, or BlueprintGuid</term></item>
    ///   <item><term>A blueprint name registered with <see cref="BlueprintCore.Utils.BlueprintTool">BlueprintTool</see></term></item>
    /// </list>
    /// See <see cref="BlueprintCore.Utils.Blueprint{{T, TRef}}">Blueprint</see> for more details.
    /// </para>
    /// </param>
    /// <param name="merge">
    /// If mergeBehavior is ComponentMerge.Merge and the component already exists, this expression is called to merge the components.
    /// </param>
    /// <param name="mergeBehavior">
    /// Handling if the component already exists since the component is unique. Defaults to ComponentMerge.Fail.
    /// </param>
    public TBuilder AddTricksterArcanaBetterEnhancements(
        List<Blueprint<BlueprintItemEnchantment, BlueprintItemEnchantmentReference>>? bestEnchantments = null,
        List<Blueprint<BlueprintItemEnchantment, BlueprintItemEnchantmentReference>>? enhancementEnchantments = null,
        Action<BlueprintComponent, BlueprintComponent>? merge = null,
        ComponentMerge mergeBehavior = ComponentMerge.Merge)
    {
      var component = new TricksterArcanaBetterEnhancements();
      component.BestEnchantments = bestEnchantments?.Select(bp => bp.Reference)?.ToList() ?? component.BestEnchantments;
      if (component.BestEnchantments is null)
      {
        component.BestEnchantments = new();
      }
      component.EnhancementEnchantments = enhancementEnchantments?.Select(bp => bp.Reference)?.ToArray() ?? component.EnhancementEnchantments;
      if (component.EnhancementEnchantments is null)
      {
        component.EnhancementEnchantments = new BlueprintItemEnchantmentReference[0];
      }
      return AddUniqueComponent(component, mergeBehavior, merge);
    }

    /// <summary>
    /// Adds <see cref="TricksterKnowledgeWorldD20"/>
    /// </summary>
    ///
    /// <remarks>
    ///
    /// <list type="bullet">
    /// <listheader>Used by</listheader>
    /// <item><term>TricksterKnowledgeWorldTier2Feature</term><description>8b6fe337865492645892cc8db5dd0e01</description></item>
    /// </list>
    /// </remarks>
    ///
    /// <param name="merge">
    /// If mergeBehavior is ComponentMerge.Merge and the component already exists, this expression is called to merge the components.
    /// </param>
    /// <param name="mergeBehavior">
    /// Handling if the component already exists since the component is unique. Defaults to ComponentMerge.Fail.
    /// </param>
    public TBuilder AddTricksterKnowledgeWorldD20(
        Action<BlueprintComponent, BlueprintComponent>? merge = null,
        ComponentMerge mergeBehavior = ComponentMerge.Merge)
    {
      var component = new TricksterKnowledgeWorldD20();
      return AddUniqueComponent(component, mergeBehavior, merge);
    }

    /// <summary>
    /// Adds <see cref="TricksterKnowledgeWorldSkillBonus"/>
    /// </summary>
    ///
    /// <remarks>
    ///
    /// <list type="bullet">
    /// <listheader>Used by</listheader>
    /// <item><term>TricksterKnowledgeWorldTier1Feature</term><description>06983a66bd6bac04db3996cd3064d9f0</description></item>
    /// </list>
    /// </remarks>
    ///
    /// <param name="merge">
    /// If mergeBehavior is ComponentMerge.Merge and the component already exists, this expression is called to merge the components.
    /// </param>
    /// <param name="mergeBehavior">
    /// Handling if the component already exists since the component is unique. Defaults to ComponentMerge.Fail.
    /// </param>
    public TBuilder AddTricksterKnowledgeWorldSkillBonus(
        Action<BlueprintComponent, BlueprintComponent>? merge = null,
        ComponentMerge mergeBehavior = ComponentMerge.Merge)
    {
      var component = new TricksterKnowledgeWorldSkillBonus();
      return AddUniqueComponent(component, mergeBehavior, merge);
    }

    /// <summary>
    /// Adds <see cref="TricksterLoreNatureRestTrigger"/>
    /// </summary>
    ///
    /// <remarks>
    ///
    /// <list type="bullet">
    /// <listheader>Used by</listheader>
    /// <item><term>TricksterLoreNature1Feature</term><description>cb232b9ed5c216242a667e95527ad8e1</description></item>
    /// </list>
    /// </remarks>
    ///
    /// <param name="merge">
    /// If mergeBehavior is ComponentMerge.Merge and the component already exists, this expression is called to merge the components.
    /// </param>
    /// <param name="mergeBehavior">
    /// Handling if the component already exists since the component is unique. Defaults to ComponentMerge.Fail.
    /// </param>
    /// <param name="tier1Buffs">
    /// <para>
    /// Blueprint of type BlueprintBuff. You can pass in the blueprint using:
    /// <list type ="bullet">
    ///   <item><term>A blueprint instance</term></item>
    ///   <item><term>A blueprint reference</term></item>
    ///   <item><term>A blueprint id as a string, Guid, or BlueprintGuid</term></item>
    ///   <item><term>A blueprint name registered with <see cref="BlueprintCore.Utils.BlueprintTool">BlueprintTool</see></term></item>
    /// </list>
    /// See <see cref="BlueprintCore.Utils.Blueprint{{T, TRef}}">Blueprint</see> for more details.
    /// </para>
    /// </param>
    /// <param name="tier2Buffs">
    /// <para>
    /// Blueprint of type BlueprintBuff. You can pass in the blueprint using:
    /// <list type ="bullet">
    ///   <item><term>A blueprint instance</term></item>
    ///   <item><term>A blueprint reference</term></item>
    ///   <item><term>A blueprint id as a string, Guid, or BlueprintGuid</term></item>
    ///   <item><term>A blueprint name registered with <see cref="BlueprintCore.Utils.BlueprintTool">BlueprintTool</see></term></item>
    /// </list>
    /// See <see cref="BlueprintCore.Utils.Blueprint{{T, TRef}}">Blueprint</see> for more details.
    /// </para>
    /// </param>
    /// <param name="tier2Feature">
    /// <para>
    /// Blueprint of type BlueprintFeature. You can pass in the blueprint using:
    /// <list type ="bullet">
    ///   <item><term>A blueprint instance</term></item>
    ///   <item><term>A blueprint reference</term></item>
    ///   <item><term>A blueprint id as a string, Guid, or BlueprintGuid</term></item>
    ///   <item><term>A blueprint name registered with <see cref="BlueprintCore.Utils.BlueprintTool">BlueprintTool</see></term></item>
    /// </list>
    /// See <see cref="BlueprintCore.Utils.Blueprint{{T, TRef}}">Blueprint</see> for more details.
    /// </para>
    /// </param>
    /// <param name="tier3Buffs">
    /// <para>
    /// Blueprint of type BlueprintBuff. You can pass in the blueprint using:
    /// <list type ="bullet">
    ///   <item><term>A blueprint instance</term></item>
    ///   <item><term>A blueprint reference</term></item>
    ///   <item><term>A blueprint id as a string, Guid, or BlueprintGuid</term></item>
    ///   <item><term>A blueprint name registered with <see cref="BlueprintCore.Utils.BlueprintTool">BlueprintTool</see></term></item>
    /// </list>
    /// See <see cref="BlueprintCore.Utils.Blueprint{{T, TRef}}">Blueprint</see> for more details.
    /// </para>
    /// </param>
    /// <param name="tier3Feature">
    /// <para>
    /// Blueprint of type BlueprintFeature. You can pass in the blueprint using:
    /// <list type ="bullet">
    ///   <item><term>A blueprint instance</term></item>
    ///   <item><term>A blueprint reference</term></item>
    ///   <item><term>A blueprint id as a string, Guid, or BlueprintGuid</term></item>
    ///   <item><term>A blueprint name registered with <see cref="BlueprintCore.Utils.BlueprintTool">BlueprintTool</see></term></item>
    /// </list>
    /// See <see cref="BlueprintCore.Utils.Blueprint{{T, TRef}}">Blueprint</see> for more details.
    /// </para>
    /// </param>
    public TBuilder AddTricksterLoreNatureRestTrigger(
        Action<BlueprintComponent, BlueprintComponent>? merge = null,
        ComponentMerge mergeBehavior = ComponentMerge.Merge,
        List<Blueprint<BlueprintBuff, BlueprintBuffReference>>? tier1Buffs = null,
        List<Blueprint<BlueprintBuff, BlueprintBuffReference>>? tier2Buffs = null,
        Blueprint<BlueprintFeature, BlueprintFeatureReference>? tier2Feature = null,
        List<Blueprint<BlueprintBuff, BlueprintBuffReference>>? tier3Buffs = null,
        Blueprint<BlueprintFeature, BlueprintFeatureReference>? tier3Feature = null)
    {
      var component = new TricksterLoreNatureRestTrigger();
      component.Tier1Buffs = tier1Buffs?.Select(bp => bp.Reference)?.ToArray() ?? component.Tier1Buffs;
      if (component.Tier1Buffs is null)
      {
        component.Tier1Buffs = new BlueprintBuffReference[0];
      }
      component.Tier2Buffs = tier2Buffs?.Select(bp => bp.Reference)?.ToArray() ?? component.Tier2Buffs;
      if (component.Tier2Buffs is null)
      {
        component.Tier2Buffs = new BlueprintBuffReference[0];
      }
      component.m_Tier2Feature = tier2Feature?.Reference ?? component.m_Tier2Feature;
      if (component.m_Tier2Feature is null)
      {
        component.m_Tier2Feature = BlueprintTool.GetRef<BlueprintFeatureReference>(null);
      }
      component.Tier3Buffs = tier3Buffs?.Select(bp => bp.Reference)?.ToArray() ?? component.Tier3Buffs;
      if (component.Tier3Buffs is null)
      {
        component.Tier3Buffs = new BlueprintBuffReference[0];
      }
      component.m_Tier3Feature = tier3Feature?.Reference ?? component.m_Tier3Feature;
      if (component.m_Tier3Feature is null)
      {
        component.m_Tier3Feature = BlueprintTool.GetRef<BlueprintFeatureReference>(null);
      }
      return AddUniqueComponent(component, mergeBehavior, merge);
    }

    /// <summary>
    /// Adds <see cref="TwoWeaponFightingAttackPenalty"/>
    /// </summary>
    ///
    /// <remarks>
    ///
    /// <para>
    /// ComponentName: Basic Mechanics for two weapon fighting
    /// </para>
    ///
    /// <list type="bullet">
    /// <listheader>Used by</listheader>
    /// <item><term>TwoWeaponFightingBasicMechanics</term><description>6948b379c0562714d9f6d58ccbfa8faa</description></item>
    /// </list>
    /// </remarks>
    ///
    /// <param name="mythicBlueprint">
    /// <para>
    /// Blueprint of type BlueprintFeature. You can pass in the blueprint using:
    /// <list type ="bullet">
    ///   <item><term>A blueprint instance</term></item>
    ///   <item><term>A blueprint reference</term></item>
    ///   <item><term>A blueprint id as a string, Guid, or BlueprintGuid</term></item>
    ///   <item><term>A blueprint name registered with <see cref="BlueprintCore.Utils.BlueprintTool">BlueprintTool</see></term></item>
    /// </list>
    /// See <see cref="BlueprintCore.Utils.Blueprint{{T, TRef}}">Blueprint</see> for more details.
    /// </para>
    /// </param>
    public TBuilder AddTwoWeaponFightingAttackPenalty(
        Blueprint<BlueprintFeature, BlueprintFeatureReference>? mythicBlueprint = null)
    {
      var component = new TwoWeaponFightingAttackPenalty();
      component.m_MythicBlueprint = mythicBlueprint?.Reference ?? component.m_MythicBlueprint;
      if (component.m_MythicBlueprint is null)
      {
        component.m_MythicBlueprint = BlueprintTool.GetRef<BlueprintFeatureReference>(null);
      }
      return AddComponent(component);
    }

    /// <summary>
    /// Adds <see cref="TwoWeaponFightingAttacks"/>
    /// </summary>
    ///
    /// <remarks>
    ///
    /// <para>
    /// ComponentName: BuffMechanics/Extra Attack
    /// </para>
    ///
    /// <list type="bullet">
    /// <listheader>Used by</listheader>
    /// <item><term>TwoWeaponFightingBasicMechanics</term><description>6948b379c0562714d9f6d58ccbfa8faa</description></item>
    /// </list>
    /// </remarks>
    public TBuilder AddTwoWeaponFightingAttacks()
    {
      return AddComponent(new TwoWeaponFightingAttacks());
    }

    /// <summary>
    /// Adds <see cref="TwoWeaponFightingDamagePenalty"/>
    /// </summary>
    ///
    /// <remarks>
    ///
    /// <list type="bullet">
    /// <listheader>Used by</listheader>
    /// <item><term>TwoWeaponFightingBasicMechanics</term><description>6948b379c0562714d9f6d58ccbfa8faa</description></item>
    /// </list>
    /// </remarks>
    public TBuilder AddTwoWeaponFightingDamagePenalty()
    {
      return AddComponent(new TwoWeaponFightingDamagePenalty());
    }

    /// <summary>
    /// Adds <see cref="UndeadHealth"/>
    /// </summary>
    ///
    /// <remarks>
    ///
    /// <para>
    /// ComponentName: Add hit points from Charisma
    /// </para>
    ///
    /// <list type="bullet">
    /// <listheader>Used by</listheader>
    /// <item><term>ArmyPlaguedBeastTemplate</term><description>96cf8eaa67d309843a274df01461017e</description></item>
    /// <item><term>PlaguedBeastTemplate_NoPlague</term><description>8df24186a5974aeb8858082cfb34f6b2</description></item>
    /// <item><term>VampireTemplate</term><description>28e12f4480a66f1499aa118896197719</description></item>
    /// </list>
    /// </remarks>
    public TBuilder AddUndeadHealth()
    {
      return AddComponent(new UndeadHealth());
    }

    /// <summary>
    /// Adds <see cref="UnitDeathTrigger"/>
    /// </summary>
    ///
    /// <remarks>
    ///
    /// <list type="bullet">
    /// <listheader>Used by</listheader>
    /// <item><term>MenanceOfDeathAmuletFeature</term><description>c317350d45ab4d2291fe00134b29bdae</description></item>
    /// <item><term>TimelyAssistanceFeature</term><description>6561c197db404818844a5bd71a61525b</description></item>
    /// </list>
    /// </remarks>
    public TBuilder AddUnitDeathTrigger(
        ActionsBuilder? actions = null,
        UnitDeathTrigger.FactionType? faction = null,
        ContextValue? radiusInMeters = null)
    {
      var component = new UnitDeathTrigger();
      component.Actions = actions?.Build() ?? component.Actions;
      if (component.Actions is null)
      {
        component.Actions = Utils.Constants.Empty.Actions;
      }
      component.Faction = faction ?? component.Faction;
      component.RadiusInMeters = radiusInMeters ?? component.RadiusInMeters;
      if (component.RadiusInMeters is null)
      {
        component.RadiusInMeters = ContextValues.Constant(0);
      }
      return AddComponent(component);
    }

    /// <summary>
    /// Adds <see cref="WeaponCategoryAttackBonus"/>
    /// </summary>
    ///
    /// <remarks>
    ///
    /// <list type="bullet">
    /// <listheader>Used by</listheader>
    /// <item><term>AnimalAspectGreaterMonkeyBuff</term><description>6bf59a6fca16f6d4887e3544e5c2f689</description></item>
    /// <item><term>ElementalOverflowBuff 4</term><description>eea9c3a8e8b169b4a83a75613e350b56</description></item>
    /// <item><term>ThrowAnything</term><description>65c538dcfd91930489ad3ab18ad9204b</description></item>
    /// </list>
    /// </remarks>
    public TBuilder AddWeaponCategoryAttackBonus(
        int? attackBonus = null,
        WeaponCategory? category = null,
        ModifierDescriptor? descriptor = null)
    {
      var component = new WeaponCategoryAttackBonus();
      component.AttackBonus = attackBonus ?? component.AttackBonus;
      component.Category = category ?? component.Category;
      component.Descriptor = descriptor ?? component.Descriptor;
      return AddComponent(component);
    }

    /// <summary>
    /// Adds <see cref="WeaponFocus"/>
    /// </summary>
    ///
    /// <remarks>
    ///
    /// <para>
    /// ComponentName: Weapon type attack bonus
    /// </para>
    ///
    /// <list type="bullet">
    /// <listheader>Used by</listheader>
    /// <item><term>SpellblastBombBuff</term><description>c783f23e678f71542995c01e36540206</description></item>
    /// <item><term>WeaponFocusGreaterSlam</term><description>8c43f9f60ce0c4d4ca8e8ec6872b46b0</description></item>
    /// <item><term>WeaponSpecializationBite</term><description>b41b5a06b3c2108428e54820314423bd</description></item>
    /// </list>
    /// </remarks>
    ///
    /// <param name="merge">
    /// If mergeBehavior is ComponentMerge.Merge and the component already exists, this expression is called to merge the components.
    /// </param>
    /// <param name="mergeBehavior">
    /// Handling if the component already exists since the component is unique. Defaults to ComponentMerge.Fail.
    /// </param>
    /// <param name="weaponType">
    /// <para>
    /// Blueprint of type BlueprintWeaponType. You can pass in the blueprint using:
    /// <list type ="bullet">
    ///   <item><term>A blueprint instance</term></item>
    ///   <item><term>A blueprint reference</term></item>
    ///   <item><term>A blueprint id as a string, Guid, or BlueprintGuid</term></item>
    ///   <item><term>A blueprint name registered with <see cref="BlueprintCore.Utils.BlueprintTool">BlueprintTool</see></term></item>
    /// </list>
    /// See <see cref="BlueprintCore.Utils.Blueprint{{T, TRef}}">Blueprint</see> for more details.
    /// </para>
    /// </param>
    public TBuilder AddWeaponFocus(
        int? attackBonus = null,
        ModifierDescriptor? descriptor = null,
        Action<BlueprintComponent, BlueprintComponent>? merge = null,
        ComponentMerge mergeBehavior = ComponentMerge.Merge,
        Blueprint<BlueprintWeaponType, BlueprintWeaponTypeReference>? weaponType = null)
    {
      var component = new WeaponFocus();
      component.AttackBonus = attackBonus ?? component.AttackBonus;
      component.Descriptor = descriptor ?? component.Descriptor;
      component.m_WeaponType = weaponType?.Reference ?? component.m_WeaponType;
      if (component.m_WeaponType is null)
      {
        component.m_WeaponType = BlueprintTool.GetRef<BlueprintWeaponTypeReference>(null);
      }
      return AddUniqueComponent(component, mergeBehavior, merge);
    }

    /// <summary>
    /// Adds <see cref="WeaponGroupAttackBonus"/>
    /// </summary>
    ///
    /// <remarks>
    ///
    /// <para>
    /// ComponentName: Weapon group attack bonus
    /// </para>
    ///
    /// <list type="bullet">
    /// <listheader>Used by</listheader>
    /// <item><term>ArcheryBonuses</term><description>136adc54467964446b2e790c1698d93a</description></item>
    /// <item><term>SwiftBlowImprovedChargeAbility</term><description>d4b4757660cb66e4fbf376a43f1ffb13</description></item>
    /// <item><term>WorldwoundSettingFeature</term><description>ae2f7620b5bf4282b95abc8b70c0066c</description></item>
    /// </list>
    /// </remarks>
    ///
    /// <param name="merge">
    /// If mergeBehavior is ComponentMerge.Merge and the component already exists, this expression is called to merge the components.
    /// </param>
    /// <param name="mergeBehavior">
    /// Handling if the component already exists since the component is unique. Defaults to ComponentMerge.Fail.
    /// </param>
    /// <param name="multiplyByContext">
    /// <para>
    /// Tooltip: Add calculated value wich multiplies AttackBonus
    /// </para>
    /// </param>
    public TBuilder AddWeaponGroupAttackBonus(
        int? attackBonus = null,
        ContextValue? contextMultiplier = null,
        ModifierDescriptor? descriptor = null,
        Action<BlueprintComponent, BlueprintComponent>? merge = null,
        ComponentMerge mergeBehavior = ComponentMerge.Merge,
        bool? multiplyByContext = null,
        WeaponFighterGroup? weaponGroup = null)
    {
      var component = new WeaponGroupAttackBonus();
      component.AttackBonus = attackBonus ?? component.AttackBonus;
      component.contextMultiplier = contextMultiplier ?? component.contextMultiplier;
      if (component.contextMultiplier is null)
      {
        component.contextMultiplier = ContextValues.Constant(0);
      }
      component.Descriptor = descriptor ?? component.Descriptor;
      component.multiplyByContext = multiplyByContext ?? component.multiplyByContext;
      component.WeaponGroup = weaponGroup ?? component.WeaponGroup;
      return AddUniqueComponent(component, mergeBehavior, merge);
    }

    /// <summary>
    /// Adds <see cref="WeaponGroupDamageBonus"/>
    /// </summary>
    ///
    /// <remarks>
    ///
    /// <para>
    /// ComponentName: Weapon group damage bonus
    /// </para>
    ///
    /// <list type="bullet">
    /// <listheader>Used by</listheader>
    /// <item><term>ArcheryBonuses</term><description>136adc54467964446b2e790c1698d93a</description></item>
    /// <item><term>SwiftBlowImprovedChargeAbility</term><description>d4b4757660cb66e4fbf376a43f1ffb13</description></item>
    /// <item><term>WorldwoundSettingFeature</term><description>ae2f7620b5bf4282b95abc8b70c0066c</description></item>
    /// </list>
    /// </remarks>
    public TBuilder AddWeaponGroupDamageBonus(
        ContextValue? additionalValue = null,
        int? damageBonus = null,
        ModifierDescriptor? descriptor = null,
        WeaponFighterGroup? weaponGroup = null)
    {
      var component = new WeaponGroupDamageBonus();
      component.AdditionalValue = additionalValue ?? component.AdditionalValue;
      if (component.AdditionalValue is null)
      {
        component.AdditionalValue = ContextValues.Constant(0);
      }
      component.DamageBonus = damageBonus ?? component.DamageBonus;
      component.Descriptor = descriptor ?? component.Descriptor;
      component.WeaponGroup = weaponGroup ?? component.WeaponGroup;
      return AddComponent(component);
    }

    /// <summary>
    /// Adds <see cref="WeaponGroupEnchant"/>
    /// </summary>
    ///
    /// <remarks>
    ///
    /// <para>
    /// ComponentName: Weapon group enchant
    /// </para>
    ///
    /// <list type="bullet">
    /// <listheader>Used by</listheader>
    /// <item><term>DemonNaturalAttackFeatureLevel5</term><description>66285313d89a863469cd056f2d6e32a0</description></item>
    /// <item><term>GhoulGreaterMagicFang</term><description>7fbd6c1e0af1f5b408b903e8bc5c4784</description></item>
    /// <item><term>KeketarMagicFangGreater5</term><description>399aa0aad71c4de7a9b9c1e008b8a545</description></item>
    /// </list>
    /// </remarks>
    public TBuilder AddWeaponGroupEnchant(
        int? bonus = null,
        ModifierDescriptor? descriptor = null,
        WeaponFighterGroup? weaponGroup = null)
    {
      var component = new WeaponGroupEnchant();
      component.Bonus = bonus ?? component.Bonus;
      component.Descriptor = descriptor ?? component.Descriptor;
      component.WeaponGroup = weaponGroup ?? component.WeaponGroup;
      return AddComponent(component);
    }

    /// <summary>
    /// Adds <see cref="WeaponMultipleCategoriesAttackBonus"/>
    /// </summary>
    ///
    /// <remarks>
    ///
    /// <list type="bullet">
    /// <listheader>Used by</listheader>
    /// <item><term>BlackenedCurseAttackRollLevel1</term><description>a52a37d93340ade4fb8128fc8d30df28</description></item>
    /// <item><term>BlackenedCurseAttackRollLevel10</term><description>a7c8ef7c2dcdc4b4a8f5ff8a73f03421</description></item>
    /// <item><term>LongspearOfOraclesMiseryBlackenedCurseBuff</term><description>85d23ec1f2d6b90489e8c246d29ca40d</description></item>
    /// </list>
    /// </remarks>
    public TBuilder AddWeaponMultipleCategoriesAttackBonus(
        int? attackBonus = null,
        WeaponCategory[]? categories = null,
        ModifierDescriptor? descriptor = null,
        bool? exceptForCategories = null)
    {
      var component = new WeaponMultipleCategoriesAttackBonus();
      component.AttackBonus = attackBonus ?? component.AttackBonus;
      component.Categories = categories ?? component.Categories;
      if (component.Categories is null)
      {
        component.Categories = new WeaponCategory[0];
      }
      component.Descriptor = descriptor ?? component.Descriptor;
      component.ExceptForCategories = exceptForCategories ?? component.ExceptForCategories;
      return AddComponent(component);
    }

    /// <summary>
    /// Adds <see cref="WeaponParametersAttackBonus"/>
    /// </summary>
    ///
    /// <remarks>
    ///
    /// <para>
    /// ComponentName: Weapon parameters attack bonus
    /// </para>
    ///
    /// <list type="bullet">
    /// <listheader>Used by</listheader>
    /// <item><term>AcidFogBuff</term><description>af76754540cacca45bfb1f0074bf3013</description></item>
    /// <item><term>PowerAttackBuff</term><description>5898bcf75a0942449a5dc16adc97b279</description></item>
    /// <item><term>TwoHandedFighterWeaponTraining</term><description>88da2a5dfc505054f933bb81014e864f</description></item>
    /// </list>
    /// </remarks>
    ///
    /// <param name="fightersFinesse">
    /// <para>
    /// Blueprint of type BlueprintFeature. You can pass in the blueprint using:
    /// <list type ="bullet">
    ///   <item><term>A blueprint instance</term></item>
    ///   <item><term>A blueprint reference</term></item>
    ///   <item><term>A blueprint id as a string, Guid, or BlueprintGuid</term></item>
    ///   <item><term>A blueprint name registered with <see cref="BlueprintCore.Utils.BlueprintTool">BlueprintTool</see></term></item>
    /// </list>
    /// See <see cref="BlueprintCore.Utils.Blueprint{{T, TRef}}">Blueprint</see> for more details.
    /// </para>
    /// </param>
    /// <param name="merge">
    /// If mergeBehavior is ComponentMerge.Merge and the component already exists, this expression is called to merge the components.
    /// </param>
    /// <param name="mergeBehavior">
    /// Handling if the component already exists since the component is unique. Defaults to ComponentMerge.Fail.
    /// </param>
    /// <param name="multiplierFact">
    /// <para>
    /// Blueprint of type BlueprintUnitFact. You can pass in the blueprint using:
    /// <list type ="bullet">
    ///   <item><term>A blueprint instance</term></item>
    ///   <item><term>A blueprint reference</term></item>
    ///   <item><term>A blueprint id as a string, Guid, or BlueprintGuid</term></item>
    ///   <item><term>A blueprint name registered with <see cref="BlueprintCore.Utils.BlueprintTool">BlueprintTool</see></term></item>
    /// </list>
    /// See <see cref="BlueprintCore.Utils.Blueprint{{T, TRef}}">Blueprint</see> for more details.
    /// </para>
    /// </param>
    public TBuilder AddWeaponParametersAttackBonus(
        int? attackBonus = null,
        bool? canBeUsedWithFightersFinesse = null,
        ModifierDescriptor? descriptor = null,
        Blueprint<BlueprintFeature, BlueprintFeatureReference>? fightersFinesse = null,
        Action<BlueprintComponent, BlueprintComponent>? merge = null,
        ComponentMerge mergeBehavior = ComponentMerge.Merge,
        int? multiplier = null,
        Blueprint<BlueprintUnitFact, BlueprintUnitFactReference>? multiplierFact = null,
        bool? onlyFinessable = null,
        bool? onlyForFullAttack = null,
        bool? onlyTwoHanded = null,
        bool? ranged = null,
        bool? scaleByBasicAttackBonus = null)
    {
      var component = new WeaponParametersAttackBonus();
      component.AttackBonus = attackBonus ?? component.AttackBonus;
      component.CanBeUsedWithFightersFinesse = canBeUsedWithFightersFinesse ?? component.CanBeUsedWithFightersFinesse;
      component.Descriptor = descriptor ?? component.Descriptor;
      component.m_FightersFinesse = fightersFinesse?.Reference ?? component.m_FightersFinesse;
      if (component.m_FightersFinesse is null)
      {
        component.m_FightersFinesse = BlueprintTool.GetRef<BlueprintFeatureReference>(null);
      }
      component.Multiplier = multiplier ?? component.Multiplier;
      component.m_MultiplierFact = multiplierFact?.Reference ?? component.m_MultiplierFact;
      if (component.m_MultiplierFact is null)
      {
        component.m_MultiplierFact = BlueprintTool.GetRef<BlueprintUnitFactReference>(null);
      }
      component.OnlyFinessable = onlyFinessable ?? component.OnlyFinessable;
      component.OnlyForFullAttack = onlyForFullAttack ?? component.OnlyForFullAttack;
      component.OnlyTwoHanded = onlyTwoHanded ?? component.OnlyTwoHanded;
      component.Ranged = ranged ?? component.Ranged;
      component.ScaleByBasicAttackBonus = scaleByBasicAttackBonus ?? component.ScaleByBasicAttackBonus;
      return AddUniqueComponent(component, mergeBehavior, merge);
    }

    /// <summary>
    /// Adds <see cref="WeaponParametersCriticalEdgeIncrease"/>
    /// </summary>
    ///
    /// <remarks>
    ///
    /// <para>
    /// ComponentName: Weapon parameters critical edge increase
    /// </para>
    ///
    /// <list type="bullet">
    /// <listheader>Used by</listheader>
    /// <item><term>Cambion_Feature_SadisticStrike</term><description>0d1f2972f5b378b44afaaa73c535366d</description></item>
    /// </list>
    /// </remarks>
    ///
    /// <param name="merge">
    /// If mergeBehavior is ComponentMerge.Merge and the component already exists, this expression is called to merge the components.
    /// </param>
    /// <param name="mergeBehavior">
    /// Handling if the component already exists since the component is unique. Defaults to ComponentMerge.Fail.
    /// </param>
    public TBuilder AddWeaponParametersCriticalEdgeIncrease(
        bool? light = null,
        Action<BlueprintComponent, BlueprintComponent>? merge = null,
        ComponentMerge mergeBehavior = ComponentMerge.Merge,
        bool? ranged = null,
        bool? twoHanded = null)
    {
      var component = new WeaponParametersCriticalEdgeIncrease();
      component.Light = light ?? component.Light;
      component.Ranged = ranged ?? component.Ranged;
      component.TwoHanded = twoHanded ?? component.TwoHanded;
      return AddUniqueComponent(component, mergeBehavior, merge);
    }

    /// <summary>
    /// Adds <see cref="WeaponParametersDamageBonus"/>
    /// </summary>
    ///
    /// <remarks>
    ///
    /// <para>
    /// ComponentName: Weapon type damage bonus
    /// </para>
    ///
    /// <list type="bullet">
    /// <listheader>Used by</listheader>
    /// <item><term>AcidFogBuff</term><description>af76754540cacca45bfb1f0074bf3013</description></item>
    /// <item><term>PiranhaStrikeBuff</term><description>8af258b1dd322874ba6047b0c24660c7</description></item>
    /// <item><term>TwoHandedFighterWeaponTraining</term><description>88da2a5dfc505054f933bb81014e864f</description></item>
    /// </list>
    /// </remarks>
    ///
    /// <param name="fightersFinesse">
    /// <para>
    /// Blueprint of type BlueprintFeature. You can pass in the blueprint using:
    /// <list type ="bullet">
    ///   <item><term>A blueprint instance</term></item>
    ///   <item><term>A blueprint reference</term></item>
    ///   <item><term>A blueprint id as a string, Guid, or BlueprintGuid</term></item>
    ///   <item><term>A blueprint name registered with <see cref="BlueprintCore.Utils.BlueprintTool">BlueprintTool</see></term></item>
    /// </list>
    /// See <see cref="BlueprintCore.Utils.Blueprint{{T, TRef}}">Blueprint</see> for more details.
    /// </para>
    /// </param>
    /// <param name="greaterPowerAttackBlueprint">
    /// <para>
    /// Blueprint of type BlueprintFeature. You can pass in the blueprint using:
    /// <list type ="bullet">
    ///   <item><term>A blueprint instance</term></item>
    ///   <item><term>A blueprint reference</term></item>
    ///   <item><term>A blueprint id as a string, Guid, or BlueprintGuid</term></item>
    ///   <item><term>A blueprint name registered with <see cref="BlueprintCore.Utils.BlueprintTool">BlueprintTool</see></term></item>
    /// </list>
    /// See <see cref="BlueprintCore.Utils.Blueprint{{T, TRef}}">Blueprint</see> for more details.
    /// </para>
    /// </param>
    /// <param name="merge">
    /// If mergeBehavior is ComponentMerge.Merge and the component already exists, this expression is called to merge the components.
    /// </param>
    /// <param name="mergeBehavior">
    /// Handling if the component already exists since the component is unique. Defaults to ComponentMerge.Fail.
    /// </param>
    /// <param name="mythicBlueprint">
    /// <para>
    /// Blueprint of type BlueprintFeature. You can pass in the blueprint using:
    /// <list type ="bullet">
    ///   <item><term>A blueprint instance</term></item>
    ///   <item><term>A blueprint reference</term></item>
    ///   <item><term>A blueprint id as a string, Guid, or BlueprintGuid</term></item>
    ///   <item><term>A blueprint name registered with <see cref="BlueprintCore.Utils.BlueprintTool">BlueprintTool</see></term></item>
    /// </list>
    /// See <see cref="BlueprintCore.Utils.Blueprint{{T, TRef}}">Blueprint</see> for more details.
    /// </para>
    /// </param>
    /// <param name="weaponBlueprint">
    /// <para>
    /// Blueprint of type BlueprintItemWeapon. You can pass in the blueprint using:
    /// <list type ="bullet">
    ///   <item><term>A blueprint instance</term></item>
    ///   <item><term>A blueprint reference</term></item>
    ///   <item><term>A blueprint id as a string, Guid, or BlueprintGuid</term></item>
    ///   <item><term>A blueprint name registered with <see cref="BlueprintCore.Utils.BlueprintTool">BlueprintTool</see></term></item>
    /// </list>
    /// See <see cref="BlueprintCore.Utils.Blueprint{{T, TRef}}">Blueprint</see> for more details.
    /// </para>
    /// </param>
    public TBuilder AddWeaponParametersDamageBonus(
        bool? canBeUsedWithFightersFinesse = null,
        int? damageBonus = null,
        bool? dualWielding = null,
        Blueprint<BlueprintFeature, BlueprintFeatureReference>? fightersFinesse = null,
        Blueprint<BlueprintFeature, BlueprintFeatureReference>? greaterPowerAttackBlueprint = null,
        Action<BlueprintComponent, BlueprintComponent>? merge = null,
        ComponentMerge mergeBehavior = ComponentMerge.Merge,
        Blueprint<BlueprintFeature, BlueprintFeatureReference>? mythicBlueprint = null,
        bool? onlyFinessable = null,
        bool? onlySpecificItemBlueprint = null,
        bool? onlyToOffHandBonus = null,
        bool? onlyTwoHanded = null,
        bool? powerAttackScaling = null,
        bool? ranged = null,
        bool? scaleByBasicAttackBonus = null,
        Blueprint<BlueprintItemWeapon, BlueprintItemWeaponReference>? weaponBlueprint = null)
    {
      var component = new WeaponParametersDamageBonus();
      component.CanBeUsedWithFightersFinesse = canBeUsedWithFightersFinesse ?? component.CanBeUsedWithFightersFinesse;
      component.DamageBonus = damageBonus ?? component.DamageBonus;
      component.DualWielding = dualWielding ?? component.DualWielding;
      component.m_FightersFinesse = fightersFinesse?.Reference ?? component.m_FightersFinesse;
      if (component.m_FightersFinesse is null)
      {
        component.m_FightersFinesse = BlueprintTool.GetRef<BlueprintFeatureReference>(null);
      }
      component.m_GreaterPowerAttackBlueprint = greaterPowerAttackBlueprint?.Reference ?? component.m_GreaterPowerAttackBlueprint;
      if (component.m_GreaterPowerAttackBlueprint is null)
      {
        component.m_GreaterPowerAttackBlueprint = BlueprintTool.GetRef<BlueprintFeatureReference>(null);
      }
      component.m_MythicBlueprint = mythicBlueprint?.Reference ?? component.m_MythicBlueprint;
      if (component.m_MythicBlueprint is null)
      {
        component.m_MythicBlueprint = BlueprintTool.GetRef<BlueprintFeatureReference>(null);
      }
      component.OnlyFinessable = onlyFinessable ?? component.OnlyFinessable;
      component.OnlySpecificItemBlueprint = onlySpecificItemBlueprint ?? component.OnlySpecificItemBlueprint;
      component.OnlyToOffHandBonus = onlyToOffHandBonus ?? component.OnlyToOffHandBonus;
      component.OnlyTwoHanded = onlyTwoHanded ?? component.OnlyTwoHanded;
      component.PowerAttackScaling = powerAttackScaling ?? component.PowerAttackScaling;
      component.Ranged = ranged ?? component.Ranged;
      component.ScaleByBasicAttackBonus = scaleByBasicAttackBonus ?? component.ScaleByBasicAttackBonus;
      component.m_WeaponBlueprint = weaponBlueprint?.Reference ?? component.m_WeaponBlueprint;
      if (component.m_WeaponBlueprint is null)
      {
        component.m_WeaponBlueprint = BlueprintTool.GetRef<BlueprintItemWeaponReference>(null);
      }
      return AddUniqueComponent(component, mergeBehavior, merge);
    }

    /// <summary>
    /// Adds <see cref="WeaponSizeChange"/>
    /// </summary>
    ///
    /// <remarks>
    ///
    /// <para>
    /// ComponentName: Weapon size change
    /// </para>
    ///
    /// <list type="bullet">
    /// <listheader>Used by</listheader>
    /// <item><term>AshGiantOversizedWeaponFeature</term><description>c3c898a50b8ff1247817f2807385fb7a</description></item>
    /// <item><term>QuarterstaffMasterDamageBonus12</term><description>169a9c271ad74afb819fe3cb904fb8c7</description></item>
    /// <item><term>QuarterstaffMasterDamageBonus4</term><description>11ce78cdcbe6427a8a4dd9dd1e36c914</description></item>
    /// </list>
    /// </remarks>
    ///
    /// <param name="merge">
    /// If mergeBehavior is ComponentMerge.Merge and the component already exists, this expression is called to merge the components.
    /// </param>
    /// <param name="mergeBehavior">
    /// Handling if the component already exists since the component is unique. Defaults to ComponentMerge.Fail.
    /// </param>
    public TBuilder AddWeaponSizeChange(
        WeaponCategory? category = null,
        bool? checkWeaponCategory = null,
        Action<BlueprintComponent, BlueprintComponent>? merge = null,
        ComponentMerge mergeBehavior = ComponentMerge.Merge,
        int? sizeCategoryChange = null)
    {
      var component = new WeaponSizeChange();
      component.Category = category ?? component.Category;
      component.CheckWeaponCategory = checkWeaponCategory ?? component.CheckWeaponCategory;
      component.SizeCategoryChange = sizeCategoryChange ?? component.SizeCategoryChange;
      return AddUniqueComponent(component, mergeBehavior, merge);
    }

    /// <summary>
    /// Adds <see cref="WeaponTypeCriticalEdgeIncrease"/>
    /// </summary>
    ///
    /// <remarks>
    ///
    /// <para>
    /// ComponentName: Weapon type critical edge increase
    /// </para>
    ///
    /// <list type="bullet">
    /// <listheader>Used by</listheader>
    /// <item><term>AspectOfTheFalconBuff</term><description>5de9e71d013d1024eb14f4c5605b31dc</description></item>
    /// <item><term>ImprovedCriticalLightCrossbow</term><description>9fb9160d3e5b70d41be3c620a4db72aa</description></item>
    /// <item><term>RiftDrakeSavageBiteFeature</term><description>2ad28cd3874b4db4e82fb41b32d59d51</description></item>
    /// </list>
    /// </remarks>
    ///
    /// <param name="merge">
    /// If mergeBehavior is ComponentMerge.Merge and the component already exists, this expression is called to merge the components.
    /// </param>
    /// <param name="mergeBehavior">
    /// Handling if the component already exists since the component is unique. Defaults to ComponentMerge.Fail.
    /// </param>
    /// <param name="weaponType">
    /// <para>
    /// Blueprint of type BlueprintWeaponType. You can pass in the blueprint using:
    /// <list type ="bullet">
    ///   <item><term>A blueprint instance</term></item>
    ///   <item><term>A blueprint reference</term></item>
    ///   <item><term>A blueprint id as a string, Guid, or BlueprintGuid</term></item>
    ///   <item><term>A blueprint name registered with <see cref="BlueprintCore.Utils.BlueprintTool">BlueprintTool</see></term></item>
    /// </list>
    /// See <see cref="BlueprintCore.Utils.Blueprint{{T, TRef}}">Blueprint</see> for more details.
    /// </para>
    /// </param>
    public TBuilder AddWeaponTypeCriticalEdgeIncrease(
        Action<BlueprintComponent, BlueprintComponent>? merge = null,
        ComponentMerge mergeBehavior = ComponentMerge.Merge,
        Blueprint<BlueprintWeaponType, BlueprintWeaponTypeReference>? weaponType = null)
    {
      var component = new WeaponTypeCriticalEdgeIncrease();
      component.m_WeaponType = weaponType?.Reference ?? component.m_WeaponType;
      if (component.m_WeaponType is null)
      {
        component.m_WeaponType = BlueprintTool.GetRef<BlueprintWeaponTypeReference>(null);
      }
      return AddUniqueComponent(component, mergeBehavior, merge);
    }

    /// <summary>
    /// Adds <see cref="WeaponTypeCriticalEdgeIncreaseStackable"/>
    /// </summary>
    ///
    /// <remarks>
    ///
    /// <para>
    /// ComponentName: Weapon type critical edge increase
    /// </para>
    ///
    /// <list type="bullet">
    /// <listheader>Used by</listheader>
    /// <item><term>AnimatedWeaponEnchantmentBuff</term><description>e5a6a91529eedc147a5ad18200ffc16c</description></item>
    /// <item><term>ImminentAttackAnimalFeature</term><description>edec194f8186e2b449afe99f38552fc3</description></item>
    /// <item><term>SigilOfDestructionRingFeature</term><description>5585e517927516442946d472c9cd6591</description></item>
    /// </list>
    /// </remarks>
    ///
    /// <param name="merge">
    /// If mergeBehavior is ComponentMerge.Merge and the component already exists, this expression is called to merge the components.
    /// </param>
    /// <param name="mergeBehavior">
    /// Handling if the component already exists since the component is unique. Defaults to ComponentMerge.Fail.
    /// </param>
    public TBuilder AddWeaponTypeCriticalEdgeIncreaseStackable(
        bool? anyCategory = null,
        WeaponCategory? category = null,
        Action<BlueprintComponent, BlueprintComponent>? merge = null,
        ComponentMerge mergeBehavior = ComponentMerge.Merge)
    {
      var component = new WeaponTypeCriticalEdgeIncreaseStackable();
      component.AnyCategory = anyCategory ?? component.AnyCategory;
      component.Category = category ?? component.Category;
      return AddUniqueComponent(component, mergeBehavior, merge);
    }

    /// <summary>
    /// Adds <see cref="WeaponTypeCriticalMultiplierIncrease"/>
    /// </summary>
    ///
    /// <remarks>
    ///
    /// <para>
    /// ComponentName: Weapon type critical multiplier increase
    /// </para>
    ///
    /// <list type="bullet">
    /// <listheader>Used by</listheader>
    /// <item><term>Abadar_Buff</term><description>70b34e1de03641b4a5a35b5fda6f0642</description></item>
    /// <item><term>AspectOfTheFalconBuff</term><description>5de9e71d013d1024eb14f4c5605b31dc</description></item>
    /// </list>
    /// </remarks>
    ///
    /// <param name="merge">
    /// If mergeBehavior is ComponentMerge.Merge and the component already exists, this expression is called to merge the components.
    /// </param>
    /// <param name="mergeBehavior">
    /// Handling if the component already exists since the component is unique. Defaults to ComponentMerge.Fail.
    /// </param>
    /// <param name="weaponType">
    /// <para>
    /// Blueprint of type BlueprintWeaponType. You can pass in the blueprint using:
    /// <list type ="bullet">
    ///   <item><term>A blueprint instance</term></item>
    ///   <item><term>A blueprint reference</term></item>
    ///   <item><term>A blueprint id as a string, Guid, or BlueprintGuid</term></item>
    ///   <item><term>A blueprint name registered with <see cref="BlueprintCore.Utils.BlueprintTool">BlueprintTool</see></term></item>
    /// </list>
    /// See <see cref="BlueprintCore.Utils.Blueprint{{T, TRef}}">Blueprint</see> for more details.
    /// </para>
    /// </param>
    public TBuilder AddWeaponTypeCriticalMultiplierIncrease(
        int? additionalMultiplier = null,
        Action<BlueprintComponent, BlueprintComponent>? merge = null,
        ComponentMerge mergeBehavior = ComponentMerge.Merge,
        Blueprint<BlueprintWeaponType, BlueprintWeaponTypeReference>? weaponType = null)
    {
      var component = new WeaponTypeCriticalMultiplierIncrease();
      component.AdditionalMultiplier = additionalMultiplier ?? component.AdditionalMultiplier;
      component.m_WeaponType = weaponType?.Reference ?? component.m_WeaponType;
      if (component.m_WeaponType is null)
      {
        component.m_WeaponType = BlueprintTool.GetRef<BlueprintWeaponTypeReference>(null);
      }
      return AddUniqueComponent(component, mergeBehavior, merge);
    }

    /// <summary>
    /// Adds <see cref="WeaponTypeDamageBonus"/>
    /// </summary>
    ///
    /// <remarks>
    ///
    /// <para>
    /// ComponentName: Weapon type damage bonus
    /// </para>
    ///
    /// <list type="bullet">
    /// <listheader>Used by</listheader>
    /// <item><term>BackgroundAlkenstarAlchemist</term><description>f51af2d4fa3358844879cbc5ee0f1073</description></item>
    /// <item><term>WeaponSpecializationGreaterScimitar</term><description>890c468f9fba6ca4dbcb86a5d0cf4c86</description></item>
    /// <item><term>WeaponSpecializationUnarmed</term><description>74028e94b236a9c4ca9ba67e57299547</description></item>
    /// </list>
    /// </remarks>
    ///
    /// <param name="merge">
    /// If mergeBehavior is ComponentMerge.Merge and the component already exists, this expression is called to merge the components.
    /// </param>
    /// <param name="mergeBehavior">
    /// Handling if the component already exists since the component is unique. Defaults to ComponentMerge.Fail.
    /// </param>
    /// <param name="weaponType">
    /// <para>
    /// Blueprint of type BlueprintWeaponType. You can pass in the blueprint using:
    /// <list type ="bullet">
    ///   <item><term>A blueprint instance</term></item>
    ///   <item><term>A blueprint reference</term></item>
    ///   <item><term>A blueprint id as a string, Guid, or BlueprintGuid</term></item>
    ///   <item><term>A blueprint name registered with <see cref="BlueprintCore.Utils.BlueprintTool">BlueprintTool</see></term></item>
    /// </list>
    /// See <see cref="BlueprintCore.Utils.Blueprint{{T, TRef}}">Blueprint</see> for more details.
    /// </para>
    /// </param>
    public TBuilder AddWeaponTypeDamageBonus(
        int? damageBonus = null,
        Action<BlueprintComponent, BlueprintComponent>? merge = null,
        ComponentMerge mergeBehavior = ComponentMerge.Merge,
        Blueprint<BlueprintWeaponType, BlueprintWeaponTypeReference>? weaponType = null)
    {
      var component = new WeaponTypeDamageBonus();
      component.DamageBonus = damageBonus ?? component.DamageBonus;
      component.m_WeaponType = weaponType?.Reference ?? component.m_WeaponType;
      if (component.m_WeaponType is null)
      {
        component.m_WeaponType = BlueprintTool.GetRef<BlueprintWeaponTypeReference>(null);
      }
      return AddUniqueComponent(component, mergeBehavior, merge);
    }

    /// <summary>
    /// Adds <see cref="WeaponTypeDamageStatReplacement"/>
    /// </summary>
    ///
    /// <remarks>
    ///
    /// <para>
    /// ComponentName: Replace damage stat for weapon
    /// </para>
    ///
    /// <list type="bullet">
    /// <listheader>Used by</listheader>
    /// <item><term>AnimalCompanionUpgradeLeopard</term><description>b8c98af302ee334499d30a926306327d</description></item>
    /// <item><term>FinesseTrainingKukri</term><description>80bca19f64a359146ba8e26ebf615190</description></item>
    /// <item><term>FinesseTrainingUnarmed</term><description>641dc4bbfb8c13b43a879ba9a2e196b3</description></item>
    /// </list>
    /// </remarks>
    ///
    /// <param name="merge">
    /// If mergeBehavior is ComponentMerge.Merge and the component already exists, this expression is called to merge the components.
    /// </param>
    /// <param name="mergeBehavior">
    /// Handling if the component already exists since the component is unique. Defaults to ComponentMerge.Fail.
    /// </param>
    public TBuilder AddWeaponTypeDamageStatReplacement(
        WeaponCategory? category = null,
        Action<BlueprintComponent, BlueprintComponent>? merge = null,
        ComponentMerge mergeBehavior = ComponentMerge.Merge,
        bool? onlyOneHanded = null,
        StatType? stat = null,
        bool? twoHandedBonus = null)
    {
      var component = new WeaponTypeDamageStatReplacement();
      component.Category = category ?? component.Category;
      component.OnlyOneHanded = onlyOneHanded ?? component.OnlyOneHanded;
      component.Stat = stat ?? component.Stat;
      component.TwoHandedBonus = twoHandedBonus ?? component.TwoHandedBonus;
      return AddUniqueComponent(component, mergeBehavior, merge);
    }

    /// <summary>
    /// Adds <see cref="ImpatienceCalmingPart"/>
    /// </summary>
    ///
    /// <remarks>
    ///
    /// <list type="bullet">
    /// <listheader>Used by</listheader>
    /// <item><term>ImpatienceTickingBuff</term><description>46b39651560c13f41a1f5deebb9caa1a</description></item>
    /// </list>
    /// </remarks>
    ///
    /// <param name="impatience">
    /// <para>
    /// Blueprint of type BlueprintBuff. You can pass in the blueprint using:
    /// <list type ="bullet">
    ///   <item><term>A blueprint instance</term></item>
    ///   <item><term>A blueprint reference</term></item>
    ///   <item><term>A blueprint id as a string, Guid, or BlueprintGuid</term></item>
    ///   <item><term>A blueprint name registered with <see cref="BlueprintCore.Utils.BlueprintTool">BlueprintTool</see></term></item>
    /// </list>
    /// See <see cref="BlueprintCore.Utils.Blueprint{{T, TRef}}">Blueprint</see> for more details.
    /// </para>
    /// </param>
    /// <param name="merge">
    /// If mergeBehavior is ComponentMerge.Merge and the component already exists, this expression is called to merge the components.
    /// </param>
    /// <param name="mergeBehavior">
    /// Handling if the component already exists since the component is unique. Defaults to ComponentMerge.Fail.
    /// </param>
    /// <param name="patience">
    /// <para>
    /// Blueprint of type BlueprintBuff. You can pass in the blueprint using:
    /// <list type ="bullet">
    ///   <item><term>A blueprint instance</term></item>
    ///   <item><term>A blueprint reference</term></item>
    ///   <item><term>A blueprint id as a string, Guid, or BlueprintGuid</term></item>
    ///   <item><term>A blueprint name registered with <see cref="BlueprintCore.Utils.BlueprintTool">BlueprintTool</see></term></item>
    /// </list>
    /// See <see cref="BlueprintCore.Utils.Blueprint{{T, TRef}}">Blueprint</see> for more details.
    /// </para>
    /// </param>
    /// <param name="targetedImpatience">
    /// <para>
    /// Blueprint of type BlueprintBuff. You can pass in the blueprint using:
    /// <list type ="bullet">
    ///   <item><term>A blueprint instance</term></item>
    ///   <item><term>A blueprint reference</term></item>
    ///   <item><term>A blueprint id as a string, Guid, or BlueprintGuid</term></item>
    ///   <item><term>A blueprint name registered with <see cref="BlueprintCore.Utils.BlueprintTool">BlueprintTool</see></term></item>
    /// </list>
    /// See <see cref="BlueprintCore.Utils.Blueprint{{T, TRef}}">Blueprint</see> for more details.
    /// </para>
    /// </param>
    public TBuilder AddImpatienceCalmingPart(
        Blueprint<BlueprintBuff, BlueprintBuffReference>? impatience = null,
        Action<BlueprintComponent, BlueprintComponent>? merge = null,
        ComponentMerge mergeBehavior = ComponentMerge.Merge,
        Blueprint<BlueprintBuff, BlueprintBuffReference>? patience = null,
        Blueprint<BlueprintBuff, BlueprintBuffReference>? targetedImpatience = null)
    {
      var component = new ImpatienceCalmingPart();
      component.m_Impatience = impatience?.Reference ?? component.m_Impatience;
      if (component.m_Impatience is null)
      {
        component.m_Impatience = BlueprintTool.GetRef<BlueprintBuffReference>(null);
      }
      component.m_Patience = patience?.Reference ?? component.m_Patience;
      if (component.m_Patience is null)
      {
        component.m_Patience = BlueprintTool.GetRef<BlueprintBuffReference>(null);
      }
      component.m_TargetedImpatience = targetedImpatience?.Reference ?? component.m_TargetedImpatience;
      if (component.m_TargetedImpatience is null)
      {
        component.m_TargetedImpatience = BlueprintTool.GetRef<BlueprintBuffReference>(null);
      }
      return AddUniqueComponent(component, mergeBehavior, merge);
    }

    /// <summary>
    /// Adds <see cref="ImpatienceWatcherTickingResolve"/>
    /// </summary>
    ///
    /// <remarks>
    ///
    /// <list type="bullet">
    /// <listheader>Used by</listheader>
    /// <item><term>ImpatienceTickingBuff</term><description>46b39651560c13f41a1f5deebb9caa1a</description></item>
    /// </list>
    /// </remarks>
    ///
    /// <param name="impatience">
    /// <para>
    /// Blueprint of type BlueprintBuff. You can pass in the blueprint using:
    /// <list type ="bullet">
    ///   <item><term>A blueprint instance</term></item>
    ///   <item><term>A blueprint reference</term></item>
    ///   <item><term>A blueprint id as a string, Guid, or BlueprintGuid</term></item>
    ///   <item><term>A blueprint name registered with <see cref="BlueprintCore.Utils.BlueprintTool">BlueprintTool</see></term></item>
    /// </list>
    /// See <see cref="BlueprintCore.Utils.Blueprint{{T, TRef}}">Blueprint</see> for more details.
    /// </para>
    /// </param>
    /// <param name="merge">
    /// If mergeBehavior is ComponentMerge.Merge and the component already exists, this expression is called to merge the components.
    /// </param>
    /// <param name="mergeBehavior">
    /// Handling if the component already exists since the component is unique. Defaults to ComponentMerge.Fail.
    /// </param>
    /// <param name="patience">
    /// <para>
    /// Blueprint of type BlueprintBuff. You can pass in the blueprint using:
    /// <list type ="bullet">
    ///   <item><term>A blueprint instance</term></item>
    ///   <item><term>A blueprint reference</term></item>
    ///   <item><term>A blueprint id as a string, Guid, or BlueprintGuid</term></item>
    ///   <item><term>A blueprint name registered with <see cref="BlueprintCore.Utils.BlueprintTool">BlueprintTool</see></term></item>
    /// </list>
    /// See <see cref="BlueprintCore.Utils.Blueprint{{T, TRef}}">Blueprint</see> for more details.
    /// </para>
    /// </param>
    /// <param name="targetedImpatience">
    /// <para>
    /// Blueprint of type BlueprintBuff. You can pass in the blueprint using:
    /// <list type ="bullet">
    ///   <item><term>A blueprint instance</term></item>
    ///   <item><term>A blueprint reference</term></item>
    ///   <item><term>A blueprint id as a string, Guid, or BlueprintGuid</term></item>
    ///   <item><term>A blueprint name registered with <see cref="BlueprintCore.Utils.BlueprintTool">BlueprintTool</see></term></item>
    /// </list>
    /// See <see cref="BlueprintCore.Utils.Blueprint{{T, TRef}}">Blueprint</see> for more details.
    /// </para>
    /// </param>
    public TBuilder AddImpatienceWatcherTickingResolve(
        Blueprint<BlueprintBuff, BlueprintBuffReference>? impatience = null,
        Action<BlueprintComponent, BlueprintComponent>? merge = null,
        ComponentMerge mergeBehavior = ComponentMerge.Merge,
        Blueprint<BlueprintBuff, BlueprintBuffReference>? patience = null,
        int[]? resolveChances = null,
        int[]? resolveChancesForHighInt = null,
        int[]? resolveChancesForLowInt = null,
        Blueprint<BlueprintBuff, BlueprintBuffReference>? targetedImpatience = null)
    {
      var component = new ImpatienceWatcherTickingResolve();
      component.m_Impatience = impatience?.Reference ?? component.m_Impatience;
      if (component.m_Impatience is null)
      {
        component.m_Impatience = BlueprintTool.GetRef<BlueprintBuffReference>(null);
      }
      component.m_Patience = patience?.Reference ?? component.m_Patience;
      if (component.m_Patience is null)
      {
        component.m_Patience = BlueprintTool.GetRef<BlueprintBuffReference>(null);
      }
      component.ResolveChances = resolveChances ?? component.ResolveChances;
      if (component.ResolveChances is null)
      {
        component.ResolveChances = new int[0];
      }
      component.ResolveChancesForHighInt = resolveChancesForHighInt ?? component.ResolveChancesForHighInt;
      if (component.ResolveChancesForHighInt is null)
      {
        component.ResolveChancesForHighInt = new int[0];
      }
      component.ResolveChancesForLowInt = resolveChancesForLowInt ?? component.ResolveChancesForLowInt;
      if (component.ResolveChancesForLowInt is null)
      {
        component.ResolveChancesForLowInt = new int[0];
      }
      component.m_TargetedImpatience = targetedImpatience?.Reference ?? component.m_TargetedImpatience;
      if (component.m_TargetedImpatience is null)
      {
        component.m_TargetedImpatience = BlueprintTool.GetRef<BlueprintBuffReference>(null);
      }
      return AddUniqueComponent(component, mergeBehavior, merge);
    }

    /// <summary>
    /// Adds <see cref="Afterbuff"/>
    /// </summary>
    ///
    /// <remarks>
    ///
    /// <para>
    /// ComponentName: BuffMechanics/Energy Damage Each Round
    /// </para>
    ///
    /// <list type="bullet">
    /// <listheader>Used by</listheader>
    /// <item><term>DefensiveStanceBuff</term><description>3dccdf27a8209af478ac71cded18a271</description></item>
    /// <item><term>ScintillatingPatternBuffILiving</term><description>1d54aef47f9843d4691fddd1f04ee4c8</description></item>
    /// <item><term>ScintillatingPatternBuffINonliving</term><description>7c9ae927f2532a44d93492d126c6d6b2</description></item>
    /// </list>
    /// </remarks>
    ///
    /// <param name="afterBuff">
    /// <para>
    /// Blueprint of type BlueprintBuff. You can pass in the blueprint using:
    /// <list type ="bullet">
    ///   <item><term>A blueprint instance</term></item>
    ///   <item><term>A blueprint reference</term></item>
    ///   <item><term>A blueprint id as a string, Guid, or BlueprintGuid</term></item>
    ///   <item><term>A blueprint name registered with <see cref="BlueprintCore.Utils.BlueprintTool">BlueprintTool</see></term></item>
    /// </list>
    /// See <see cref="BlueprintCore.Utils.Blueprint{{T, TRef}}">Blueprint</see> for more details.
    /// </para>
    /// </param>
    /// <param name="merge">
    /// If mergeBehavior is ComponentMerge.Merge and the component already exists, this expression is called to merge the components.
    /// </param>
    /// <param name="mergeBehavior">
    /// Handling if the component already exists since the component is unique. Defaults to ComponentMerge.Fail.
    /// </param>
    public TBuilder AddAfterbuff(
        Blueprint<BlueprintBuff, BlueprintBuffReference>? afterBuff = null,
        int? durationMultiplier = null,
        Action<BlueprintComponent, BlueprintComponent>? merge = null,
        ComponentMerge mergeBehavior = ComponentMerge.Merge)
    {
      var component = new Afterbuff();
      component.m_AfterBuff = afterBuff?.Reference ?? component.m_AfterBuff;
      if (component.m_AfterBuff is null)
      {
        component.m_AfterBuff = BlueprintTool.GetRef<BlueprintBuffReference>(null);
      }
      component.DurationMultiplier = durationMultiplier ?? component.DurationMultiplier;
      return AddUniqueComponent(component, mergeBehavior, merge);
    }

    /// <summary>
    /// Adds <see cref="ArmagsBladeEnrage"/>
    /// </summary>
    ///
    /// <remarks>
    ///
    /// <list type="bullet">
    /// <listheader>Used by</listheader>
    /// <item><term>ArmagsBladeBuff</term><description>38804797dd02b2f4c818c6eba0b00b5d</description></item>
    /// </list>
    /// </remarks>
    public TBuilder AddArmagsBladeEnrage()
    {
      return AddComponent(new ArmagsBladeEnrage());
    }

    /// <summary>
    /// Adds <see cref="ArmorFocus"/>
    /// </summary>
    ///
    /// <remarks>
    ///
    /// <para>
    /// ComponentName: Add AC if owner has specific armor
    /// </para>
    ///
    /// <list type="bullet">
    /// <listheader>Used by</listheader>
    /// <item><term>ArmorFocusBanded</term><description>57c6a8b9ca2f3b1489e9defe8b121055</description></item>
    /// <item><term>ArmorFocusHide</term><description>e31e66c4670152945969e719112709d8</description></item>
    /// <item><term>ArmorFocusStudded</term><description>57770bba6c22f1e42b396f2bcb1c420a</description></item>
    /// </list>
    /// </remarks>
    ///
    /// <param name="merge">
    /// If mergeBehavior is ComponentMerge.Merge and the component already exists, this expression is called to merge the components.
    /// </param>
    /// <param name="mergeBehavior">
    /// Handling if the component already exists since the component is unique. Defaults to ComponentMerge.Fail.
    /// </param>
    public TBuilder AddArmorFocus(
        ArmorProficiencyGroup? armorCategory = null,
        Action<BlueprintComponent, BlueprintComponent>? merge = null,
        ComponentMerge mergeBehavior = ComponentMerge.Merge)
    {
      var component = new ArmorFocus();
      component.ArmorCategory = armorCategory ?? component.ArmorCategory;
      return AddUniqueComponent(component, mergeBehavior, merge);
    }

    /// <summary>
    /// Adds <see cref="BuffAbilityRollsBonus"/>
    /// </summary>
    ///
    /// <remarks>
    ///
    /// <para>
    /// ComponentName: BuffMechanics/Ability Roll Bonus
    /// </para>
    ///
    /// <list type="bullet">
    /// <listheader>Used by</listheader>
    /// <item><term>ArchaeologistLuckBuff</term><description>2ef43eabd1d15fe4399e45806e9ca2d0</description></item>
    /// <item><term>Gyronna_Debuff</term><description>869757bd60714683bafd73c1e4dcd6cb</description></item>
    /// <item><term>TemporaryNegativeLevel</term><description>df95c24fa8c51eb49b2595cf532d40ad</description></item>
    /// </list>
    /// </remarks>
    public TBuilder AddBuffAbilityRollsBonus(
        bool? affectAllStats = null,
        ModifierDescriptor? descriptor = null,
        ContextValue? multiplier = null,
        bool? onlyHighesStats = null,
        StatType? stat = null,
        int? value = null)
    {
      var component = new BuffAbilityRollsBonus();
      component.AffectAllStats = affectAllStats ?? component.AffectAllStats;
      component.Descriptor = descriptor ?? component.Descriptor;
      component.Multiplier = multiplier ?? component.Multiplier;
      if (component.Multiplier is null)
      {
        component.Multiplier = ContextValues.Constant(0);
      }
      component.OnlyHighesStats = onlyHighesStats ?? component.OnlyHighesStats;
      component.Stat = stat ?? component.Stat;
      component.Value = value ?? component.Value;
      return AddComponent(component);
    }

    /// <summary>
    /// Adds <see cref="BuffAllSavesBonus"/>
    /// </summary>
    ///
    /// <remarks>
    ///
    /// <para>
    /// ComponentName: BuffMechanics/Bonus to all saves
    /// </para>
    ///
    /// <list type="bullet">
    /// <listheader>Used by</listheader>
    /// <item><term>AngelHaloArchonsAuraHolyAuraBuff</term><description>64b2791ee5b11194e82eb6f474244d19</description></item>
    /// <item><term>HermitKnightBracersShakenBuff</term><description>f9a1497640775e74f9b57758cf83fe09</description></item>
    /// <item><term>ZeorisDaggerRing_BetrayalEffectBuff</term><description>252279901e3644ce8b5b3275bea8f7bd</description></item>
    /// </list>
    /// </remarks>
    ///
    /// <param name="merge">
    /// If mergeBehavior is ComponentMerge.Merge and the component already exists, this expression is called to merge the components.
    /// </param>
    /// <param name="mergeBehavior">
    /// Handling if the component already exists since the component is unique. Defaults to ComponentMerge.Fail.
    /// </param>
    public TBuilder AddBuffAllSavesBonus(
        ModifierDescriptor? descriptor = null,
        Action<BlueprintComponent, BlueprintComponent>? merge = null,
        ComponentMerge mergeBehavior = ComponentMerge.Merge,
        int? value = null)
    {
      var component = new BuffAllSavesBonus();
      component.Descriptor = descriptor ?? component.Descriptor;
      component.Value = value ?? component.Value;
      return AddUniqueComponent(component, mergeBehavior, merge);
    }

    /// <summary>
    /// Adds <see cref="BuffAllSkillsBonus"/>
    /// </summary>
    ///
    /// <remarks>
    ///
    /// <para>
    /// ComponentName: BuffMechanics/Bonus to all skills
    /// </para>
    ///
    /// <list type="bullet">
    /// <listheader>Used by</listheader>
    /// <item><term>AllSkilledFeature</term><description>f3bc6f9c855b2fb4e9aea364b8163aca</description></item>
    /// <item><term>IncenseFogSickenedBuff</term><description>e905c55936cb67a48b8adf36e0d71de9</description></item>
    /// <item><term>TricksterResistances</term><description>4cd530e060eccbc4b99f232abbf9c3f1</description></item>
    /// </list>
    /// </remarks>
    ///
    /// <param name="merge">
    /// If mergeBehavior is ComponentMerge.Merge and the component already exists, this expression is called to merge the components.
    /// </param>
    /// <param name="mergeBehavior">
    /// Handling if the component already exists since the component is unique. Defaults to ComponentMerge.Fail.
    /// </param>
    public TBuilder AddBuffAllSkillsBonus(
        ModifierDescriptor? descriptor = null,
        Action<BlueprintComponent, BlueprintComponent>? merge = null,
        ComponentMerge mergeBehavior = ComponentMerge.Merge,
        ContextValue? multiplier = null,
        int? value = null)
    {
      var component = new BuffAllSkillsBonus();
      component.Descriptor = descriptor ?? component.Descriptor;
      component.Multiplier = multiplier ?? component.Multiplier;
      if (component.Multiplier is null)
      {
        component.Multiplier = ContextValues.Constant(0);
      }
      component.Value = value ?? component.Value;
      return AddUniqueComponent(component, mergeBehavior, merge);
    }

    /// <summary>
    /// Adds <see cref="BuffAllSkillsBonusAbilityValue"/>
    /// </summary>
    ///
    /// <remarks>
    ///
    /// <para>
    /// ComponentName: BuffMechanics/Bonus to all skills equal to ability value
    /// </para>
    ///
    /// <list type="bullet">
    /// <listheader>Used by</listheader>
    /// <item><term>CavalierMomentOfTriumphBuff</term><description>acf63c4575b5ae94d8341555526793ae</description></item>
    /// <item><term>LinziCampBuff</term><description>27cbf5f6ec970a74d9f13ade58456aca</description></item>
    /// <item><term>MadnessDomainBaseSkillChecksBuff</term><description>3e42877e5e481894880df63ad924e320</description></item>
    /// </list>
    /// </remarks>
    ///
    /// <param name="merge">
    /// If mergeBehavior is ComponentMerge.Merge and the component already exists, this expression is called to merge the components.
    /// </param>
    /// <param name="mergeBehavior">
    /// Handling if the component already exists since the component is unique. Defaults to ComponentMerge.Fail.
    /// </param>
    public TBuilder AddBuffAllSkillsBonusAbilityValue(
        ModifierDescriptor? descriptor = null,
        Action<BlueprintComponent, BlueprintComponent>? merge = null,
        ComponentMerge mergeBehavior = ComponentMerge.Merge,
        ContextValue? value = null)
    {
      var component = new BuffAllSkillsBonusAbilityValue();
      component.Descriptor = descriptor ?? component.Descriptor;
      component.Value = value ?? component.Value;
      if (component.Value is null)
      {
        component.Value = ContextValues.Constant(0);
      }
      return AddUniqueComponent(component, mergeBehavior, merge);
    }

    /// <summary>
    /// Adds <see cref="BuffAllSkillsBonusRankDependent"/>
    /// </summary>
    ///
    /// <remarks>
    ///
    /// <para>
    /// ComponentName: BuffMechanics/Bonus to all skills depending on its rank
    /// </para>
    ///
    /// <list type="bullet">
    /// <listheader>Used by</listheader>
    /// <item><term>OnionSoupBuffCompanion</term><description>4230a65e99cd5c640a1be10fe3f5f657</description></item>
    /// </list>
    /// </remarks>
    ///
    /// <param name="merge">
    /// If mergeBehavior is ComponentMerge.Merge and the component already exists, this expression is called to merge the components.
    /// </param>
    /// <param name="mergeBehavior">
    /// Handling if the component already exists since the component is unique. Defaults to ComponentMerge.Fail.
    /// </param>
    public TBuilder AddBuffAllSkillsBonusRankDependent(
        ModifierDescriptor? descriptor = null,
        Action<BlueprintComponent, BlueprintComponent>? merge = null,
        ComponentMerge mergeBehavior = ComponentMerge.Merge,
        int? minimalRank = null,
        int? value = null)
    {
      var component = new BuffAllSkillsBonusRankDependent();
      component.Descriptor = descriptor ?? component.Descriptor;
      component.MinimalRank = minimalRank ?? component.MinimalRank;
      component.Value = value ?? component.Value;
      return AddUniqueComponent(component, mergeBehavior, merge);
    }

    /// <summary>
    /// Adds <see cref="BuffDamageEachRound"/>
    /// </summary>
    ///
    /// <remarks>
    ///
    /// <para>
    /// ComponentName: BuffMechanics/Saving throw each round
    /// </para>
    ///
    /// <list type="bullet">
    /// <listheader>Used by</listheader>
    /// <item><term>AuthorityHeavyMaceBuff</term><description>b3b8fb97d9282a04aa44012bbf0e4b24</description></item>
    /// <item><term>NaturesAgonyBuff</term><description>d89b2c0a2a81e2f47a70ad90609e1d10</description></item>
    /// <item><term>VenomPoisonSecondBuff</term><description>dccf1f1c6a7ecfc45be3628afb5d28ed</description></item>
    /// </list>
    /// </remarks>
    ///
    /// <param name="merge">
    /// If mergeBehavior is ComponentMerge.Merge and the component already exists, this expression is called to merge the components.
    /// </param>
    /// <param name="mergeBehavior">
    /// Handling if the component already exists since the component is unique. Defaults to ComponentMerge.Fail.
    /// </param>
    public TBuilder AddBuffDamageEachRound(
        float? additionalRoundsPerCasterLevel = null,
        int? baseRounds = null,
        DamageEnergyType? element = null,
        DiceFormula? energyDamageDice = null,
        Action<BlueprintComponent, BlueprintComponent>? merge = null,
        ComponentMerge mergeBehavior = ComponentMerge.Merge)
    {
      var component = new BuffDamageEachRound();
      component.AdditionalRoundsPerCasterLevel = additionalRoundsPerCasterLevel ?? component.AdditionalRoundsPerCasterLevel;
      component.baseRounds = baseRounds ?? component.baseRounds;
      component.Element = element ?? component.Element;
      component.EnergyDamageDice = energyDamageDice ?? component.EnergyDamageDice;
      return AddUniqueComponent(component, mergeBehavior, merge);
    }

    /// <summary>
    /// Adds <see cref="BuffExtraAttack"/>
    /// </summary>
    ///
    /// <remarks>
    ///
    /// <para>
    /// ComponentName: BuffMechanics/Extra Attack
    /// </para>
    ///
    /// <list type="bullet">
    /// <listheader>Used by</listheader>
    /// <item><term>Abadar_Buff</term><description>70b34e1de03641b4a5a35b5fda6f0642</description></item>
    /// <item><term>HammerOfMasterpiece1Buff</term><description>d74b23b9bd6d4294e80cf529d379f7e1</description></item>
    /// <item><term>TherukNulDivinePowerPrebuff</term><description>8d1f792a8ab0a174e9a7d0541fb52900</description></item>
    /// </list>
    /// </remarks>
    public TBuilder AddBuffExtraAttack(
        bool? haste = null,
        int? number = null)
    {
      var component = new BuffExtraAttack();
      component.Haste = haste ?? component.Haste;
      component.Number = number ?? component.Number;
      return AddComponent(component);
    }

    /// <summary>
    /// Adds <see cref="BuffExtraAttackWeaponSpecific"/>
    /// </summary>
    ///
    /// <remarks>
    ///
    /// <list type="bullet">
    /// <listheader>Used by</listheader>
    /// <item><term>RapidShotBuff</term><description>0f310c1e709e15e4fa693db15a4baeb4</description></item>
    /// </list>
    /// </remarks>
    public TBuilder AddBuffExtraAttackWeaponSpecific(
        WeaponRangeType? rangeType = null)
    {
      var component = new BuffExtraAttackWeaponSpecific();
      component.RangeType = rangeType ?? component.RangeType;
      return AddComponent(component);
    }

    /// <summary>
    /// Adds <see cref="BuffIncomingDamageIncrease"/>
    /// </summary>
    ///
    /// <remarks>
    ///
    /// <para>
    /// ComponentName: BuffMechanics/Increase incoming damage
    /// </para>
    ///
    /// <list type="bullet">
    /// <listheader>Used by</listheader>
    /// <item><term>ArmyBlurFeature</term><description>8d48b761e7a3451e89d4fcef304105da</description></item>
    /// <item><term>ArmyUnitsProtectiveTalismans</term><description>9543e0f084f147608bb43b05b65b9c88</description></item>
    /// <item><term>DestructionDomainGreaterEffect</term><description>f9de414e53a9c23419fa3cfc0daabde7</description></item>
    /// </list>
    /// </remarks>
    public TBuilder AddBuffIncomingDamageIncrease(
        ContextValue? value = null)
    {
      var component = new BuffIncomingDamageIncrease();
      component.Value = value ?? component.Value;
      if (component.Value is null)
      {
        component.Value = ContextValues.Constant(0);
      }
      return AddComponent(component);
    }

    /// <summary>
    /// Adds <see cref="BuffMovementSpeed"/>
    /// </summary>
    ///
    /// <remarks>
    ///
    /// <para>
    /// ComponentName: BuffMechanics/Speed modifier
    /// </para>
    ///
    /// <list type="bullet">
    /// <listheader>Used by</listheader>
    /// <item><term>Abadar_Buff</term><description>70b34e1de03641b4a5a35b5fda6f0642</description></item>
    /// <item><term>FormOfTheDragonIWhiteBuff</term><description>a6acd3ad1e9fa6c45998d43fd5dcd86d</description></item>
    /// <item><term>WrathOfTheCreatorItemFeature</term><description>5600fc815bc0404e98b6f0bc4ce9665d</description></item>
    /// </list>
    /// </remarks>
    ///
    /// <param name="cappedMinimum">
    /// <para>
    /// InfoBox: Doesn't actually cap bonus. It changes bonus to zero if value + bonus is less than 0. Min speed is always = 5, so use this flag carefully
    /// </para>
    /// </param>
    /// <param name="merge">
    /// If mergeBehavior is ComponentMerge.Merge and the component already exists, this expression is called to merge the components.
    /// </param>
    /// <param name="mergeBehavior">
    /// Handling if the component already exists since the component is unique. Defaults to ComponentMerge.Fail.
    /// </param>
    public TBuilder AddBuffMovementSpeed(
        bool? cappedMinimum = null,
        bool? cappedOnMultiplier = null,
        ContextValue? contextBonus = null,
        ModifierDescriptor? descriptor = null,
        Action<BlueprintComponent, BlueprintComponent>? merge = null,
        ComponentMerge mergeBehavior = ComponentMerge.Merge,
        int? minimumCap = null,
        float? multiplierCap = null,
        int? value = null)
    {
      var component = new BuffMovementSpeed();
      component.CappedMinimum = cappedMinimum ?? component.CappedMinimum;
      component.CappedOnMultiplier = cappedOnMultiplier ?? component.CappedOnMultiplier;
      component.ContextBonus = contextBonus ?? component.ContextBonus;
      if (component.ContextBonus is null)
      {
        component.ContextBonus = ContextValues.Constant(0);
      }
      component.Descriptor = descriptor ?? component.Descriptor;
      component.MinimumCap = minimumCap ?? component.MinimumCap;
      component.MultiplierCap = multiplierCap ?? component.MultiplierCap;
      component.Value = value ?? component.Value;
      return AddUniqueComponent(component, mergeBehavior, merge);
    }

    /// <summary>
    /// Adds <see cref="BuffOnArmor"/>
    /// </summary>
    ///
    /// <remarks>
    ///
    /// <para>
    /// ComponentName: Add AC if owner has shield
    /// </para>
    ///
    /// <list type="bullet">
    /// <listheader>Used by</listheader>
    /// <item><term>ArmorMastery</term><description>ae177f17cfb45264291d4d7c2cb64671</description></item>
    /// </list>
    /// </remarks>
    ///
    /// <param name="buff">
    /// <para>
    /// Blueprint of type BlueprintBuff. You can pass in the blueprint using:
    /// <list type ="bullet">
    ///   <item><term>A blueprint instance</term></item>
    ///   <item><term>A blueprint reference</term></item>
    ///   <item><term>A blueprint id as a string, Guid, or BlueprintGuid</term></item>
    ///   <item><term>A blueprint name registered with <see cref="BlueprintCore.Utils.BlueprintTool">BlueprintTool</see></term></item>
    /// </list>
    /// See <see cref="BlueprintCore.Utils.Blueprint{{T, TRef}}">Blueprint</see> for more details.
    /// </para>
    /// </param>
    /// <param name="merge">
    /// If mergeBehavior is ComponentMerge.Merge and the component already exists, this expression is called to merge the components.
    /// </param>
    /// <param name="mergeBehavior">
    /// Handling if the component already exists since the component is unique. Defaults to ComponentMerge.Fail.
    /// </param>
    public TBuilder AddBuffOnArmor(
        Blueprint<BlueprintBuff, BlueprintBuffReference>? buff = null,
        Action<BlueprintComponent, BlueprintComponent>? merge = null,
        ComponentMerge mergeBehavior = ComponentMerge.Merge)
    {
      var component = new BuffOnArmor();
      component.m_Buff = buff?.Reference ?? component.m_Buff;
      if (component.m_Buff is null)
      {
        component.m_Buff = BlueprintTool.GetRef<BlueprintBuffReference>(null);
      }
      return AddUniqueComponent(component, mergeBehavior, merge);
    }

    /// <summary>
    /// Adds <see cref="BuffOnHealthTickingTrigger"/>
    /// </summary>
    ///
    /// <remarks>
    ///
    /// <para>
    /// ComponentName: Ticking trigger for low health
    /// </para>
    ///
    /// <list type="bullet">
    /// <listheader>Used by</listheader>
    /// <item><term>LastStandBuff</term><description>c5455f88975e16648b4abc47a28fa120</description></item>
    /// <item><term>MonsterMythic5HealthTriggerBadBuff</term><description>a668bbad55c0945478fcc62c4f079510</description></item>
    /// </list>
    /// </remarks>
    ///
    /// <param name="merge">
    /// If mergeBehavior is ComponentMerge.Merge and the component already exists, this expression is called to merge the components.
    /// </param>
    /// <param name="mergeBehavior">
    /// Handling if the component already exists since the component is unique. Defaults to ComponentMerge.Fail.
    /// </param>
    /// <param name="triggeredBuff">
    /// <para>
    /// Blueprint of type BlueprintBuff. You can pass in the blueprint using:
    /// <list type ="bullet">
    ///   <item><term>A blueprint instance</term></item>
    ///   <item><term>A blueprint reference</term></item>
    ///   <item><term>A blueprint id as a string, Guid, or BlueprintGuid</term></item>
    ///   <item><term>A blueprint name registered with <see cref="BlueprintCore.Utils.BlueprintTool">BlueprintTool</see></term></item>
    /// </list>
    /// See <see cref="BlueprintCore.Utils.Blueprint{{T, TRef}}">Blueprint</see> for more details.
    /// </para>
    /// </param>
    public TBuilder AddBuffOnHealthTickingTrigger(
        float? healthPercent = null,
        Action<BlueprintComponent, BlueprintComponent>? merge = null,
        ComponentMerge mergeBehavior = ComponentMerge.Merge,
        Blueprint<BlueprintBuff, BlueprintBuffReference>? triggeredBuff = null)
    {
      var component = new BuffOnHealthTickingTrigger();
      component.HealthPercent = healthPercent ?? component.HealthPercent;
      component.m_TriggeredBuff = triggeredBuff?.Reference ?? component.m_TriggeredBuff;
      if (component.m_TriggeredBuff is null)
      {
        component.m_TriggeredBuff = BlueprintTool.GetRef<BlueprintBuffReference>(null);
      }
      return AddUniqueComponent(component, mergeBehavior, merge);
    }

    /// <summary>
    /// Adds <see cref="BuffOnLightOrNoArmor"/>
    /// </summary>
    ///
    /// <remarks>
    ///
    /// <para>
    /// ComponentName: Add AC if owner has Light Armor or no Armor
    /// </para>
    ///
    /// <list type="bullet">
    /// <listheader>Used by</listheader>
    /// <item><term>DanceOfAvoidanceFeature</term><description>32a4cdb964a370340a2d945ec8a76375</description></item>
    /// <item><term>GreaterDanceOfAvoidanceFeature</term><description>4ff17df890a636a4dbd572f55d8288ff</description></item>
    /// </list>
    /// </remarks>
    ///
    /// <param name="buff">
    /// <para>
    /// Blueprint of type BlueprintBuff. You can pass in the blueprint using:
    /// <list type ="bullet">
    ///   <item><term>A blueprint instance</term></item>
    ///   <item><term>A blueprint reference</term></item>
    ///   <item><term>A blueprint id as a string, Guid, or BlueprintGuid</term></item>
    ///   <item><term>A blueprint name registered with <see cref="BlueprintCore.Utils.BlueprintTool">BlueprintTool</see></term></item>
    /// </list>
    /// See <see cref="BlueprintCore.Utils.Blueprint{{T, TRef}}">Blueprint</see> for more details.
    /// </para>
    /// </param>
    /// <param name="merge">
    /// If mergeBehavior is ComponentMerge.Merge and the component already exists, this expression is called to merge the components.
    /// </param>
    /// <param name="mergeBehavior">
    /// Handling if the component already exists since the component is unique. Defaults to ComponentMerge.Fail.
    /// </param>
    public TBuilder AddBuffOnLightOrNoArmor(
        Blueprint<BlueprintBuff, BlueprintBuffReference>? buff = null,
        Action<BlueprintComponent, BlueprintComponent>? merge = null,
        ComponentMerge mergeBehavior = ComponentMerge.Merge)
    {
      var component = new BuffOnLightOrNoArmor();
      component.m_Buff = buff?.Reference ?? component.m_Buff;
      if (component.m_Buff is null)
      {
        component.m_Buff = BlueprintTool.GetRef<BlueprintBuffReference>(null);
      }
      return AddUniqueComponent(component, mergeBehavior, merge);
    }

    /// <summary>
    /// Adds <see cref="BuffParticleEffectPlay"/>
    /// </summary>
    ///
    /// <remarks>
    ///
    /// <para>
    /// ComponentName: BuffMechanics/Energy Damage Each Round
    /// </para>
    ///
    /// <list type="bullet">
    /// <listheader>Used by</listheader>
    /// <item><term>CorruptedMongrelRage</term><description>d59b905255b24020a25a020dfe8c820a</description></item>
    /// <item><term>StandartFocusedRageBuff</term><description>3513326cd64f475781799685c57fa452</description></item>
    /// <item><term>StandartRageBuff</term><description>da8ce41ac3cd74742b80984ccc3c9613</description></item>
    /// </list>
    /// </remarks>
    ///
    /// <param name="merge">
    /// If mergeBehavior is ComponentMerge.Merge and the component already exists, this expression is called to merge the components.
    /// </param>
    /// <param name="mergeBehavior">
    /// Handling if the component already exists since the component is unique. Defaults to ComponentMerge.Fail.
    /// </param>
    public TBuilder AddBuffParticleEffectPlay(
        PrefabLink? activateFx = null,
        PrefabLink? deactivateFx = null,
        PrefabLink? eachRoundFx = null,
        Action<BlueprintComponent, BlueprintComponent>? merge = null,
        ComponentMerge mergeBehavior = ComponentMerge.Merge,
        bool? playEachRound = null,
        bool? playOnActivate = null,
        bool? playOnDeactivate = null)
    {
      var component = new BuffParticleEffectPlay();
      component.ActivateFx = activateFx ?? component.ActivateFx;
      if (component.ActivateFx is null)
      {
        component.ActivateFx = Utils.Constants.Empty.PrefabLink;
      }
      component.DeactivateFx = deactivateFx ?? component.DeactivateFx;
      if (component.DeactivateFx is null)
      {
        component.DeactivateFx = Utils.Constants.Empty.PrefabLink;
      }
      component.EachRoundFx = eachRoundFx ?? component.EachRoundFx;
      if (component.EachRoundFx is null)
      {
        component.EachRoundFx = Utils.Constants.Empty.PrefabLink;
      }
      component.PlayEachRound = playEachRound ?? component.PlayEachRound;
      component.PlayOnActivate = playOnActivate ?? component.PlayOnActivate;
      component.PlayOnDeactivate = playOnDeactivate ?? component.PlayOnDeactivate;
      return AddUniqueComponent(component, mergeBehavior, merge);
    }

    /// <summary>
    /// Adds <see cref="BuffSaveEachRound"/>
    /// </summary>
    ///
    /// <remarks>
    ///
    /// <para>
    /// ComponentName: BuffMechanics/Saving throw each round
    /// </para>
    ///
    /// <list type="bullet">
    /// <listheader>Used by</listheader>
    /// <item><term>CursedThornArrowsQuiverOnEnemyBuff</term><description>307f462d5aa3766409a0b6aaff24e83c</description></item>
    /// <item><term>NaturesGraspBuff</term><description>b506053d4279ee347b56095c9714c008</description></item>
    /// <item><term>RevoltAttackBuff</term><description>ad48caada2fd3b14eae09fcb62cf07c5</description></item>
    /// </list>
    /// </remarks>
    ///
    /// <param name="merge">
    /// If mergeBehavior is ComponentMerge.Merge and the component already exists, this expression is called to merge the components.
    /// </param>
    /// <param name="mergeBehavior">
    /// Handling if the component already exists since the component is unique. Defaults to ComponentMerge.Fail.
    /// </param>
    public TBuilder AddBuffSaveEachRound(
        ActionsBuilder? actionsOnFail = null,
        ActionsBuilder? actionsOnPass = null,
        int? increaseDC = null,
        Action<BlueprintComponent, BlueprintComponent>? merge = null,
        ComponentMerge mergeBehavior = ComponentMerge.Merge,
        int? saveDC = null,
        SavingThrowType? saveType = null)
    {
      var component = new BuffSaveEachRound();
      component.ActionsOnFail = actionsOnFail?.Build() ?? component.ActionsOnFail;
      if (component.ActionsOnFail is null)
      {
        component.ActionsOnFail = Utils.Constants.Empty.Actions;
      }
      component.ActionsOnPass = actionsOnPass?.Build() ?? component.ActionsOnPass;
      if (component.ActionsOnPass is null)
      {
        component.ActionsOnPass = Utils.Constants.Empty.Actions;
      }
      component.IncreaseDC = increaseDC ?? component.IncreaseDC;
      component.SaveDC = saveDC ?? component.SaveDC;
      component.SaveType = saveType ?? component.SaveType;
      return AddUniqueComponent(component, mergeBehavior, merge);
    }

    /// <summary>
    /// Adds <see cref="BuffSkillBonus"/>
    /// </summary>
    ///
    /// <remarks>
    ///
    /// <para>
    /// ComponentName: BuffMechanics/Bonus to Stealth skill
    /// </para>
    ///
    /// <list type="bullet">
    /// <listheader>Used by</listheader>
    /// <item><term>NecklaceOfDoubleCorssesFeature</term><description>64d5a59feeb292e49a6c459fe37c3953</description></item>
    /// </list>
    /// </remarks>
    ///
    /// <param name="merge">
    /// If mergeBehavior is ComponentMerge.Merge and the component already exists, this expression is called to merge the components.
    /// </param>
    /// <param name="mergeBehavior">
    /// Handling if the component already exists since the component is unique. Defaults to ComponentMerge.Fail.
    /// </param>
    public TBuilder AddBuffSkillBonus(
        ModifierDescriptor? descriptor = null,
        Action<BlueprintComponent, BlueprintComponent>? merge = null,
        ComponentMerge mergeBehavior = ComponentMerge.Merge,
        StatType? stat = null,
        int? value = null)
    {
      var component = new BuffSkillBonus();
      component.Descriptor = descriptor ?? component.Descriptor;
      component.Stat = stat ?? component.Stat;
      component.Value = value ?? component.Value;
      return AddUniqueComponent(component, mergeBehavior, merge);
    }

    /// <summary>
    /// Adds <see cref="BuffSkillLoreNatureBonus"/>
    /// </summary>
    ///
    /// <remarks>
    ///
    /// <para>
    /// ComponentName: BuffMechanics/Bonus to Nature Lore skill
    /// </para>
    ///
    /// <list type="bullet">
    /// <listheader>Used by</listheader>
    /// <item><term>NaturesExileBuff</term><description>937d532c110880c40b0072f9ec1baee1</description></item>
    /// </list>
    /// </remarks>
    ///
    /// <param name="merge">
    /// If mergeBehavior is ComponentMerge.Merge and the component already exists, this expression is called to merge the components.
    /// </param>
    /// <param name="mergeBehavior">
    /// Handling if the component already exists since the component is unique. Defaults to ComponentMerge.Fail.
    /// </param>
    public TBuilder AddBuffSkillLoreNatureBonus(
        ModifierDescriptor? descriptor = null,
        Action<BlueprintComponent, BlueprintComponent>? merge = null,
        ComponentMerge mergeBehavior = ComponentMerge.Merge,
        int? value = null)
    {
      var component = new BuffSkillLoreNatureBonus();
      component.Descriptor = descriptor ?? component.Descriptor;
      component.Value = value ?? component.Value;
      return AddUniqueComponent(component, mergeBehavior, merge);
    }

    /// <summary>
    /// Adds <see cref="BuffSkillStealthBonus"/>
    /// </summary>
    ///
    /// <remarks>
    ///
    /// <para>
    /// ComponentName: BuffMechanics/Bonus to Stealth skill
    /// </para>
    ///
    /// <list type="bullet">
    /// <listheader>Used by</listheader>
    /// <item><term>FaerieFireBuff</term><description>cc383a9eaae4d2b45a925d442b367b54</description></item>
    /// </list>
    /// </remarks>
    ///
    /// <param name="merge">
    /// If mergeBehavior is ComponentMerge.Merge and the component already exists, this expression is called to merge the components.
    /// </param>
    /// <param name="mergeBehavior">
    /// Handling if the component already exists since the component is unique. Defaults to ComponentMerge.Fail.
    /// </param>
    public TBuilder AddBuffSkillStealthBonus(
        ModifierDescriptor? descriptor = null,
        Action<BlueprintComponent, BlueprintComponent>? merge = null,
        ComponentMerge mergeBehavior = ComponentMerge.Merge,
        int? value = null)
    {
      var component = new BuffSkillStealthBonus();
      component.Descriptor = descriptor ?? component.Descriptor;
      component.Value = value ?? component.Value;
      return AddUniqueComponent(component, mergeBehavior, merge);
    }

    /// <summary>
    /// Adds <see cref="BuffSpellSubstitution"/>
    /// </summary>
    ///
    /// <remarks>
    ///
    /// <list type="bullet">
    /// <listheader>Used by</listheader>
    /// </list>
    /// </remarks>
    ///
    /// <param name="excludedSpells">
    /// <para>
    /// Blueprint of type BlueprintAbility. You can pass in the blueprint using:
    /// <list type ="bullet">
    ///   <item><term>A blueprint instance</term></item>
    ///   <item><term>A blueprint reference</term></item>
    ///   <item><term>A blueprint id as a string, Guid, or BlueprintGuid</term></item>
    ///   <item><term>A blueprint name registered with <see cref="BlueprintCore.Utils.BlueprintTool">BlueprintTool</see></term></item>
    /// </list>
    /// See <see cref="BlueprintCore.Utils.Blueprint{{T, TRef}}">Blueprint</see> for more details.
    /// </para>
    /// </param>
    /// <param name="protectionBuffs">
    /// <para>
    /// Blueprint of type BlueprintBuff. You can pass in the blueprint using:
    /// <list type ="bullet">
    ///   <item><term>A blueprint instance</term></item>
    ///   <item><term>A blueprint reference</term></item>
    ///   <item><term>A blueprint id as a string, Guid, or BlueprintGuid</term></item>
    ///   <item><term>A blueprint name registered with <see cref="BlueprintCore.Utils.BlueprintTool">BlueprintTool</see></term></item>
    /// </list>
    /// See <see cref="BlueprintCore.Utils.Blueprint{{T, TRef}}">Blueprint</see> for more details.
    /// </para>
    /// </param>
    /// <param name="spells">
    /// <para>
    /// Blueprint of type BlueprintAbility. You can pass in the blueprint using:
    /// <list type ="bullet">
    ///   <item><term>A blueprint instance</term></item>
    ///   <item><term>A blueprint reference</term></item>
    ///   <item><term>A blueprint id as a string, Guid, or BlueprintGuid</term></item>
    ///   <item><term>A blueprint name registered with <see cref="BlueprintCore.Utils.BlueprintTool">BlueprintTool</see></term></item>
    /// </list>
    /// See <see cref="BlueprintCore.Utils.Blueprint{{T, TRef}}">Blueprint</see> for more details.
    /// </para>
    /// </param>
    public TBuilder AddBuffSpellSubstitution(
        float? chance = null,
        ContextValue? dC = null,
        List<Blueprint<BlueprintAbility, BlueprintAbilityReference>>? excludedSpells = null,
        List<Blueprint<BlueprintBuff, BlueprintBuffReference>>? protectionBuffs = null,
        List<Blueprint<BlueprintAbility, BlueprintAbilityReference>>? spells = null)
    {
      var component = new BuffSpellSubstitution();
      component.Chance = chance ?? component.Chance;
      component.DC = dC ?? component.DC;
      if (component.DC is null)
      {
        component.DC = ContextValues.Constant(0);
      }
      component.m_ExcludedSpells = excludedSpells?.Select(bp => bp.Reference)?.ToArray() ?? component.m_ExcludedSpells;
      if (component.m_ExcludedSpells is null)
      {
        component.m_ExcludedSpells = new BlueprintAbilityReference[0];
      }
      component.m_ProtectionBuffs = protectionBuffs?.Select(bp => bp.Reference)?.ToArray() ?? component.m_ProtectionBuffs;
      if (component.m_ProtectionBuffs is null)
      {
        component.m_ProtectionBuffs = new BlueprintBuffReference[0];
      }
      component.m_Spells = spells?.Select(bp => bp.Reference)?.ToArray() ?? component.m_Spells;
      if (component.m_Spells is null)
      {
        component.m_Spells = new BlueprintAbilityReference[0];
      }
      return AddComponent(component);
    }

    /// <summary>
    /// Adds <see cref="BuffStatusCondition"/>
    /// </summary>
    ///
    /// <remarks>
    ///
    /// <para>
    /// ComponentName: BuffMechanics/Status Effect
    /// </para>
    ///
    /// <list type="bullet">
    /// <listheader>Used by</listheader>
    /// <item><term>AcidCloudsBuff_DLC2</term><description>d196ea96bd5344c3bdd604f80efce406</description></item>
    /// <item><term>IronGolemSlowBuff</term><description>1b6ac64d99882e04cbb1d3ac61b5af3b</description></item>
    /// <item><term>WordOfChaosConfusionBuff</term><description>7afd2712c9b599748943e3564eaec9f7</description></item>
    /// </list>
    /// </remarks>
    ///
    /// <param name="merge">
    /// If mergeBehavior is ComponentMerge.Merge and the component already exists, this expression is called to merge the components.
    /// </param>
    /// <param name="mergeBehavior">
    /// Handling if the component already exists since the component is unique. Defaults to ComponentMerge.Fail.
    /// </param>
    public TBuilder AddBuffStatusCondition(
        UnitCondition? condition = null,
        Action<BlueprintComponent, BlueprintComponent>? merge = null,
        ComponentMerge mergeBehavior = ComponentMerge.Merge,
        bool? saveEachRound = null,
        SavingThrowType? saveType = null)
    {
      var component = new BuffStatusCondition();
      component.Condition = condition ?? component.Condition;
      component.SaveEachRound = saveEachRound ?? component.SaveEachRound;
      component.SaveType = saveType ?? component.SaveType;
      return AddUniqueComponent(component, mergeBehavior, merge);
    }

    /// <summary>
    /// Adds <see cref="BurstBarrier"/>
    /// </summary>
    ///
    /// <remarks>
    ///
    /// <list type="bullet">
    /// <listheader>Used by</listheader>
    /// <item><term>BurstBarrier</term><description>6c97b3fd5d354454c9f69fea5348a7e8</description></item>
    /// </list>
    /// </remarks>
    ///
    /// <param name="merge">
    /// If mergeBehavior is ComponentMerge.Merge and the component already exists, this expression is called to merge the components.
    /// </param>
    /// <param name="mergeBehavior">
    /// Handling if the component already exists since the component is unique. Defaults to ComponentMerge.Fail.
    /// </param>
    public TBuilder AddBurstBarrier(
        Action<BlueprintComponent, BlueprintComponent>? merge = null,
        ComponentMerge mergeBehavior = ComponentMerge.Merge)
    {
      var component = new BurstBarrier();
      return AddUniqueComponent(component, mergeBehavior, merge);
    }

    /// <summary>
    /// Adds <see cref="CannyDefensePermanent"/>
    /// </summary>
    ///
    /// <remarks>
    ///
    /// <list type="bullet">
    /// <listheader>Used by</listheader>
    /// <item><term>CannyDefense</term><description>9a0a447e161207d46829ce2bd8b3cc6f</description></item>
    /// <item><term>SwordSaintCannyDefense</term><description>f58e19256746efa419e640175d4e21ad</description></item>
    /// </list>
    /// </remarks>
    ///
    /// <param name="characterClass">
    /// <para>
    /// Blueprint of type BlueprintCharacterClass. You can pass in the blueprint using:
    /// <list type ="bullet">
    ///   <item><term>A blueprint instance</term></item>
    ///   <item><term>A blueprint reference</term></item>
    ///   <item><term>A blueprint id as a string, Guid, or BlueprintGuid</term></item>
    ///   <item><term>A blueprint name registered with <see cref="BlueprintCore.Utils.BlueprintTool">BlueprintTool</see></term></item>
    /// </list>
    /// See <see cref="BlueprintCore.Utils.Blueprint{{T, TRef}}">Blueprint</see> for more details.
    /// </para>
    /// </param>
    /// <param name="chosenWeaponBlueprint">
    /// <para>
    /// Blueprint of type BlueprintParametrizedFeature. You can pass in the blueprint using:
    /// <list type ="bullet">
    ///   <item><term>A blueprint instance</term></item>
    ///   <item><term>A blueprint reference</term></item>
    ///   <item><term>A blueprint id as a string, Guid, or BlueprintGuid</term></item>
    ///   <item><term>A blueprint name registered with <see cref="BlueprintCore.Utils.BlueprintTool">BlueprintTool</see></term></item>
    /// </list>
    /// See <see cref="BlueprintCore.Utils.Blueprint{{T, TRef}}">Blueprint</see> for more details.
    /// </para>
    /// </param>
    /// <param name="merge">
    /// If mergeBehavior is ComponentMerge.Merge and the component already exists, this expression is called to merge the components.
    /// </param>
    /// <param name="mergeBehavior">
    /// Handling if the component already exists since the component is unique. Defaults to ComponentMerge.Fail.
    /// </param>
    public TBuilder AddCannyDefensePermanent(
        Blueprint<BlueprintCharacterClass, BlueprintCharacterClassReference>? characterClass = null,
        Blueprint<BlueprintParametrizedFeature, BlueprintParametrizedFeatureReference>? chosenWeaponBlueprint = null,
        Action<BlueprintComponent, BlueprintComponent>? merge = null,
        ComponentMerge mergeBehavior = ComponentMerge.Merge,
        bool? requiresKensai = null)
    {
      var component = new CannyDefensePermanent();
      component.m_CharacterClass = characterClass?.Reference ?? component.m_CharacterClass;
      if (component.m_CharacterClass is null)
      {
        component.m_CharacterClass = BlueprintTool.GetRef<BlueprintCharacterClassReference>(null);
      }
      component.m_ChosenWeaponBlueprint = chosenWeaponBlueprint?.Reference ?? component.m_ChosenWeaponBlueprint;
      if (component.m_ChosenWeaponBlueprint is null)
      {
        component.m_ChosenWeaponBlueprint = BlueprintTool.GetRef<BlueprintParametrizedFeatureReference>(null);
      }
      component.RequiresKensai = requiresKensai ?? component.RequiresKensai;
      return AddUniqueComponent(component, mergeBehavior, merge);
    }

    /// <summary>
    /// Adds <see cref="ChangeUnitSize"/>
    /// </summary>
    ///
    /// <remarks>
    ///
    /// <list type="bullet">
    /// <listheader>Used by</listheader>
    /// <item><term>AeonNormalizeSizeGazeEnemyGargantuaBuff</term><description>39ce7de50e1e43439a205cfef8059f5e</description></item>
    /// <item><term>DragonAzataFeatureTierIIBuff</term><description>95f7a7c4be0e4c73855b1cc71b45dba4</description></item>
    /// <item><term>TricksterMicroscopicProportionsBuff</term><description>1dfc2f933e7833f41922411962e1d58a</description></item>
    /// </list>
    /// </remarks>
    public TBuilder AddChangeUnitSize(
        Size? size = null,
        int? sizeDelta = null,
        ChangeUnitSize.ChangeType? type = null)
    {
      var component = new ChangeUnitSize();
      component.Size = size ?? component.Size;
      component.SizeDelta = sizeDelta ?? component.SizeDelta;
      component.m_Type = type ?? component.m_Type;
      return AddComponent(component);
    }

    /// <summary>
    /// Adds <see cref="DamageBonusConditional"/>
    /// </summary>
    ///
    /// <remarks>
    ///
    /// <list type="bullet">
    /// <listheader>Used by</listheader>
    /// <item><term>Airborne</term><description>70cffb448c132fa409e49156d013b175</description></item>
    /// <item><term>BowBreakerFeature</term><description>136b8887c8de4f4ba819440e6db43790</description></item>
    /// <item><term>FearControlFeature</term><description>16c499797605dd244a365fc73f475e11</description></item>
    /// </list>
    /// </remarks>
    ///
    /// <param name="merge">
    /// If mergeBehavior is ComponentMerge.Merge and the component already exists, this expression is called to merge the components.
    /// </param>
    /// <param name="mergeBehavior">
    /// Handling if the component already exists since the component is unique. Defaults to ComponentMerge.Fail.
    /// </param>
    public TBuilder AddDamageBonusConditional(
        ContextValue? bonus = null,
        bool? checkWielder = null,
        ConditionsBuilder? conditions = null,
        ModifierDescriptor? descriptor = null,
        Action<BlueprintComponent, BlueprintComponent>? merge = null,
        ComponentMerge mergeBehavior = ComponentMerge.Merge,
        bool? onlyWeaponDamage = null)
    {
      var component = new DamageBonusConditional();
      component.Bonus = bonus ?? component.Bonus;
      if (component.Bonus is null)
      {
        component.Bonus = ContextValues.Constant(0);
      }
      component.CheckWielder = checkWielder ?? component.CheckWielder;
      component.Conditions = conditions?.Build() ?? component.Conditions;
      if (component.Conditions is null)
      {
        component.Conditions = Utils.Constants.Empty.Conditions;
      }
      component.Descriptor = descriptor ?? component.Descriptor;
      component.OnlyWeaponDamage = onlyWeaponDamage ?? component.OnlyWeaponDamage;
      return AddUniqueComponent(component, mergeBehavior, merge);
    }

    /// <summary>
    /// Adds <see cref="DamageOverTime"/>
    /// </summary>
    ///
    /// <remarks>
    ///
    /// <para>
    /// ComponentName: BuffMechanics/Energy Damage Each Round
    /// </para>
    ///
    /// <list type="bullet">
    /// <listheader>Used by</listheader>
    /// <item><term>DamageAfterRage</term><description>72f220934a933eb40a61b37fe8751286</description></item>
    /// <item><term>DamageAfterRage</term><description>ee24f9ee659d040478c69ec17fa556aa</description></item>
    /// <item><term>DeadlyGraceBuff</term><description>fe0f848e8e5982941b09a4b4d5771aa2</description></item>
    /// </list>
    /// </remarks>
    ///
    /// <param name="merge">
    /// If mergeBehavior is ComponentMerge.Merge and the component already exists, this expression is called to merge the components.
    /// </param>
    /// <param name="mergeBehavior">
    /// Handling if the component already exists since the component is unique. Defaults to ComponentMerge.Fail.
    /// </param>
    public TBuilder AddDamageOverTime(
        DiceFormula? damage = null,
        DamageEnergyType? energyType = null,
        bool? instantStartTick = null,
        Action<BlueprintComponent, BlueprintComponent>? merge = null,
        ComponentMerge mergeBehavior = ComponentMerge.Merge)
    {
      var component = new DamageOverTime();
      component.Damage = damage ?? component.Damage;
      component.EnergyType = energyType ?? component.EnergyType;
      component.InstantStartTick = instantStartTick ?? component.InstantStartTick;
      return AddUniqueComponent(component, mergeBehavior, merge);
    }

    /// <summary>
    /// Adds <see cref="DevilReflectAbility"/>
    /// </summary>
    ///
    /// <remarks>
    ///
    /// <list type="bullet">
    /// <listheader>Used by</listheader>
    /// <item><term>HellsSealVariantMindReflectBuff</term><description>ab52d90a7895595498a7266bbf69563f</description></item>
    /// </list>
    /// </remarks>
    public TBuilder AddDevilReflectAbility(
        SpellSchool[]? reflectSchools = null)
    {
      var component = new DevilReflectAbility();
      component.m_ReflectSchools = reflectSchools ?? component.m_ReflectSchools;
      if (component.m_ReflectSchools is null)
      {
        component.m_ReflectSchools = new SpellSchool[0];
      }
      return AddComponent(component);
    }

    /// <summary>
    /// Adds <see cref="DifficultyStatAdvancement"/>
    /// </summary>
    ///
    /// <remarks>
    ///
    /// <para>
    /// ComponentName: Add stat bonuses for difficulty
    /// </para>
    ///
    /// <list type="bullet">
    /// <listheader>Used by</listheader>
    /// <item><term>DifficultOpponent</term><description>6e318c139554e3341b52991ba2c5a3c7</description></item>
    /// </list>
    /// </remarks>
    ///
    /// <param name="merge">
    /// If mergeBehavior is ComponentMerge.Merge and the component already exists, this expression is called to merge the components.
    /// </param>
    /// <param name="mergeBehavior">
    /// Handling if the component already exists since the component is unique. Defaults to ComponentMerge.Fail.
    /// </param>
    public TBuilder AddDifficultyStatAdvancement(
        int? basicStatBonus = null,
        int? derivativeStatBonus = null,
        Action<BlueprintComponent, BlueprintComponent>? merge = null,
        ComponentMerge mergeBehavior = ComponentMerge.Merge)
    {
      var component = new DifficultyStatAdvancement();
      component.BasicStatBonus = basicStatBonus ?? component.BasicStatBonus;
      component.DerivativeStatBonus = derivativeStatBonus ?? component.DerivativeStatBonus;
      return AddUniqueComponent(component, mergeBehavior, merge);
    }

    /// <summary>
    /// Adds <see cref="EchoesOfStoneTerrainBonus"/>
    /// </summary>
    ///
    /// <remarks>
    ///
    /// <list type="bullet">
    /// <listheader>Used by</listheader>
    /// <item><term>EchoesOfStone</term><description>70d3ac68dad02074791f58c8ba09d42f</description></item>
    /// </list>
    /// </remarks>
    ///
    /// <param name="merge">
    /// If mergeBehavior is ComponentMerge.Merge and the component already exists, this expression is called to merge the components.
    /// </param>
    /// <param name="mergeBehavior">
    /// Handling if the component already exists since the component is unique. Defaults to ComponentMerge.Fail.
    /// </param>
    public TBuilder AddEchoesOfStoneTerrainBonus(
        Action<BlueprintComponent, BlueprintComponent>? merge = null,
        ComponentMerge mergeBehavior = ComponentMerge.Merge,
        AreaSetting? setting = null)
    {
      var component = new EchoesOfStoneTerrainBonus();
      component.Setting = setting ?? component.Setting;
      return AddUniqueComponent(component, mergeBehavior, merge);
    }

    /// <summary>
    /// Adds <see cref="EmptyHandWeaponOverride"/>
    /// </summary>
    ///
    /// <remarks>
    ///
    /// <para>
    /// ComponentName: Override owner's empty hand weapon
    /// </para>
    ///
    /// <list type="bullet">
    /// <listheader>Used by</listheader>
    /// <item><term>AnimalBlessingMinorBuff</term><description>6c45e13671a7ccb49814bdd1b0b7c2e7</description></item>
    /// <item><term>BloodlineDraconicSilverClawsBuffLevel4</term><description>fa74b1be2d52f4d4da4e30c0acbfd21e</description></item>
    /// <item><term>WitchHexNailsFeature</term><description>6a9a6cd57f30ffb4784625742c2f1756</description></item>
    /// </list>
    /// </remarks>
    ///
    /// <param name="isPermanent">
    /// <para>
    /// InfoBox: If character receive permanent empty hand weapon while not permanent empty hand weapon is already active then new weapon goes to stack and doesn't override currently active weapon
    /// </para>
    /// </param>
    /// <param name="weapon">
    /// <para>
    /// Blueprint of type BlueprintItemWeapon. You can pass in the blueprint using:
    /// <list type ="bullet">
    ///   <item><term>A blueprint instance</term></item>
    ///   <item><term>A blueprint reference</term></item>
    ///   <item><term>A blueprint id as a string, Guid, or BlueprintGuid</term></item>
    ///   <item><term>A blueprint name registered with <see cref="BlueprintCore.Utils.BlueprintTool">BlueprintTool</see></term></item>
    /// </list>
    /// See <see cref="BlueprintCore.Utils.Blueprint{{T, TRef}}">Blueprint</see> for more details.
    /// </para>
    /// </param>
    public TBuilder AddEmptyHandWeaponOverride(
        bool? isMonkUnarmedStrike = null,
        bool? isPermanent = null,
        Blueprint<BlueprintItemWeapon, BlueprintItemWeaponReference>? weapon = null)
    {
      var component = new EmptyHandWeaponOverride();
      component.IsMonkUnarmedStrike = isMonkUnarmedStrike ?? component.IsMonkUnarmedStrike;
      component.IsPermanent = isPermanent ?? component.IsPermanent;
      component.m_Weapon = weapon?.Reference ?? component.m_Weapon;
      if (component.m_Weapon is null)
      {
        component.m_Weapon = BlueprintTool.GetRef<BlueprintItemWeaponReference>(null);
      }
      return AddComponent(component);
    }

    /// <summary>
    /// Adds <see cref="HasArmorFeatureUnlock"/>
    /// </summary>
    ///
    /// <remarks>
    ///
    /// <para>
    /// ComponentName: Add feature if owner has no armor or shield
    /// </para>
    ///
    /// <list type="bullet">
    /// <listheader>Used by</listheader>
    /// <item><term>Hellknight10Feature</term><description>ad93356a2a3b71b4ba59b04389409a37</description></item>
    /// <item><term>HellKnightInfernalArmor</term><description>ebf6791573c8c834f99efb5bc16cf341</description></item>
    /// </list>
    /// </remarks>
    ///
    /// <param name="merge">
    /// If mergeBehavior is ComponentMerge.Merge and the component already exists, this expression is called to merge the components.
    /// </param>
    /// <param name="mergeBehavior">
    /// Handling if the component already exists since the component is unique. Defaults to ComponentMerge.Fail.
    /// </param>
    /// <param name="newFact">
    /// <para>
    /// Blueprint of type BlueprintUnitFact. You can pass in the blueprint using:
    /// <list type ="bullet">
    ///   <item><term>A blueprint instance</term></item>
    ///   <item><term>A blueprint reference</term></item>
    ///   <item><term>A blueprint id as a string, Guid, or BlueprintGuid</term></item>
    ///   <item><term>A blueprint name registered with <see cref="BlueprintCore.Utils.BlueprintTool">BlueprintTool</see></term></item>
    /// </list>
    /// See <see cref="BlueprintCore.Utils.Blueprint{{T, TRef}}">Blueprint</see> for more details.
    /// </para>
    /// </param>
    public TBuilder AddHasArmorFeatureUnlock(
        Action<BlueprintComponent, BlueprintComponent>? merge = null,
        ComponentMerge mergeBehavior = ComponentMerge.Merge,
        Blueprint<BlueprintUnitFact, BlueprintUnitFactReference>? newFact = null)
    {
      var component = new HasArmorFeatureUnlock();
      component.m_NewFact = newFact?.Reference ?? component.m_NewFact;
      if (component.m_NewFact is null)
      {
        component.m_NewFact = BlueprintTool.GetRef<BlueprintUnitFactReference>(null);
      }
      return AddUniqueComponent(component, mergeBehavior, merge);
    }

    /// <summary>
    /// Adds <see cref="HealWithOutgoingDamage"/>
    /// </summary>
    ///
    /// <remarks>
    ///
    /// <list type="bullet">
    /// <listheader>Used by</listheader>
    /// </list>
    /// </remarks>
    ///
    /// <param name="merge">
    /// If mergeBehavior is ComponentMerge.Merge and the component already exists, this expression is called to merge the components.
    /// </param>
    /// <param name="mergeBehavior">
    /// Handling if the component already exists since the component is unique. Defaults to ComponentMerge.Fail.
    /// </param>
    public TBuilder AddHealWithOutgoingDamage(
        float? fraction = null,
        Action<BlueprintComponent, BlueprintComponent>? merge = null,
        ComponentMerge mergeBehavior = ComponentMerge.Merge)
    {
      var component = new HealWithOutgoingDamage();
      component.Fraction = fraction ?? component.Fraction;
      return AddUniqueComponent(component, mergeBehavior, merge);
    }

    /// <summary>
    /// Adds <see cref="IncreaseSpellDamageByClassLevel"/>
    /// </summary>
    ///
    /// <remarks>
    ///
    /// <list type="bullet">
    /// <listheader>Used by</listheader>
    /// <item><term>SunDomainBaseFeature</term><description>3d8e38c9ed54931469281ab0cec506e9</description></item>
    /// </list>
    /// </remarks>
    ///
    /// <param name="additionalClasses">
    /// <para>
    /// Blueprint of type BlueprintCharacterClass. You can pass in the blueprint using:
    /// <list type ="bullet">
    ///   <item><term>A blueprint instance</term></item>
    ///   <item><term>A blueprint reference</term></item>
    ///   <item><term>A blueprint id as a string, Guid, or BlueprintGuid</term></item>
    ///   <item><term>A blueprint name registered with <see cref="BlueprintCore.Utils.BlueprintTool">BlueprintTool</see></term></item>
    /// </list>
    /// See <see cref="BlueprintCore.Utils.Blueprint{{T, TRef}}">Blueprint</see> for more details.
    /// </para>
    /// </param>
    /// <param name="archetypes">
    /// <para>
    /// Blueprint of type BlueprintArchetype. You can pass in the blueprint using:
    /// <list type ="bullet">
    ///   <item><term>A blueprint instance</term></item>
    ///   <item><term>A blueprint reference</term></item>
    ///   <item><term>A blueprint id as a string, Guid, or BlueprintGuid</term></item>
    ///   <item><term>A blueprint name registered with <see cref="BlueprintCore.Utils.BlueprintTool">BlueprintTool</see></term></item>
    /// </list>
    /// See <see cref="BlueprintCore.Utils.Blueprint{{T, TRef}}">Blueprint</see> for more details.
    /// </para>
    /// </param>
    /// <param name="characterClass">
    /// <para>
    /// Blueprint of type BlueprintCharacterClass. You can pass in the blueprint using:
    /// <list type ="bullet">
    ///   <item><term>A blueprint instance</term></item>
    ///   <item><term>A blueprint reference</term></item>
    ///   <item><term>A blueprint id as a string, Guid, or BlueprintGuid</term></item>
    ///   <item><term>A blueprint name registered with <see cref="BlueprintCore.Utils.BlueprintTool">BlueprintTool</see></term></item>
    /// </list>
    /// See <see cref="BlueprintCore.Utils.Blueprint{{T, TRef}}">Blueprint</see> for more details.
    /// </para>
    /// </param>
    /// <param name="spells">
    /// <para>
    /// Blueprint of type BlueprintAbility. You can pass in the blueprint using:
    /// <list type ="bullet">
    ///   <item><term>A blueprint instance</term></item>
    ///   <item><term>A blueprint reference</term></item>
    ///   <item><term>A blueprint id as a string, Guid, or BlueprintGuid</term></item>
    ///   <item><term>A blueprint name registered with <see cref="BlueprintCore.Utils.BlueprintTool">BlueprintTool</see></term></item>
    /// </list>
    /// See <see cref="BlueprintCore.Utils.Blueprint{{T, TRef}}">Blueprint</see> for more details.
    /// </para>
    /// </param>
    public TBuilder AddIncreaseSpellDamageByClassLevel(
        List<Blueprint<BlueprintCharacterClass, BlueprintCharacterClassReference>>? additionalClasses = null,
        List<Blueprint<BlueprintArchetype, BlueprintArchetypeReference>>? archetypes = null,
        Blueprint<BlueprintCharacterClass, BlueprintCharacterClassReference>? characterClass = null,
        List<Blueprint<BlueprintAbility, BlueprintAbilityReference>>? spells = null)
    {
      var component = new IncreaseSpellDamageByClassLevel();
      component.m_AdditionalClasses = additionalClasses?.Select(bp => bp.Reference)?.ToArray() ?? component.m_AdditionalClasses;
      if (component.m_AdditionalClasses is null)
      {
        component.m_AdditionalClasses = new BlueprintCharacterClassReference[0];
      }
      component.m_Archetypes = archetypes?.Select(bp => bp.Reference)?.ToArray() ?? component.m_Archetypes;
      if (component.m_Archetypes is null)
      {
        component.m_Archetypes = new BlueprintArchetypeReference[0];
      }
      component.m_CharacterClass = characterClass?.Reference ?? component.m_CharacterClass;
      if (component.m_CharacterClass is null)
      {
        component.m_CharacterClass = BlueprintTool.GetRef<BlueprintCharacterClassReference>(null);
      }
      component.m_Spells = spells?.Select(bp => bp.Reference)?.ToArray() ?? component.m_Spells;
      if (component.m_Spells is null)
      {
        component.m_Spells = new BlueprintAbilityReference[0];
      }
      return AddComponent(component);
    }

    /// <summary>
    /// Adds <see cref="IntenseSpells"/>
    /// </summary>
    ///
    /// <remarks>
    ///
    /// <list type="bullet">
    /// <listheader>Used by</listheader>
    /// <item><term>SpecializationSchoolEvocation</term><description>c46512b796216b64899f26301241e4e6</description></item>
    /// </list>
    /// </remarks>
    ///
    /// <param name="wizard">
    /// <para>
    /// Blueprint of type BlueprintCharacterClass. You can pass in the blueprint using:
    /// <list type ="bullet">
    ///   <item><term>A blueprint instance</term></item>
    ///   <item><term>A blueprint reference</term></item>
    ///   <item><term>A blueprint id as a string, Guid, or BlueprintGuid</term></item>
    ///   <item><term>A blueprint name registered with <see cref="BlueprintCore.Utils.BlueprintTool">BlueprintTool</see></term></item>
    /// </list>
    /// See <see cref="BlueprintCore.Utils.Blueprint{{T, TRef}}">Blueprint</see> for more details.
    /// </para>
    /// </param>
    public TBuilder AddIntenseSpells(
        Blueprint<BlueprintCharacterClass, BlueprintCharacterClassReference>? wizard = null)
    {
      var component = new IntenseSpells();
      component.m_Wizard = wizard?.Reference ?? component.m_Wizard;
      if (component.m_Wizard is null)
      {
        component.m_Wizard = BlueprintTool.GetRef<BlueprintCharacterClassReference>(null);
      }
      return AddComponent(component);
    }

    /// <summary>
    /// Adds <see cref="LiquidateTowerShieldPenalty"/>
    /// </summary>
    ///
    /// <remarks>
    ///
    /// <list type="bullet">
    /// <listheader>Used by</listheader>
    /// <item><term>TowerShieldNegatePenalty</term><description>4808f1ac7432cbf488cf9213610acda0</description></item>
    /// </list>
    /// </remarks>
    ///
    /// <param name="merge">
    /// If mergeBehavior is ComponentMerge.Merge and the component already exists, this expression is called to merge the components.
    /// </param>
    /// <param name="mergeBehavior">
    /// Handling if the component already exists since the component is unique. Defaults to ComponentMerge.Fail.
    /// </param>
    public TBuilder AddLiquidateTowerShieldPenalty(
        Action<BlueprintComponent, BlueprintComponent>? merge = null,
        ComponentMerge mergeBehavior = ComponentMerge.Merge)
    {
      var component = new LiquidateTowerShieldPenalty();
      return AddUniqueComponent(component, mergeBehavior, merge);
    }

    /// <summary>
    /// Adds <see cref="MakeUnitFollowUnit"/>
    /// </summary>
    ///
    /// <remarks>
    ///
    /// <list type="bullet">
    /// <listheader>Used by</listheader>
    /// <item><term>EscortBuff</term><description>1a513e7df759656429db10449c24ba4a</description></item>
    /// <item><term>MakeFollowPlayer</term><description>6f1d9e5b1bf462642bb7e72d1ed67141</description></item>
    /// <item><term>RepurposeBuffUndead</term><description>5e18ce2e21330e34690c372fbd9d6d60</description></item>
    /// </list>
    /// </remarks>
    ///
    /// <param name="leader">
    /// <para>
    /// Tooltip: Main character if not specified
    /// </para>
    /// </param>
    public TBuilder AddMakeUnitFollowUnit(
        bool? alwaysRun = null,
        bool? canBeSlowerThanLeader = null,
        UnitEvaluator? leader = null)
    {
      var component = new MakeUnitFollowUnit();
      component.AlwaysRun = alwaysRun ?? component.AlwaysRun;
      component.CanBeSlowerThanLeader = canBeSlowerThanLeader ?? component.CanBeSlowerThanLeader;
      Validate(leader);
      component.Leader = leader ?? component.Leader;
      return AddComponent(component);
    }

    /// <summary>
    /// Adds <see cref="ModifySpell"/>
    /// </summary>
    ///
    /// <remarks>
    ///
    /// <list type="bullet">
    /// <listheader>Used by</listheader>
    /// <item><term>AngelSwordDepersonalizeFeature</term><description>432c96835aee50341a4ff0b364cdb85a</description></item>
    /// </list>
    /// </remarks>
    ///
    /// <param name="merge">
    /// If mergeBehavior is ComponentMerge.Merge and the component already exists, this expression is called to merge the components.
    /// </param>
    /// <param name="mergeBehavior">
    /// Handling if the component already exists since the component is unique. Defaults to ComponentMerge.Fail.
    /// </param>
    /// <param name="spells">
    /// <para>
    /// Blueprint of type BlueprintAbility. You can pass in the blueprint using:
    /// <list type ="bullet">
    ///   <item><term>A blueprint instance</term></item>
    ///   <item><term>A blueprint reference</term></item>
    ///   <item><term>A blueprint id as a string, Guid, or BlueprintGuid</term></item>
    ///   <item><term>A blueprint name registered with <see cref="BlueprintCore.Utils.BlueprintTool">BlueprintTool</see></term></item>
    /// </list>
    /// See <see cref="BlueprintCore.Utils.Blueprint{{T, TRef}}">Blueprint</see> for more details.
    /// </para>
    /// </param>
    public TBuilder AddModifySpell(
        Action<BlueprintComponent, BlueprintComponent>? merge = null,
        ComponentMerge mergeBehavior = ComponentMerge.Merge,
        SpellModificationType? modificationType = null,
        List<Blueprint<BlueprintAbility, BlueprintAbilityReference>>? spells = null)
    {
      var component = new ModifySpell();
      component.ModificationType = modificationType ?? component.ModificationType;
      component.m_Spells = spells?.Select(bp => bp.Reference)?.ToArray() ?? component.m_Spells;
      if (component.m_Spells is null)
      {
        component.m_Spells = new BlueprintAbilityReference[0];
      }
      return AddUniqueComponent(component, mergeBehavior, merge);
    }

    /// <summary>
    /// Adds <see cref="MonkNoArmorAndMonkWeaponFeatureUnlock"/>
    /// </summary>
    ///
    /// <remarks>
    ///
    /// <para>
    /// ComponentName: Add feature if owner has no armor or shield
    /// </para>
    ///
    /// <list type="bullet">
    /// <listheader>Used by</listheader>
    /// <item><term>MonkFlurryOfBlowstLevel11Unlock</term><description>a34b8a9fcc9024b42bacfd5e6b614bfa</description></item>
    /// <item><term>SoheiKiStrikeAdamantineUnlock</term><description>707756f8da99563429d869ca17ae76d2</description></item>
    /// <item><term>ZenArcherFlurryOfBlowsUnlock</term><description>3e470edc8a733b641bcbbbb5b9527ff6</description></item>
    /// </list>
    /// </remarks>
    ///
    /// <param name="bowWeaponTypes">
    /// <para>
    /// Blueprint of type BlueprintWeaponType. You can pass in the blueprint using:
    /// <list type ="bullet">
    ///   <item><term>A blueprint instance</term></item>
    ///   <item><term>A blueprint reference</term></item>
    ///   <item><term>A blueprint id as a string, Guid, or BlueprintGuid</term></item>
    ///   <item><term>A blueprint name registered with <see cref="BlueprintCore.Utils.BlueprintTool">BlueprintTool</see></term></item>
    /// </list>
    /// See <see cref="BlueprintCore.Utils.Blueprint{{T, TRef}}">Blueprint</see> for more details.
    /// </para>
    /// </param>
    /// <param name="merge">
    /// If mergeBehavior is ComponentMerge.Merge and the component already exists, this expression is called to merge the components.
    /// </param>
    /// <param name="mergeBehavior">
    /// Handling if the component already exists since the component is unique. Defaults to ComponentMerge.Fail.
    /// </param>
    /// <param name="newFact">
    /// <para>
    /// Blueprint of type BlueprintUnitFact. You can pass in the blueprint using:
    /// <list type ="bullet">
    ///   <item><term>A blueprint instance</term></item>
    ///   <item><term>A blueprint reference</term></item>
    ///   <item><term>A blueprint id as a string, Guid, or BlueprintGuid</term></item>
    ///   <item><term>A blueprint name registered with <see cref="BlueprintCore.Utils.BlueprintTool">BlueprintTool</see></term></item>
    /// </list>
    /// See <see cref="BlueprintCore.Utils.Blueprint{{T, TRef}}">Blueprint</see> for more details.
    /// </para>
    /// </param>
    /// <param name="rapidshotBuff">
    /// <para>
    /// Blueprint of type BlueprintBuff. You can pass in the blueprint using:
    /// <list type ="bullet">
    ///   <item><term>A blueprint instance</term></item>
    ///   <item><term>A blueprint reference</term></item>
    ///   <item><term>A blueprint id as a string, Guid, or BlueprintGuid</term></item>
    ///   <item><term>A blueprint name registered with <see cref="BlueprintCore.Utils.BlueprintTool">BlueprintTool</see></term></item>
    /// </list>
    /// See <see cref="BlueprintCore.Utils.Blueprint{{T, TRef}}">Blueprint</see> for more details.
    /// </para>
    /// </param>
    public TBuilder AddMonkNoArmorAndMonkWeaponFeatureUnlock(
        List<Blueprint<BlueprintWeaponType, BlueprintWeaponTypeReference>>? bowWeaponTypes = null,
        bool? isSohei = null,
        bool? isZenArcher = null,
        Action<BlueprintComponent, BlueprintComponent>? merge = null,
        ComponentMerge mergeBehavior = ComponentMerge.Merge,
        Blueprint<BlueprintUnitFact, BlueprintUnitFactReference>? newFact = null,
        Blueprint<BlueprintBuff, BlueprintBuffReference>? rapidshotBuff = null)
    {
      var component = new MonkNoArmorAndMonkWeaponFeatureUnlock();
      component.m_BowWeaponTypes = bowWeaponTypes?.Select(bp => bp.Reference)?.ToArray() ?? component.m_BowWeaponTypes;
      if (component.m_BowWeaponTypes is null)
      {
        component.m_BowWeaponTypes = new BlueprintWeaponTypeReference[0];
      }
      component.IsSohei = isSohei ?? component.IsSohei;
      component.IsZenArcher = isZenArcher ?? component.IsZenArcher;
      component.m_NewFact = newFact?.Reference ?? component.m_NewFact;
      if (component.m_NewFact is null)
      {
        component.m_NewFact = BlueprintTool.GetRef<BlueprintUnitFactReference>(null);
      }
      component.m_RapidshotBuff = rapidshotBuff?.Reference ?? component.m_RapidshotBuff;
      if (component.m_RapidshotBuff is null)
      {
        component.m_RapidshotBuff = BlueprintTool.GetRef<BlueprintBuffReference>(null);
      }
      return AddUniqueComponent(component, mergeBehavior, merge);
    }

    /// <summary>
    /// Adds <see cref="MonkNoArmorFeatureUnlock"/>
    /// </summary>
    ///
    /// <remarks>
    ///
    /// <para>
    /// ComponentName: Add feature if owner has no armor or shield
    /// </para>
    ///
    /// <list type="bullet">
    /// <listheader>Used by</listheader>
    /// <item><term>CunningElusionUnlockFeature</term><description>91c8b2e3abdb4e2e807fddb668b619f8</description></item>
    /// <item><term>MonkACBonusUnlock</term><description>2615c5f87b3d72b42ac0e73b56d895e0</description></item>
    /// <item><term>ScaledFistACBonusUnlock</term><description>2a8922e28b3eba54fa7a244f7b05bd9e</description></item>
    /// </list>
    /// </remarks>
    ///
    /// <param name="merge">
    /// If mergeBehavior is ComponentMerge.Merge and the component already exists, this expression is called to merge the components.
    /// </param>
    /// <param name="mergeBehavior">
    /// Handling if the component already exists since the component is unique. Defaults to ComponentMerge.Fail.
    /// </param>
    /// <param name="newFact">
    /// <para>
    /// Blueprint of type BlueprintUnitFact. You can pass in the blueprint using:
    /// <list type ="bullet">
    ///   <item><term>A blueprint instance</term></item>
    ///   <item><term>A blueprint reference</term></item>
    ///   <item><term>A blueprint id as a string, Guid, or BlueprintGuid</term></item>
    ///   <item><term>A blueprint name registered with <see cref="BlueprintCore.Utils.BlueprintTool">BlueprintTool</see></term></item>
    /// </list>
    /// See <see cref="BlueprintCore.Utils.Blueprint{{T, TRef}}">Blueprint</see> for more details.
    /// </para>
    /// </param>
    public TBuilder AddMonkNoArmorFeatureUnlock(
        Action<BlueprintComponent, BlueprintComponent>? merge = null,
        ComponentMerge mergeBehavior = ComponentMerge.Merge,
        Blueprint<BlueprintUnitFact, BlueprintUnitFactReference>? newFact = null)
    {
      var component = new MonkNoArmorFeatureUnlock();
      component.m_NewFact = newFact?.Reference ?? component.m_NewFact;
      if (component.m_NewFact is null)
      {
        component.m_NewFact = BlueprintTool.GetRef<BlueprintUnitFactReference>(null);
      }
      return AddUniqueComponent(component, mergeBehavior, merge);
    }

    /// <summary>
    /// Adds <see cref="MysticTheurgeCombinedSpells"/>
    /// </summary>
    ///
    /// <remarks>
    ///
    /// <list type="bullet">
    /// <listheader>Used by</listheader>
    /// <item><term>MysticTheurgeCombinedSpells1</term><description>80ea00ac94323cd43b6e743f2fa168c8</description></item>
    /// <item><term>MysticTheurgeCombinedSpells3</term><description>f34592b15e73c1445a204f07c5771abb</description></item>
    /// <item><term>MysticTheurgeCombinedSpells5</term><description>f5c7f64de0a57f645975fac2e5244851</description></item>
    /// </list>
    /// </remarks>
    ///
    /// <param name="merge">
    /// If mergeBehavior is ComponentMerge.Merge and the component already exists, this expression is called to merge the components.
    /// </param>
    /// <param name="mergeBehavior">
    /// Handling if the component already exists since the component is unique. Defaults to ComponentMerge.Fail.
    /// </param>
    public TBuilder AddMysticTheurgeCombinedSpells(
        Action<BlueprintComponent, BlueprintComponent>? merge = null,
        ComponentMerge mergeBehavior = ComponentMerge.Merge,
        int? spellLevel = null)
    {
      var component = new MysticTheurgeCombinedSpells();
      component.SpellLevel = spellLevel ?? component.SpellLevel;
      return AddUniqueComponent(component, mergeBehavior, merge);
    }

    /// <summary>
    /// Adds <see cref="MysticTheurgeSpellbook"/>
    /// </summary>
    ///
    /// <remarks>
    ///
    /// <list type="bullet">
    /// <listheader>Used by</listheader>
    /// <item><term>MysticTheurgeAngelfireApostleProgression</term><description>531a91faf90da634eaf2a08a90d28494</description></item>
    /// <item><term>MysticTheurgeInquisitorProgression</term><description>d21a104c204ed7348a51405e68387013</description></item>
    /// <item><term>MysticTheurgeWarpriestProgression</term><description>9a4ad60a34f042b0b4178624aa90f803</description></item>
    /// </list>
    /// </remarks>
    ///
    /// <param name="characterClass">
    /// <para>
    /// Blueprint of type BlueprintCharacterClass. You can pass in the blueprint using:
    /// <list type ="bullet">
    ///   <item><term>A blueprint instance</term></item>
    ///   <item><term>A blueprint reference</term></item>
    ///   <item><term>A blueprint id as a string, Guid, or BlueprintGuid</term></item>
    ///   <item><term>A blueprint name registered with <see cref="BlueprintCore.Utils.BlueprintTool">BlueprintTool</see></term></item>
    /// </list>
    /// See <see cref="BlueprintCore.Utils.Blueprint{{T, TRef}}">Blueprint</see> for more details.
    /// </para>
    /// </param>
    /// <param name="mysticTheurge">
    /// <para>
    /// Blueprint of type BlueprintCharacterClass. You can pass in the blueprint using:
    /// <list type ="bullet">
    ///   <item><term>A blueprint instance</term></item>
    ///   <item><term>A blueprint reference</term></item>
    ///   <item><term>A blueprint id as a string, Guid, or BlueprintGuid</term></item>
    ///   <item><term>A blueprint name registered with <see cref="BlueprintCore.Utils.BlueprintTool">BlueprintTool</see></term></item>
    /// </list>
    /// See <see cref="BlueprintCore.Utils.Blueprint{{T, TRef}}">Blueprint</see> for more details.
    /// </para>
    /// </param>
    public TBuilder AddMysticTheurgeSpellbook(
        Blueprint<BlueprintCharacterClass, BlueprintCharacterClassReference>? characterClass = null,
        Blueprint<BlueprintCharacterClass, BlueprintCharacterClassReference>? mysticTheurge = null)
    {
      var component = new MysticTheurgeSpellbook();
      component.m_CharacterClass = characterClass?.Reference ?? component.m_CharacterClass;
      if (component.m_CharacterClass is null)
      {
        component.m_CharacterClass = BlueprintTool.GetRef<BlueprintCharacterClassReference>(null);
      }
      component.m_MysticTheurge = mysticTheurge?.Reference ?? component.m_MysticTheurge;
      if (component.m_MysticTheurge is null)
      {
        component.m_MysticTheurge = BlueprintTool.GetRef<BlueprintCharacterClassReference>(null);
      }
      return AddComponent(component);
    }

    /// <summary>
    /// Adds <see cref="PowerfulCharge"/>
    /// </summary>
    ///
    /// <remarks>
    ///
    /// <list type="bullet">
    /// <listheader>Used by</listheader>
    /// <item><term>AnimalCompanionUpgradeElk</term><description>70206f918cecc9440925dad944760928</description></item>
    /// <item><term>Minotaur_PowerfulChargeFeature</term><description>71241b4c372431a4ea1c1e823f0c00ed</description></item>
    /// <item><term>Triceratops_Feature_PowerfulChargeFeature</term><description>5c1c2f9aa37ca7445a31bdb4ab16255b</description></item>
    /// </list>
    /// </remarks>
    ///
    /// <param name="merge">
    /// If mergeBehavior is ComponentMerge.Merge and the component already exists, this expression is called to merge the components.
    /// </param>
    /// <param name="mergeBehavior">
    /// Handling if the component already exists since the component is unique. Defaults to ComponentMerge.Fail.
    /// </param>
    public TBuilder AddPowerfulCharge(
        int? additionalDiceRolls = null,
        Action<BlueprintComponent, BlueprintComponent>? merge = null,
        ComponentMerge mergeBehavior = ComponentMerge.Merge,
        bool? useContextBonus = null,
        ContextValue? value = null)
    {
      var component = new PowerfulCharge();
      component.AdditionalDiceRolls = additionalDiceRolls ?? component.AdditionalDiceRolls;
      component.UseContextBonus = useContextBonus ?? component.UseContextBonus;
      component.Value = value ?? component.Value;
      if (component.Value is null)
      {
        component.Value = ContextValues.Constant(0);
      }
      return AddUniqueComponent(component, mergeBehavior, merge);
    }

    /// <summary>
    /// Adds <see cref="ProtectionFromEnergy"/>
    /// </summary>
    ///
    /// <remarks>
    ///
    /// <para>
    /// ComponentName: Protection From Energy
    /// </para>
    ///
    /// <list type="bullet">
    /// <listheader>Used by</listheader>
    /// <item><term>ProtectionFromAcidBuff</term><description>6f9d4b5d2fe2f684e816a54b4973cc58</description></item>
    /// <item><term>ProtectionFromFireBuff</term><description>52a2552185c4a7c4ba30e421b9e27224</description></item>
    /// <item><term>TrollBrandedProtection</term><description>8aad45a750a76b84ea5163fed362f215</description></item>
    /// </list>
    /// </remarks>
    ///
    /// <param name="merge">
    /// If mergeBehavior is ComponentMerge.Merge and the component already exists, this expression is called to merge the components.
    /// </param>
    /// <param name="mergeBehavior">
    /// Handling if the component already exists since the component is unique. Defaults to ComponentMerge.Fail.
    /// </param>
    public TBuilder AddProtectionFromEnergy(
        Action<BlueprintComponent, BlueprintComponent>? merge = null,
        ComponentMerge mergeBehavior = ComponentMerge.Merge,
        ContextValue? pool = null,
        DamageEnergyType? type = null,
        bool? usePool = null,
        bool? useValueMultiplier = null,
        ContextValue? value = null,
        ContextValue? valueMultiplier = null)
    {
      var component = new ProtectionFromEnergy();
      component.Pool = pool ?? component.Pool;
      if (component.Pool is null)
      {
        component.Pool = ContextValues.Constant(0);
      }
      component.Type = type ?? component.Type;
      component.UsePool = usePool ?? component.UsePool;
      component.UseValueMultiplier = useValueMultiplier ?? component.UseValueMultiplier;
      component.Value = value ?? component.Value;
      if (component.Value is null)
      {
        component.Value = ContextValues.Constant(0);
      }
      component.ValueMultiplier = valueMultiplier ?? component.ValueMultiplier;
      if (component.ValueMultiplier is null)
      {
        component.ValueMultiplier = ContextValues.Constant(0);
      }
      return AddUniqueComponent(component, mergeBehavior, merge);
    }

    /// <summary>
    /// Adds <see cref="PummelingCharge"/>
    /// </summary>
    ///
    /// <remarks>
    ///
    /// <list type="bullet">
    /// <listheader>Used by</listheader>
    /// <item><term>PummelingChargeBuff</term><description>0da484e5fcd6c0747a18a80f638e9240</description></item>
    /// </list>
    /// </remarks>
    public TBuilder AddPummelingCharge(
        WeaponCategory? unarmedCategory = null)
    {
      var component = new PummelingCharge();
      component.UnarmedCategory = unarmedCategory ?? component.UnarmedCategory;
      return AddComponent(component);
    }

    /// <summary>
    /// Adds <see cref="ReduceDamageReduction"/>
    /// </summary>
    ///
    /// <remarks>
    ///
    /// <list type="bullet">
    /// <listheader>Used by</listheader>
    /// <item><term>AeonDRGazeEnemyBuff</term><description>a9f713a9e431c5147910c1f877f1cc88</description></item>
    /// <item><term>FinneanPechkaSpellBuff</term><description>f4bf706618566014fae04323075a2d95</description></item>
    /// <item><term>WeakeningWoundBuff</term><description>9e0d01f2eb934a74bb27d0dbe924aaa7</description></item>
    /// </list>
    /// </remarks>
    ///
    /// <param name="merge">
    /// If mergeBehavior is ComponentMerge.Merge and the component already exists, this expression is called to merge the components.
    /// </param>
    /// <param name="mergeBehavior">
    /// Handling if the component already exists since the component is unique. Defaults to ComponentMerge.Fail.
    /// </param>
    public TBuilder AddReduceDamageReduction(
        Action<BlueprintComponent, BlueprintComponent>? merge = null,
        ComponentMerge mergeBehavior = ComponentMerge.Merge,
        int? multiplier = null,
        ContextValue? value = null)
    {
      var component = new ReduceDamageReduction();
      component.Multiplier = multiplier ?? component.Multiplier;
      component.Value = value ?? component.Value;
      if (component.Value is null)
      {
        component.Value = ContextValues.Constant(0);
      }
      return AddUniqueComponent(component, mergeBehavior, merge);
    }

    /// <summary>
    /// Adds <see cref="ReplaceAsksList"/>
    /// </summary>
    ///
    /// <remarks>
    ///
    /// <list type="bullet">
    /// <listheader>Used by</listheader>
    /// <item><term>Artifact_TigerArmorSmilodonBuff</term><description>cd90f378bacb1e848971e9137fc5a507</description></item>
    /// <item><term>FormOfTheDragonIIIGreenBuff</term><description>2d294863adf81f944a7558f7ae248448</description></item>
    /// <item><term>WitchHexAnimalSkinBuff</term><description>adf61123d3dcce14baf1dd6ffe0b2062</description></item>
    /// </list>
    /// </remarks>
    ///
    /// <param name="asks">
    /// <para>
    /// Blueprint of type BlueprintUnitAsksList. You can pass in the blueprint using:
    /// <list type ="bullet">
    ///   <item><term>A blueprint instance</term></item>
    ///   <item><term>A blueprint reference</term></item>
    ///   <item><term>A blueprint id as a string, Guid, or BlueprintGuid</term></item>
    ///   <item><term>A blueprint name registered with <see cref="BlueprintCore.Utils.BlueprintTool">BlueprintTool</see></term></item>
    /// </list>
    /// See <see cref="BlueprintCore.Utils.Blueprint{{T, TRef}}">Blueprint</see> for more details.
    /// </para>
    /// </param>
    public TBuilder AddReplaceAsksList(
        Blueprint<BlueprintUnitAsksList, BlueprintUnitAsksListReference>? asks = null)
    {
      var component = new ReplaceAsksList();
      component.m_Asks = asks?.Reference ?? component.m_Asks;
      if (component.m_Asks is null)
      {
        component.m_Asks = BlueprintTool.GetRef<BlueprintUnitAsksListReference>(null);
      }
      return AddComponent(component);
    }

    /// <summary>
    /// Adds <see cref="ResistEnergy"/>
    /// </summary>
    ///
    /// <remarks>
    ///
    /// <para>
    /// ComponentName: Resist Energy
    /// </para>
    ///
    /// <list type="bullet">
    /// <listheader>Used by</listheader>
    /// <item><term>AeonResistances</term><description>b755a4f21dedb2d4da7d839e217e2575</description></item>
    /// <item><term>FormOfTheDragonIGoldBuff</term><description>89669cfba3d9c15448c23b79dd604c41</description></item>
    /// <item><term>WildShapeIVShamblingMoundBuff</term><description>0d29c50c956e82d4eae56710987de9f7</description></item>
    /// </list>
    /// </remarks>
    ///
    /// <param name="merge">
    /// If mergeBehavior is ComponentMerge.Merge and the component already exists, this expression is called to merge the components.
    /// </param>
    /// <param name="mergeBehavior">
    /// Handling if the component already exists since the component is unique. Defaults to ComponentMerge.Fail.
    /// </param>
    public TBuilder AddResistEnergy(
        Action<BlueprintComponent, BlueprintComponent>? merge = null,
        ComponentMerge mergeBehavior = ComponentMerge.Merge,
        ContextValue? pool = null,
        DamageEnergyType? type = null,
        bool? usePool = null,
        bool? useValueMultiplier = null,
        ContextValue? value = null,
        ContextValue? valueMultiplier = null)
    {
      var component = new ResistEnergy();
      component.Pool = pool ?? component.Pool;
      if (component.Pool is null)
      {
        component.Pool = ContextValues.Constant(0);
      }
      component.Type = type ?? component.Type;
      component.UsePool = usePool ?? component.UsePool;
      component.UseValueMultiplier = useValueMultiplier ?? component.UseValueMultiplier;
      component.Value = value ?? component.Value;
      if (component.Value is null)
      {
        component.Value = ContextValues.Constant(0);
      }
      component.ValueMultiplier = valueMultiplier ?? component.ValueMultiplier;
      if (component.ValueMultiplier is null)
      {
        component.ValueMultiplier = ContextValues.Constant(0);
      }
      return AddUniqueComponent(component, mergeBehavior, merge);
    }

    /// <summary>
    /// Adds <see cref="ResistEnergyContext"/>
    /// </summary>
    ///
    /// <remarks>
    ///
    /// <para>
    /// ComponentName: Buffs/AddEffect/EnergyResistance
    /// </para>
    ///
    /// <list type="bullet">
    /// <listheader>Used by</listheader>
    /// <item><term>FlameDancerPerformanceEffectBuff</term><description>6b6258335b08dd74fb12e89eddceed7a</description></item>
    /// <item><term>ProtectionDomainGreaterEffect</term><description>fea7c44605c90f14fa40b2f2f5ae6339</description></item>
    /// <item><term>ResistanceJudgmentBuff</term><description>e73da542e92df1843a93e29701a2e1d8</description></item>
    /// </list>
    /// </remarks>
    ///
    /// <param name="merge">
    /// If mergeBehavior is ComponentMerge.Merge and the component already exists, this expression is called to merge the components.
    /// </param>
    /// <param name="mergeBehavior">
    /// Handling if the component already exists since the component is unique. Defaults to ComponentMerge.Fail.
    /// </param>
    public TBuilder AddResistEnergyContext(
        Action<BlueprintComponent, BlueprintComponent>? merge = null,
        ComponentMerge mergeBehavior = ComponentMerge.Merge,
        ContextValue? pool = null,
        DamageEnergyType? type = null,
        bool? usePool = null,
        bool? useValueMultiplier = null,
        ContextValue? value = null,
        ContextValue? valueMultiplier = null)
    {
      var component = new ResistEnergyContext();
      component.Pool = pool ?? component.Pool;
      if (component.Pool is null)
      {
        component.Pool = ContextValues.Constant(0);
      }
      component.Type = type ?? component.Type;
      component.UsePool = usePool ?? component.UsePool;
      component.UseValueMultiplier = useValueMultiplier ?? component.UseValueMultiplier;
      component.Value = value ?? component.Value;
      if (component.Value is null)
      {
        component.Value = ContextValues.Constant(0);
      }
      component.ValueMultiplier = valueMultiplier ?? component.ValueMultiplier;
      if (component.ValueMultiplier is null)
      {
        component.ValueMultiplier = ContextValues.Constant(0);
      }
      return AddUniqueComponent(component, mergeBehavior, merge);
    }

    /// <summary>
    /// Adds <see cref="SaveSuccessIfBonus"/>
    /// </summary>
    ///
    /// <remarks>
    ///
    /// <list type="bullet">
    /// <listheader>Used by</listheader>
    /// <item><term>SecretOfQuellingDisastersBuff</term><description>25efcab5ea135c8428846c9e7b541c72</description></item>
    /// <item><term>SongOfHeroicResolveEffectBuff</term><description>4eafdc4608d89f84b82089953bc54e59</description></item>
    /// </list>
    /// </remarks>
    public TBuilder AddSaveSuccessIfBonus(
        ContextValue? value = null)
    {
      var component = new SaveSuccessIfBonus();
      component.Value = value ?? component.Value;
      if (component.Value is null)
      {
        component.Value = ContextValues.Constant(0);
      }
      return AddComponent(component);
    }

    /// <summary>
    /// Adds <see cref="ShieldFocus"/>
    /// </summary>
    ///
    /// <remarks>
    ///
    /// <para>
    /// ComponentName: Add AC if owner has shield
    /// </para>
    ///
    /// <list type="bullet">
    /// <listheader>Used by</listheader>
    /// <item><term>ShieldFocus</term><description>ac57069b6bf8c904086171683992a92a</description></item>
    /// <item><term>ShieldFocusGreater</term><description>afd05ca5363036c44817c071189b67e1</description></item>
    /// </list>
    /// </remarks>
    ///
    /// <param name="merge">
    /// If mergeBehavior is ComponentMerge.Merge and the component already exists, this expression is called to merge the components.
    /// </param>
    /// <param name="mergeBehavior">
    /// Handling if the component already exists since the component is unique. Defaults to ComponentMerge.Fail.
    /// </param>
    public TBuilder AddShieldFocus(
        Action<BlueprintComponent, BlueprintComponent>? merge = null,
        ComponentMerge mergeBehavior = ComponentMerge.Merge)
    {
      var component = new ShieldFocus();
      return AddUniqueComponent(component, mergeBehavior, merge);
    }

    /// <summary>
    /// Adds <see cref="SkillSuccessIfBonus"/>
    /// </summary>
    ///
    /// <remarks>
    ///
    /// <list type="bullet">
    /// <listheader>Used by</listheader>
    /// <item><term>SecretOfAccomplishmentBuff</term><description>a788fb25492c4314e8a43a3f47b80424</description></item>
    /// </list>
    /// </remarks>
    public TBuilder AddSkillSuccessIfBonus(
        ContextValue? value = null)
    {
      var component = new SkillSuccessIfBonus();
      component.Value = value ?? component.Value;
      if (component.Value is null)
      {
        component.Value = ContextValues.Constant(0);
      }
      return AddComponent(component);
    }

    /// <summary>
    /// Adds <see cref="SpeedBonusInArmorCategory"/>
    /// </summary>
    ///
    /// <remarks>
    ///
    /// <para>
    /// ComponentName: Add AC if owner has specific armor
    /// </para>
    ///
    /// <list type="bullet">
    /// <listheader>Used by</listheader>
    /// <item><term>ArmoredHulkArmoredSwiftness</term><description>f95f4f3a10917114c82bcbebc4d0fd36</description></item>
    /// <item><term>BloodragerFastMovement</term><description>5a7eb193611e0f642bfa6da16fe22b5a</description></item>
    /// <item><term>SteelbloodArmoredSwiftness</term><description>bd4397ee26a3baf4cadaeb766b018cff</description></item>
    /// </list>
    /// </remarks>
    ///
    /// <param name="merge">
    /// If mergeBehavior is ComponentMerge.Merge and the component already exists, this expression is called to merge the components.
    /// </param>
    /// <param name="mergeBehavior">
    /// Handling if the component already exists since the component is unique. Defaults to ComponentMerge.Fail.
    /// </param>
    public TBuilder AddSpeedBonusInArmorCategory(
        int? bonus = null,
        ArmorProficiencyGroup[]? category = null,
        ModifierDescriptor? descriptor = null,
        Action<BlueprintComponent, BlueprintComponent>? merge = null,
        ComponentMerge mergeBehavior = ComponentMerge.Merge,
        bool? noArmor = null)
    {
      var component = new SpeedBonusInArmorCategory();
      component.Bonus = bonus ?? component.Bonus;
      component.Category = category ?? component.Category;
      if (component.Category is null)
      {
        component.Category = new ArmorProficiencyGroup[0];
      }
      component.Descriptor = descriptor ?? component.Descriptor;
      component.NoArmor = noArmor ?? component.NoArmor;
      return AddUniqueComponent(component, mergeBehavior, merge);
    }

    /// <summary>
    /// Adds <see cref="SpellTurning"/>
    /// </summary>
    ///
    /// <remarks>
    ///
    /// <list type="bullet">
    /// <listheader>Used by</listheader>
    /// <item><term>Valmallos_Feature_SpellTurning</term><description>2021295715794845806aeec7ae26641a</description></item>
    /// </list>
    /// </remarks>
    ///
    /// <param name="specificSpellsOnly">
    /// <para>
    /// Blueprint of type BlueprintAbility. You can pass in the blueprint using:
    /// <list type ="bullet">
    ///   <item><term>A blueprint instance</term></item>
    ///   <item><term>A blueprint reference</term></item>
    ///   <item><term>A blueprint id as a string, Guid, or BlueprintGuid</term></item>
    ///   <item><term>A blueprint name registered with <see cref="BlueprintCore.Utils.BlueprintTool">BlueprintTool</see></term></item>
    /// </list>
    /// See <see cref="BlueprintCore.Utils.Blueprint{{T, TRef}}">Blueprint</see> for more details.
    /// </para>
    /// </param>
    /// <param name="spellDescriptorOnly">
    /// <para>
    /// InfoBox: Only spells with any of those descriptors will be turned. None means all
    /// </para>
    /// </param>
    /// <param name="spellResistanceOnly">
    /// <para>
    /// InfoBox: If true works only for spells with SR
    /// </para>
    /// </param>
    public TBuilder AddSpellTurning(
        List<Blueprint<BlueprintAbility, BlueprintAbilityReference>>? specificSpellsOnly = null,
        SpellDescriptorWrapper? spellDescriptorOnly = null,
        bool? spellResistanceOnly = null)
    {
      var component = new SpellTurning();
      component.m_SpecificSpellsOnly = specificSpellsOnly?.Select(bp => bp.Reference)?.ToArray() ?? component.m_SpecificSpellsOnly;
      if (component.m_SpecificSpellsOnly is null)
      {
        component.m_SpecificSpellsOnly = new BlueprintAbilityReference[0];
      }
      component.m_SpellDescriptorOnly = spellDescriptorOnly ?? component.m_SpellDescriptorOnly;
      component.m_SpellResistanceOnly = spellResistanceOnly ?? component.m_SpellResistanceOnly;
      return AddComponent(component);
    }

    /// <summary>
    /// Adds <see cref="StatBonusWeaponRestriction"/>
    /// </summary>
    ///
    /// <remarks>
    ///
    /// <para>
    /// ComponentName: Add AC if owner has shield
    /// </para>
    ///
    /// <list type="bullet">
    /// <listheader>Used by</listheader>
    /// <item><term>DuelingMastery</term><description>c3a66c1bbd2fb65498b130802d5f183a</description></item>
    /// </list>
    /// </remarks>
    ///
    /// <param name="merge">
    /// If mergeBehavior is ComponentMerge.Merge and the component already exists, this expression is called to merge the components.
    /// </param>
    /// <param name="mergeBehavior">
    /// Handling if the component already exists since the component is unique. Defaults to ComponentMerge.Fail.
    /// </param>
    public TBuilder AddStatBonusWeaponRestriction(
        WeaponCategory? category = null,
        bool? checkCategory = null,
        ModifierDescriptor? descriptor = null,
        bool? duelistWeapon = null,
        Action<BlueprintComponent, BlueprintComponent>? merge = null,
        ComponentMerge mergeBehavior = ComponentMerge.Merge,
        bool? oneHandedOnly = null,
        StatType? stat = null,
        int? value = null)
    {
      var component = new StatBonusWeaponRestriction();
      component.Category = category ?? component.Category;
      component.CheckCategory = checkCategory ?? component.CheckCategory;
      component.Descriptor = descriptor ?? component.Descriptor;
      component.DuelistWeapon = duelistWeapon ?? component.DuelistWeapon;
      component.OneHandedOnly = oneHandedOnly ?? component.OneHandedOnly;
      component.Stat = stat ?? component.Stat;
      component.Value = value ?? component.Value;
      return AddUniqueComponent(component, mergeBehavior, merge);
    }

    /// <summary>
    /// Adds <see cref="StonyStepTerrainBonus"/>
    /// </summary>
    ///
    /// <remarks>
    ///
    /// <list type="bullet">
    /// <listheader>Used by</listheader>
    /// <item><term>StonyStep</term><description>c542b083d72f19944a4c6bdf640fc099</description></item>
    /// </list>
    /// </remarks>
    ///
    /// <param name="merge">
    /// If mergeBehavior is ComponentMerge.Merge and the component already exists, this expression is called to merge the components.
    /// </param>
    /// <param name="mergeBehavior">
    /// Handling if the component already exists since the component is unique. Defaults to ComponentMerge.Fail.
    /// </param>
    public TBuilder AddStonyStepTerrainBonus(
        Action<BlueprintComponent, BlueprintComponent>? merge = null,
        ComponentMerge mergeBehavior = ComponentMerge.Merge,
        AreaSetting? setting = null)
    {
      var component = new StonyStepTerrainBonus();
      component.Setting = setting ?? component.Setting;
      return AddUniqueComponent(component, mergeBehavior, merge);
    }

    /// <summary>
    /// Adds <see cref="TemporaryHitPointsConstitutionBased"/>
    /// </summary>
    ///
    /// <remarks>
    ///
    /// <para>
    /// ComponentName: BuffMechanics/Speed modifier
    /// </para>
    ///
    /// <list type="bullet">
    /// <listheader>Used by</listheader>
    /// <item><term>InspireGreatnessEffectBuff</term><description>ec38c2e60d738584983415cb8a4f508d</description></item>
    /// </list>
    /// </remarks>
    public TBuilder AddTemporaryHitPointsConstitutionBased(
        int? bonusMultiplier = null,
        ModifierDescriptor? descriptor = null,
        ContextValue? value = null)
    {
      var component = new TemporaryHitPointsConstitutionBased();
      component.BonusMultiplier = bonusMultiplier ?? component.BonusMultiplier;
      component.Descriptor = descriptor ?? component.Descriptor;
      component.Value = value ?? component.Value;
      if (component.Value is null)
      {
        component.Value = ContextValues.Constant(0);
      }
      return AddComponent(component);
    }

    /// <summary>
    /// Adds <see cref="TemporaryHitPointsFromAbilityValue"/>
    /// </summary>
    ///
    /// <remarks>
    ///
    /// <para>
    /// ComponentName: BuffMechanics/Temporary Hit Points from Ability Value
    /// </para>
    ///
    /// <list type="bullet">
    /// <listheader>Used by</listheader>
    /// <item><term>AeonHPGazeAllyBuff</term><description>cc8a9fcfeab2e7146b5c5912350c38f1</description></item>
    /// <item><term>HeroicInvocationBuff</term><description>fd8fb2c1d622556468a04bea949eb7da</description></item>
    /// <item><term>VirtueBuff</term><description>a13ad2502d9e4904082868eb71efb0c5</description></item>
    /// </list>
    /// </remarks>
    public TBuilder AddTemporaryHitPointsFromAbilityValue(
        ModifierDescriptor? descriptor = null,
        bool? removeWhenHitPointsEnd = null,
        ContextValue? value = null)
    {
      var component = new TemporaryHitPointsFromAbilityValue();
      component.Descriptor = descriptor ?? component.Descriptor;
      component.RemoveWhenHitPointsEnd = removeWhenHitPointsEnd ?? component.RemoveWhenHitPointsEnd;
      component.Value = value ?? component.Value;
      if (component.Value is null)
      {
        component.Value = ContextValues.Constant(0);
      }
      return AddComponent(component);
    }

    /// <summary>
    /// Adds <see cref="TemporaryHitPointsPerLevel"/>
    /// </summary>
    ///
    /// <remarks>
    ///
    /// <list type="bullet">
    /// <listheader>Used by</listheader>
    /// <item><term>BloodragerStandartRageBuff</term><description>5eac31e457999334b98f98b60fc73b2f</description></item>
    /// <item><term>SeasonedWingsAndThighsBuff</term><description>b624888e1271b384fa4c70faf6f64912</description></item>
    /// <item><term>SucculentSausagesBuff</term><description>729d35b41fb6a834f9dd69d47f752bf0</description></item>
    /// </list>
    /// </remarks>
    ///
    /// <param name="limitlessRageBlueprint">
    /// <para>
    /// Blueprint of type BlueprintUnitFact. You can pass in the blueprint using:
    /// <list type ="bullet">
    ///   <item><term>A blueprint instance</term></item>
    ///   <item><term>A blueprint reference</term></item>
    ///   <item><term>A blueprint id as a string, Guid, or BlueprintGuid</term></item>
    ///   <item><term>A blueprint name registered with <see cref="BlueprintCore.Utils.BlueprintTool">BlueprintTool</see></term></item>
    /// </list>
    /// See <see cref="BlueprintCore.Utils.Blueprint{{T, TRef}}">Blueprint</see> for more details.
    /// </para>
    /// </param>
    /// <param name="limitlessRageResource">
    /// <para>
    /// Blueprint of type BlueprintAbilityResource. You can pass in the blueprint using:
    /// <list type ="bullet">
    ///   <item><term>A blueprint instance</term></item>
    ///   <item><term>A blueprint reference</term></item>
    ///   <item><term>A blueprint id as a string, Guid, or BlueprintGuid</term></item>
    ///   <item><term>A blueprint name registered with <see cref="BlueprintCore.Utils.BlueprintTool">BlueprintTool</see></term></item>
    /// </list>
    /// See <see cref="BlueprintCore.Utils.Blueprint{{T, TRef}}">Blueprint</see> for more details.
    /// </para>
    /// </param>
    public TBuilder AddTemporaryHitPointsPerLevel(
        ModifierDescriptor? descriptor = null,
        int? hitPointsPerLevel = null,
        bool? limitlessRage = null,
        Blueprint<BlueprintUnitFact, BlueprintUnitFactReference>? limitlessRageBlueprint = null,
        Blueprint<BlueprintAbilityResource, BlueprintAbilityResourceReference>? limitlessRageResource = null,
        bool? removeWhenHitPointsEnd = null,
        ContextValue? value = null)
    {
      var component = new TemporaryHitPointsPerLevel();
      component.Descriptor = descriptor ?? component.Descriptor;
      component.HitPointsPerLevel = hitPointsPerLevel ?? component.HitPointsPerLevel;
      component.LimitlessRage = limitlessRage ?? component.LimitlessRage;
      component.m_LimitlessRageBlueprint = limitlessRageBlueprint?.Reference ?? component.m_LimitlessRageBlueprint;
      if (component.m_LimitlessRageBlueprint is null)
      {
        component.m_LimitlessRageBlueprint = BlueprintTool.GetRef<BlueprintUnitFactReference>(null);
      }
      component.m_LimitlessRageResource = limitlessRageResource?.Reference ?? component.m_LimitlessRageResource;
      if (component.m_LimitlessRageResource is null)
      {
        component.m_LimitlessRageResource = BlueprintTool.GetRef<BlueprintAbilityResourceReference>(null);
      }
      component.RemoveWhenHitPointsEnd = removeWhenHitPointsEnd ?? component.RemoveWhenHitPointsEnd;
      component.Value = value ?? component.Value;
      if (component.Value is null)
      {
        component.Value = ContextValues.Constant(0);
      }
      return AddComponent(component);
    }

    /// <summary>
    /// Adds <see cref="TemporaryHitPointsRandom"/>
    /// </summary>
    ///
    /// <remarks>
    ///
    /// <para>
    /// ComponentName: BuffMechanics/Temporary Hit Points Random
    /// </para>
    ///
    /// <list type="bullet">
    /// <listheader>Used by</listheader>
    /// <item><term>AidBuff</term><description>319b4679f25779e4e9d04360381254e1</description></item>
    /// <item><term>PrimalRegressionBuff</term><description>9533218113624324293792ed113ea62b</description></item>
    /// <item><term>WhiteroseOystersBuffCompanionValerie</term><description>a46509cd6c8aff74d94d9259ac54956c</description></item>
    /// </list>
    /// </remarks>
    public TBuilder AddTemporaryHitPointsRandom(
        ContextValue? bonus = null,
        ModifierDescriptor? descriptor = null,
        DiceFormula? dice = null,
        bool? scaleBonusByCasterLevel = null)
    {
      var component = new TemporaryHitPointsRandom();
      component.Bonus = bonus ?? component.Bonus;
      if (component.Bonus is null)
      {
        component.Bonus = ContextValues.Constant(0);
      }
      component.Descriptor = descriptor ?? component.Descriptor;
      component.Dice = dice ?? component.Dice;
      component.ScaleBonusByCasterLevel = scaleBonusByCasterLevel ?? component.ScaleBonusByCasterLevel;
      return AddComponent(component);
    }

    /// <summary>
    /// Adds <see cref="TowerShieldSpecialistTotalCover"/>
    /// </summary>
    ///
    /// <remarks>
    ///
    /// <list type="bullet">
    /// <listheader>Used by</listheader>
    /// <item><term>TowerShieldTotalCover</term><description>4068bdf2373538e4fbd1c70438102f2e</description></item>
    /// </list>
    /// </remarks>
    ///
    /// <param name="merge">
    /// If mergeBehavior is ComponentMerge.Merge and the component already exists, this expression is called to merge the components.
    /// </param>
    /// <param name="mergeBehavior">
    /// Handling if the component already exists since the component is unique. Defaults to ComponentMerge.Fail.
    /// </param>
    public TBuilder AddTowerShieldSpecialistTotalCover(
        Action<BlueprintComponent, BlueprintComponent>? merge = null,
        ComponentMerge mergeBehavior = ComponentMerge.Merge)
    {
      var component = new TowerShieldSpecialistTotalCover();
      return AddUniqueComponent(component, mergeBehavior, merge);
    }

    /// <summary>
    /// Adds <see cref="WeaponTrainingBonuses"/>
    /// </summary>
    ///
    /// <remarks>
    ///
    /// <list type="bullet">
    /// <listheader>Used by</listheader>
    /// <item><term>CombatManeuverDefense</term><description>318ae316d7aed5143b7a8cbd25fd8e77</description></item>
    /// <item><term>FightersReflexes</term><description>8140fe21fd91da3439bf5ed017ca9f90</description></item>
    /// <item><term>TrainedInitiative</term><description>1054ea2fa21176249b96a63d54f02b17</description></item>
    /// </list>
    /// </remarks>
    ///
    /// <param name="merge">
    /// If mergeBehavior is ComponentMerge.Merge and the component already exists, this expression is called to merge the components.
    /// </param>
    /// <param name="mergeBehavior">
    /// Handling if the component already exists since the component is unique. Defaults to ComponentMerge.Fail.
    /// </param>
    public TBuilder AddWeaponTrainingBonuses(
        ModifierDescriptor? descriptor = null,
        Action<BlueprintComponent, BlueprintComponent>? merge = null,
        ComponentMerge mergeBehavior = ComponentMerge.Merge,
        StatType? stat = null)
    {
      var component = new WeaponTrainingBonuses();
      component.Descriptor = descriptor ?? component.Descriptor;
      component.Stat = stat ?? component.Stat;
      return AddUniqueComponent(component, mergeBehavior, merge);
    }

    /// <summary>
    /// Adds <see cref="WizardAbjurationResistance"/>
    /// </summary>
    ///
    /// <remarks>
    ///
    /// <para>
    /// ComponentName: Resist Energy
    /// </para>
    ///
    /// <list type="bullet">
    /// <listheader>Used by</listheader>
    /// <item><term>AbjurationResistanceAcidBuff</term><description>b87a0e8a961c63a44a952822fe975edb</description></item>
    /// <item><term>AbjurationResistanceElectricityBuff</term><description>453201f110f49714fb1d713c1f7bc06d</description></item>
    /// <item><term>AbjurationResistanceSonicBuff</term><description>63e2a6323c2bbff40a87fcd522778032</description></item>
    /// </list>
    /// </remarks>
    ///
    /// <param name="merge">
    /// If mergeBehavior is ComponentMerge.Merge and the component already exists, this expression is called to merge the components.
    /// </param>
    /// <param name="mergeBehavior">
    /// Handling if the component already exists since the component is unique. Defaults to ComponentMerge.Fail.
    /// </param>
    /// <param name="wizard">
    /// <para>
    /// Blueprint of type BlueprintCharacterClass. You can pass in the blueprint using:
    /// <list type ="bullet">
    ///   <item><term>A blueprint instance</term></item>
    ///   <item><term>A blueprint reference</term></item>
    ///   <item><term>A blueprint id as a string, Guid, or BlueprintGuid</term></item>
    ///   <item><term>A blueprint name registered with <see cref="BlueprintCore.Utils.BlueprintTool">BlueprintTool</see></term></item>
    /// </list>
    /// See <see cref="BlueprintCore.Utils.Blueprint{{T, TRef}}">Blueprint</see> for more details.
    /// </para>
    /// </param>
    public TBuilder AddWizardAbjurationResistance(
        Action<BlueprintComponent, BlueprintComponent>? merge = null,
        ComponentMerge mergeBehavior = ComponentMerge.Merge,
        ContextValue? pool = null,
        DamageEnergyType? type = null,
        bool? usePool = null,
        bool? useValueMultiplier = null,
        ContextValue? value = null,
        ContextValue? valueMultiplier = null,
        Blueprint<BlueprintCharacterClass, BlueprintCharacterClassReference>? wizard = null)
    {
      var component = new WizardAbjurationResistance();
      component.Pool = pool ?? component.Pool;
      if (component.Pool is null)
      {
        component.Pool = ContextValues.Constant(0);
      }
      component.Type = type ?? component.Type;
      component.UsePool = usePool ?? component.UsePool;
      component.UseValueMultiplier = useValueMultiplier ?? component.UseValueMultiplier;
      component.Value = value ?? component.Value;
      if (component.Value is null)
      {
        component.Value = ContextValues.Constant(0);
      }
      component.ValueMultiplier = valueMultiplier ?? component.ValueMultiplier;
      if (component.ValueMultiplier is null)
      {
        component.ValueMultiplier = ContextValues.Constant(0);
      }
      component.m_Wizard = wizard?.Reference ?? component.m_Wizard;
      if (component.m_Wizard is null)
      {
        component.m_Wizard = BlueprintTool.GetRef<BlueprintCharacterClassReference>(null);
      }
      return AddUniqueComponent(component, mergeBehavior, merge);
    }

    /// <summary>
    /// Adds <see cref="WizardEnergyAbsorption"/>
    /// </summary>
    ///
    /// <remarks>
    ///
    /// <para>
    /// ComponentName: Buffs/AddEffect/EnergyResistance
    /// </para>
    ///
    /// <list type="bullet">
    /// <listheader>Used by</listheader>
    /// <item><term>EnergyAbsorptionFeature</term><description>e0a0f1ec8dd1fb94d99f824c6f032c64</description></item>
    /// </list>
    /// </remarks>
    ///
    /// <param name="merge">
    /// If mergeBehavior is ComponentMerge.Merge and the component already exists, this expression is called to merge the components.
    /// </param>
    /// <param name="mergeBehavior">
    /// Handling if the component already exists since the component is unique. Defaults to ComponentMerge.Fail.
    /// </param>
    /// <param name="resource">
    /// <para>
    /// Blueprint of type BlueprintAbilityResource. You can pass in the blueprint using:
    /// <list type ="bullet">
    ///   <item><term>A blueprint instance</term></item>
    ///   <item><term>A blueprint reference</term></item>
    ///   <item><term>A blueprint id as a string, Guid, or BlueprintGuid</term></item>
    ///   <item><term>A blueprint name registered with <see cref="BlueprintCore.Utils.BlueprintTool">BlueprintTool</see></term></item>
    /// </list>
    /// See <see cref="BlueprintCore.Utils.Blueprint{{T, TRef}}">Blueprint</see> for more details.
    /// </para>
    /// </param>
    public TBuilder AddWizardEnergyAbsorption(
        Action<BlueprintComponent, BlueprintComponent>? merge = null,
        ComponentMerge mergeBehavior = ComponentMerge.Merge,
        ContextValue? pool = null,
        Blueprint<BlueprintAbilityResource, BlueprintAbilityResourceReference>? resource = null,
        DamageEnergyType? type = null,
        bool? usePool = null,
        bool? useValueMultiplier = null,
        ContextValue? value = null,
        ContextValue? valueMultiplier = null)
    {
      var component = new WizardEnergyAbsorption();
      component.Pool = pool ?? component.Pool;
      if (component.Pool is null)
      {
        component.Pool = ContextValues.Constant(0);
      }
      component.m_Resource = resource?.Reference ?? component.m_Resource;
      if (component.m_Resource is null)
      {
        component.m_Resource = BlueprintTool.GetRef<BlueprintAbilityResourceReference>(null);
      }
      component.Type = type ?? component.Type;
      component.UsePool = usePool ?? component.UsePool;
      component.UseValueMultiplier = useValueMultiplier ?? component.UseValueMultiplier;
      component.Value = value ?? component.Value;
      if (component.Value is null)
      {
        component.Value = ContextValues.Constant(0);
      }
      component.ValueMultiplier = valueMultiplier ?? component.ValueMultiplier;
      if (component.ValueMultiplier is null)
      {
        component.ValueMultiplier = ContextValues.Constant(0);
      }
      return AddUniqueComponent(component, mergeBehavior, merge);
    }

    /// <summary>
    /// Adds <see cref="ModifyOutgoingHealAmount"/>
    /// </summary>
    ///
    /// <remarks>
    ///
    /// <list type="bullet">
    /// <listheader>Used by</listheader>
    /// </list>
    /// </remarks>
    ///
    /// <param name="facts">
    /// <para>
    /// Blueprint of type BlueprintUnitFact. You can pass in the blueprint using:
    /// <list type ="bullet">
    ///   <item><term>A blueprint instance</term></item>
    ///   <item><term>A blueprint reference</term></item>
    ///   <item><term>A blueprint id as a string, Guid, or BlueprintGuid</term></item>
    ///   <item><term>A blueprint name registered with <see cref="BlueprintCore.Utils.BlueprintTool">BlueprintTool</see></term></item>
    /// </list>
    /// See <see cref="BlueprintCore.Utils.Blueprint{{T, TRef}}">Blueprint</see> for more details.
    /// </para>
    /// </param>
    public TBuilder AddModifyOutgoingHealAmount(
        List<Blueprint<BlueprintUnitFact, BlueprintUnitFactReference>>? facts = null,
        float? multiplierIfHasAnyFact = null,
        float? multiplierIfHasNoFacts = null)
    {
      var component = new ModifyOutgoingHealAmount();
      component.m_Facts = facts?.Select(bp => bp.Reference)?.ToArray() ?? component.m_Facts;
      if (component.m_Facts is null)
      {
        component.m_Facts = new BlueprintUnitFactReference[0];
      }
      component.MultiplierIfHasAnyFact = multiplierIfHasAnyFact ?? component.MultiplierIfHasAnyFact;
      component.MultiplierIfHasNoFacts = multiplierIfHasNoFacts ?? component.MultiplierIfHasNoFacts;
      return AddComponent(component);
    }
  }
}
